
bonsoir, 
je veux faire une application web qui fera la teleconsultation. cette application doit avoir une interface graphique très riche avec react js et material UI. le backend se fera avec spring boot. nous 4 types d'utilisateurs. le medecin, le patient, le secratire medical et l'administrateur. les inscriptions des medecins, patient et secretaire devront etre validées par l'admin. le patient pourra uploader ces images DICOM(le mecanisme se fera avec le serveur orthanc). il pourra consuter son dossier medical dans lequel il y a les observations du médecin, il pourra consulter ses rendez-vous. le medecin pourra consulter ses rendez-vous et eventuellement les valider ou les rejetter avant que le patient ait accès à ce rendez-vous. le patient ne peut que voir un rendez-vous deja validé. le medecin peut consulter uniquement les dossiers medicaux de ses patients, faire des observations qui seront enregistrées dans le dossier medical concerné. il pourra voir les images DICOM uploadé par son patient à partir de son dossier medical. le secretaire est chargé de planifier les rendez-vous. il pourra ensuite les supprimer ou les modifier et il verra tous les rendez-vous. il doit un systeme de notification. quand le secrettaire planifie un rendez-vous, le medecin recoit un mail. ensuite quand le medecin valide le rendez-vous. le patient concerné recoit un mail aussi.  l'interface graphique doit être très riche. nous allons utiliser postgresql.

faisons une approche itérative étape par étape avec des tests avant de passer aux niveaux suivants
La modification de ce message créera une nouvelle branche de conversation. Vous pouvez basculer entre les branches en utilisant les boutons de navigation fléchés.
Bonsoir! Je comprends que vous souhaitez développer une application web de téléconsultation avec une interface riche en utilisant React JS et Material UI pour le frontend, et Spring Boot pour le backend. Je vais vous aider à concevoir cette application de manière itérative.




mais tu es allé très rapidement

Modifier
Je comprends que j'ai été trop rapide dans mon développement. Prenons le temps de mieux structurer notre approche. Commençons avec une vision plus détaillée de notre application de téléconsultation, étape par étape.

Planification itérative du développement
Voici une approche plus structurée et progressive:

Phase 1: Configuration initiale et architecture
Mise en place du projet Spring Boot (backend)
Mise en place du projet React (frontend)
Configuration de la base de données PostgreSQL
Définition des entités de base
Phase 2: Authentification et gestion des utilisateurs
Développement des fonctionnalités d'inscription
Développement de la connexion
Gestion des autorisations
Phase 3: Fonctionnalités de base pour les différents utilisateurs
Développement du tableau de bord administrateur
Développement du tableau de bord médecin
Développement du tableau de bord patient
Développement du tableau de bord secrétaire
Phase 4: Gestion des rendez-vous
Planification des rendez-vous par le secrétaire
Validation/rejet des rendez-vous par le médecin
Consultation des rendez-vous par le patient
Phase 5: Dossiers médicaux
Création et consultation des dossiers médicaux
Ajout d'observations par le médecin
Consultation des dossiers par le patient
Phase 6: Intégration d'Orthanc pour les images DICOM
Configuration du serveur Orthanc
Upload d'images DICOM par le patient
Visualisation des images DICOM par le médecin
Phase 7: Système de notification
Notifications par email
Notifications dans l'application
Phase 8: Tests et déploiement
Tests unitaires et d'intégration
Déploiement de l'application
Commençons par la première phase:

Phase 1: Configuration initiale et architecture
1.1 Configuration du projet Spring Boot (Backend)
Créons d'abord un projet Spring Boot avec les dépendances nécessaires:

- Spring Web
- Spring Data JPA
- Spring Security
- PostgreSQL Driver
- Lombok
- Spring Mail
- Spring Boot DevTools
Voici le fichier pom.xml pour notre projet:

xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.0</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.teleconsultation</groupId>
    <artifactId>api</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>Teleconsultation API</name>
    <description>API for teleconsultation application</description>

    <properties>
        <java.version>11</java.version>
    </properties>

    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>

        <!-- PostgreSQL Driver -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- JWT -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.11.5</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>

        <!-- Test Dependencies -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- Development Tools -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
1.2 Configuration de la base de données
Configurons notre base de données PostgreSQL dans le fichier application.properties:

properties
# Configuration de la base de données
spring.datasource.url=jdbc:postgresql://localhost:5432/teleconsultation_db
spring.datasource.username=postgres
spring.datasource.password=password
spring.jpa.hibernate.ddl-auto=update
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.show-sql=true

# Configuration du serveur
server.port=8080

# Configuration pour les emails
spring.mail.host=smtp.gmail.com
spring.mail.port=587
spring.mail.username=votre-email@gmail.com
spring.mail.password=votre-mot-de-passe
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true

# Configuration pour JWT
app.jwt.secret=Votre_Clé_Secrète_Pour_JWT_Très_Longue_Et_Sécurisée
app.jwt.expiration=86400000

# Configuration pour Orthanc
orthanc.server.url=http://localhost:8042
orthanc.server.username=orthanc
orthanc.server.password=orthanc
1.3 Définition des entités de base
Commençons par créer nos entités principales:

User.java (Classe de base pour tous les utilisateurs)
java
package com.teleconsultation.api.models;

import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;

import javax.persistence.*;
import javax.validation.constraints.Email;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Size;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Data
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
@Table(name = "users")
public abstract class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @NotBlank
    @Size(max = 50)
    private String nom;
    
    @NotBlank
    @Size(max = 50)
    private String prenom;
    
    @NotBlank
    @Size(max = 100)
    @Email
    @Column(unique = true)
    private String email;
    
    @NotBlank
    @Size(max = 120)
    private String motDePasse;
    
    @Size(max = 20)
    private String telephone;
    
    private boolean compteValide = false;
    
    private boolean actif = true;
    
    @CreationTimestamp
    private LocalDateTime dateCreation;
    
    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(
        name = "user_roles",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id")
    )
    private Set<Role> roles = new HashSet<>();
}
Role.java
java
package com.teleconsultation.api.models;

import lombok.Data;
import lombok.NoArgsConstructor;

import javax.persistence.*;

@Data
@Entity
@NoArgsConstructor
@Table(name = "roles")
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Enumerated(EnumType.STRING)
    @Column(length = 20)
    private ERole name;
    
    public Role(ERole name) {
        this.name = name;
    }
}
ERole.java (Énumération des rôles)
java
package com.teleconsultation.api.models;

public enum ERole {
    ROLE_ADMIN,
    ROLE_MEDECIN,
    ROLE_PATIENT,
    ROLE_SECRETAIRE
}
Patient.java
java
package com.teleconsultation.api.models;

import lombok.Data;
import lombok.EqualsAndHashCode;

import javax.persistence.*;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

@Data
@EqualsAndHashCode(callSuper = true)
@Entity
@Table(name = "patients")
public class Patient extends User {
    
    private String numeroSecuriteSociale;
    
    private LocalDate dateNaissance;
    
    private String adresse;
    
    @OneToMany(mappedBy = "patient", cascade = CascadeType.ALL)
    private List<DossierMedical> dossiersMedicaux = new ArrayList<>();
    
    @OneToMany(mappedBy = "patient")
    private List<RendezVous> rendezVous = new ArrayList<>();
}
Medecin.java
java
package com.teleconsultation.api.models;

import lombok.Data;
import lombok.EqualsAndHashCode;

import javax.persistence.*;
import java.util.ArrayList;
import java.util.List;

@Data
@EqualsAndHashCode(callSuper = true)
@Entity
@Table(name = "medecins")
public class Medecin extends User {
    
    private String specialite;
    
    private String numeroOrdre;
    
    @OneToMany(mappedBy = "medecin")
    private List<RendezVous> rendezVous = new ArrayList<>();
    
    @OneToMany(mappedBy = "medecin")
    private List<DossierMedical> dossiersMedicaux = new ArrayList<>();
}
SecretaireMedical.java
java
package com.teleconsultation.api.models;

import lombok.Data;
import lombok.EqualsAndHashCode;

import javax.persistence.Entity;
import javax.persistence.Table;

@Data
@EqualsAndHashCode(callSuper = true)
@Entity
@Table(name = "secretaires")
public class SecretaireMedical extends User {
    // Attributs spécifiques aux secrétaires médicaux
    private String service;
}
Admin.java
java
package com.teleconsultation.api.models;

import lombok.Data;
import lombok.EqualsAndHashCode;

import javax.persistence.Entity;
import javax.persistence.Table;

@Data
@EqualsAndHashCode(callSuper = true)
@Entity
@Table(name = "admins")
public class Admin extends User {
    // Attributs spécifiques aux administrateurs si nécessaire
}
RendezVous.java
java
package com.teleconsultation.api.models;

import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;

import javax.persistence.*;
import java.time.LocalDateTime;

@Data
@Entity
@Table(name = "rendez_vous")
public class RendezVous {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "patient_id")
    private Patient patient;
    
    @ManyToOne
    @JoinColumn(name = "medecin_id")
    private Medecin medecin;
    
    private LocalDateTime dateHeure;
    
    private int duree; // en minutes
    
    private String motif;
    
    @Enumerated(EnumType.STRING)
    private StatutRendezVous statut = StatutRendezVous.PLANIFIE;
    
    @CreationTimestamp
    private LocalDateTime dateCreation;
}
StatutRendezVous.java
java
package com.teleconsultation.api.models;

public enum StatutRendezVous {
    PLANIFIE,
    VALIDE,
    REJETE,
    ANNULE,
    TERMINE
}
DossierMedical.java
java
package com.teleconsultation.api.models;

import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;

import javax.persistence.*;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Data
@Entity
@Table(name = "dossiers_medicaux")
public class DossierMedical {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "patient_id")
    private Patient patient;
    
    @ManyToOne
    @JoinColumn(name = "medecin_id")
    private Medecin medecin;
    
    @OneToMany(mappedBy = "dossierMedical", cascade = CascadeType.ALL)
    private List<Observation> observations = new ArrayList<>();
    
    @OneToMany(mappedBy = "dossierMedical", cascade = CascadeType.ALL)
    private List<ImageDICOM> imagesDICOM = new ArrayList<>();
    
    @CreationTimestamp
    private LocalDateTime dateCreation;
}
Observation.java
java
package com.teleconsultation.api.models;

import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;

import javax.persistence.*;
import java.time.LocalDateTime;

@Data
@Entity
@Table(name = "observations")
public class Observation {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "dossier_id")
    private DossierMedical dossierMedical;
    
    @ManyToOne
    @JoinColumn(name = "medecin_id")
    private Medecin medecin;
    
    @Column(columnDefinition = "TEXT")
    private String contenu;
    
    @CreationTimestamp
    private LocalDateTime dateCreation;
}
ImageDICOM.java
java
package com.teleconsultation.api.models;

import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;

import javax.persistence.*;
import java.time.LocalDateTime;

@Data
@Entity
@Table(name = "images_dicom")
public class ImageDICOM {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "dossier_id")
    private DossierMedical dossierMedical;
    
    private String orthancId; // Identifiant de l'image sur le serveur Orthanc
    
    private String description;
    
    @CreationTimestamp
    private LocalDateTime dateUpload;
}
1.4 Configuration du projet React (Frontend)
Maintenant, créons notre application frontend avec React et Material UI:

bash
npx create-react-app teleconsultation-frontend
cd teleconsultation-frontend

# Installation des dépendances
npm install @mui/material @mui/icons-material @emotion/react @emotion/styled
npm install react-router-dom axios jwt-decode
npm install @mui/x-data-grid @mui/lab @mui/x-date-pickers
npm install date-fns
Organisons notre structure de dossiers:

src/
│
├── assets/          # Images, CSS, etc.
├── components/      # Composants réutilisables
│   ├── common/      # Composants communs (Header, Footer, etc.)
│   ├── admin/       # Composants spécifiques à l'admin
│   ├── medecin/     # Composants spécifiques au médecin
│   ├── patient/     # Composants spécifiques au patient
│   └── secretaire/  # Composants spécifiques au secrétaire
│
├── pages/           # Pages principales de l'application
├── services/        # Services pour les appels API
├── utils/           # Fonctions utilitaires
├── context/         # Contexte React (authentification, etc.)
├── hooks/           # Hooks personnalisés
└── routes/          # Configuration des routes
Créons quelques fichiers de base:

src/index.js
jsx
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import { BrowserRouter } from 'react-router-dom';
import { AuthProvider } from './context/AuthContext';

ReactDOM.render(
  <React.StrictMode>
    <BrowserRouter>
      <AuthProvider>
        <App />
      </AuthProvider>
    </BrowserRouter>
  </React.StrictMode>,
  document.getElementById('root')
);
src/App.js
jsx
import React from 'react';
import { Routes, Route, Navigate } from 'react-router-dom';
import { ThemeProvider, createTheme } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { LocalizationProvider } from '@mui/x-date-pickers';
import { frFR } from '@mui/material/locale';
import { fr } from 'date-fns/locale';

// Pages
import Login from './pages/Login';
import Register from './pages/Register';
import NotFound from './pages/NotFound';

// Layouts
import AdminLayout from './components/layouts/AdminLayout';
import MedecinLayout from './components/layouts/MedecinLayout';
import PatientLayout from './components/layouts/PatientLayout';
import SecretaireLayout from './components/layouts/SecretaireLayout';

// Route Guards
import PrivateRoute from './routes/PrivateRoute';
import RoleRoute from './routes/RoleRoute';

// Context
import { useAuth } from './context/AuthContext';

// Thème personnalisé
const theme = createTheme({
  palette: {
    primary: {
      main: '#2196f3',
    },
    secondary: {
      main: '#f50057',
    },
  },
}, frFR);

function App() {
  const { isAuthenticated, userRole } = useAuth();

  return (
    <ThemeProvider theme={theme}>
      <LocalizationProvider dateAdapter={AdapterDateFns} locale={fr}>
        <CssBaseline />
        <Routes>
          {/* Public Routes */}
          <Route path="/login" element={!isAuthenticated ? <Login /> : <Navigate to="/redirect" />} />
          <Route path="/register" element={!isAuthenticated ? <Register /> : <Navigate to="/redirect" />} />
          
          {/* Redirect based on role */}
          <Route 
            path="/redirect" 
            element={
              isAuthenticated ? (
                userRole === 'ROLE_ADMIN' ? <Navigate to="/admin/dashboard" /> :
                userRole === 'ROLE_MEDECIN' ? <Navigate to="/medecin/dashboard" /> :
                userRole === 'ROLE_PATIENT' ? <Navigate to="/patient/dashboard" /> :
                userRole === 'ROLE_SECRETAIRE' ? <Navigate to="/secretaire/dashboard" /> :
                <Navigate to="/login" />
              ) : <Navigate to="/login" />
            } 
          />
          
          {/* Protected Routes */}
          <Route path="/admin/*" element={
            <RoleRoute requiredRole="ROLE_ADMIN">
              <AdminLayout />
            </RoleRoute>
          } />
          
          <Route path="/medecin/*" element={
            <RoleRoute requiredRole="ROLE_MEDECIN">
              <MedecinLayout />
            </RoleRoute>
          } />
          
          <Route path="/patient/*" element={
            <RoleRoute requiredRole="ROLE_PATIENT">
              <PatientLayout />
            </RoleRoute>
          } />
          
          <Route path="/secretaire/*" element={
            <RoleRoute requiredRole="ROLE_SECRETAIRE">
              <SecretaireLayout />
            </RoleRoute>
          } />
          
          {/* Redirect root to login or dashboard */}
          <Route path="/" element={<Navigate to={isAuthenticated ? "/redirect" : "/login"} />} />
          
          {/* 404 Not Found */}
          <Route path="*" element={<NotFound />} />
        </Routes>
      </LocalizationProvider>
    </ThemeProvider>
  );
}

export default App;
src/context/AuthContext.js
jsx
import React, { createContext, useState, useContext, useEffect } from 'react';
import jwt_decode from 'jwt-decode';
import { login, register, logout } from '../services/authService';

const AuthContext = createContext();

export function useAuth() {
  return useContext(AuthContext);
}

export function AuthProvider({ children }) {
  const [currentUser, setCurrentUser] = useState(null);
  const [userRole, setUserRole] = useState(null);
  const [loading, setLoading] = useState(true);
  const [isAuthenticated, setIsAuthenticated] = useState(false);

  useEffect(() => {
    // Vérifier si un token existe déjà
    const token = localStorage.getItem('token');
    
    if (token) {
      try {
        // Vérifier si le token est valide
        const decodedToken = jwt_decode(token);
        const currentTime = Date.now() / 1000;
        
        if (decodedToken.exp > currentTime) {
          // Token valide, récupérer les informations de l'utilisateur
          setCurrentUser(decodedToken.user);
          setUserRole(decodedToken.roles[0]); // Supposons que nous prenons le premier rôle
          setIsAuthenticated(true);
        } else {
          // Token expiré, nettoyer
          handleLogout();
        }
      } catch (error) {
        // Erreur de décodage, nettoyer
        handleLogout();
      }
    }
    
    setLoading(false);
  }, []);

  const handleLogin = async (email, password) => {
    try {
      const response = await login(email, password);
      const { token, user } = response.data;
      
      // Stocker le token et les infos utilisateur
      localStorage.setItem('token', token);
      setCurrentUser(user);
      setUserRole(user.roles[0].name); // Supposons que nous prenons le premier rôle
      setIsAuthenticated(true);
      
      return { success: true, user };
    } catch (error) {
      return { 
        success: false, 
        message: error.response?.data?.message || 'Erreur lors de la connexion' 
      };
    }
  };

  const handleRegister = async (userData, role) => {
    try {
      const response = await register(userData, role);
      return { success: true, data: response.data };
    } catch (error) {
      return { 
        success: false, 
        message: error.response?.data?.message || 'Erreur lors de l\'inscription' 
      };
    }
  };

  const handleLogout = () => {
    // Nettoyer les données de session
    localStorage.removeItem('token');
    setCurrentUser(null);
    setUserRole(null);
    setIsAuthenticated(false);
    
    // Appel au service de déconnexion
    logout();
  };

  const value = {
    currentUser,
    userRole,
    isAuthenticated,
    login: handleLogin,
    register: handleRegister,
    logout: handleLogout
  };

  return (
    <AuthContext.Provider value={value}>
      {!loading && children}
    </AuthContext.Provider>
  );
}
src/routes/PrivateRoute.js
jsx
import React from 'react';
import { Navigate } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

const PrivateRoute = ({ children }) => {
  const { isAuthenticated } = useAuth();

  return isAuthenticated ? children : <Navigate to="/login" />;
};

export default PrivateRoute;
src/routes/RoleRoute.js
jsx
import React from 'react';
import { Navigate } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

const RoleRoute = ({ children, requiredRole }) => {
  const { isAuthenticated, userRole } = useAuth();

  if (!isAuthenticated) {
    return <Navigate to="/login" />;
  }

  if (userRole !== requiredRole) {
    return <Navigate to="/unauthorized" />;
  }

  return children;
};

export default RoleRoute;
src/services/authService.js
jsx
import axios from 'axios';
import { API_URL } from '../config';

// Configurer l'intercepteur pour ajouter le token JWT aux requêtes
axios.interceptors.request.use(config => {
  const token = localStorage.getItem('token');
  
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  
  return config;
}, error => {
  return Promise.reject(error);
});

// Connexion
export const login = (email, password) => {
  return axios.post(`${API_URL}/auth/login`, { email, password });
};

// Inscription
export const register = (userData, role) => {
  return axios.post(`${API_URL}/auth/register/${role}`, userData);
};

// Déconnexion
export const logout = () => {
  // Pas besoin d'appel API, nettoyage côté client uniquement
  return true;
};

// Vérifier si le token est valide
export const verifyToken = () => {
  return axios.get(`${API_URL}/auth/verify`);
};
src/config.js
jsx
export const API_URL = 'http://localhost:8080/api';
C'est un bon début pour notre configuration initiale. À ce stade, nous avons:

Configuré le projet Spring Boot avec les dépendances nécessaires
Défini nos entités principales pour le backend
Configuré la base de données PostgreSQL
Créé la structure de base du projet React avec Material UI
Mis en place le contexte d'authentification pour le frontend
Dans les prochaines étapes, nous allons développer les fonctionnalités d'authentification côté backend, puis progressivement ajouter les fonctionnalités nécessaires pour chaque type d'utilisateur.




ceci est la phase 1 ?

Modifier
Oui, tout ce que j'ai détaillé représente la Phase 1 de notre développement, qui se concentre sur la configuration initiale et l'architecture de notre application de téléconsultation.

Pour résumer ce que nous avons fait dans cette première phase:

Configuration du backend (Spring Boot):
Mise en place du fichier pom.xml avec toutes les dépendances nécessaires
Configuration de la base de données PostgreSQL via application.properties
Configuration des paramètres pour JWT, emails et Orthanc
Définition des entités du modèle de données:
Création d'une hiérarchie d'utilisateurs (User comme classe abstraite)
Définition des entités spécifiques (Patient, Médecin, Secrétaire, Admin)
Modélisation des rendez-vous, dossiers médicaux, observations et images DICOM
Configuration du frontend (React):
Initialisation avec create-react-app
Installation des bibliothèques nécessaires (Material UI, React Router, etc.)
Organisation de la structure de fichiers
Mise en place de l'authentification:
Contexte d'authentification React
Services pour la gestion des appels API
Routes protégées basées sur les rôles
Cette phase établit la fondation sur laquelle nous allons construire toutes les fonctionnalités de notre application. Dans la Phase 2, nous nous concentrerons sur le développement complet du système d'authentification et la gestion des utilisateurs.

Souhaitez-vous que nous passions à la Phase 2 maintenant ou préférez-vous discuter plus en détail de certains aspects de la Phase 1?




j'ai fini de mettre en place la phase 1, on peut continuer

Modifier


Parfait ! Maintenant que la Phase 1 est en place, passons à la Phase 2 qui se concentre sur l'authentification et la gestion des utilisateurs.

Phase 2: Authentification et gestion des utilisateurs
2.1 Développement du backend pour l'authentification
Commençons par créer les composants nécessaires côté backend pour gérer l'authentification avec JWT.

SecurityConfig.java
java
package com.teleconsultation.api.config;

import com.teleconsultation.api.security.jwt.AuthEntryPointJwt;
import com.teleconsultation.api.security.jwt.AuthTokenFilter;
import com.teleconsultation.api.security.services.UserDetailsServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;

@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    
    @Autowired
    UserDetailsServiceImpl userDetailsService;

    @Autowired
    private AuthEntryPointJwt unauthorizedHandler;

    @Bean
    public AuthTokenFilter authenticationJwtTokenFilter() {
        return new AuthTokenFilter();
    }

    @Override
    public void configure(AuthenticationManagerBuilder authenticationManagerBuilder) throws Exception {
        authenticationManagerBuilder.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());
    }

    @Bean
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList("http://localhost:3000")); // Origine du frontend
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("Authorization", "Content-Type"));
        configuration.setAllowCredentials(true);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.cors().configurationSource(corsConfigurationSource()).and().csrf().disable()
            .exceptionHandling().authenticationEntryPoint(unauthorizedHandler).and()
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()
            .authorizeRequests()
            .antMatchers("/api/auth/**").permitAll() // Endpoints d'authentification publics
            .antMatchers("/api/public/**").permitAll() // Autres endpoints publics
            .anyRequest().authenticated();

        http.addFilterBefore(authenticationJwtTokenFilter(), UsernamePasswordAuthenticationFilter.class);
    }
}
JwtUtils.java
java
package com.teleconsultation.api.security.jwt;

import com.teleconsultation.api.security.services.UserDetailsImpl;
import io.jsonwebtoken.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;

import java.util.Date;

@Component
public class JwtUtils {
    private static final Logger logger = LoggerFactory.getLogger(JwtUtils.class);

    @Value("${app.jwt.secret}")
    private String jwtSecret;

    @Value("${app.jwt.expiration}")
    private int jwtExpirationMs;

    public String generateJwtToken(Authentication authentication) {
        UserDetailsImpl userPrincipal = (UserDetailsImpl) authentication.getPrincipal();

        return Jwts.builder()
                .setSubject(userPrincipal.getUsername())
                .setIssuedAt(new Date())
                .setExpiration(new Date((new Date()).getTime() + jwtExpirationMs))
                .signWith(SignatureAlgorithm.HS512, jwtSecret)
                .compact();
    }

    public String getUserNameFromJwtToken(String token) {
        return Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(token).getBody().getSubject();
    }

    public boolean validateJwtToken(String authToken) {
        try {
            Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(authToken);
            return true;
        } catch (SignatureException e) {
            logger.error("Invalid JWT signature: {}", e.getMessage());
        } catch (MalformedJwtException e) {
            logger.error("Invalid JWT token: {}", e.getMessage());
        } catch (ExpiredJwtException e) {
            logger.error("JWT token is expired: {}", e.getMessage());
        } catch (UnsupportedJwtException e) {
            logger.error("JWT token is unsupported: {}", e.getMessage());
        } catch (IllegalArgumentException e) {
            logger.error("JWT claims string is empty: {}", e.getMessage());
        }

        return false;
    }
}
AuthTokenFilter.java
java
package com.teleconsultation.api.security.jwt;

import com.teleconsultation.api.security.services.UserDetailsServiceImpl;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class AuthTokenFilter extends OncePerRequestFilter {
    @Autowired
    private JwtUtils jwtUtils;

    @Autowired
    private UserDetailsServiceImpl userDetailsService;

    private static final Logger logger = LoggerFactory.getLogger(AuthTokenFilter.class);

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        try {
            String jwt = parseJwt(request);
            if (jwt != null && jwtUtils.validateJwtToken(jwt)) {
                String username = jwtUtils.getUserNameFromJwtToken(jwt);

                UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
                        userDetails, null, userDetails.getAuthorities());
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception e) {
            logger.error("Cannot set user authentication: {}", e);
        }

        filterChain.doFilter(request, response);
    }

    private String parseJwt(HttpServletRequest request) {
        String headerAuth = request.getHeader("Authorization");

        if (StringUtils.hasText(headerAuth) && headerAuth.startsWith("Bearer ")) {
            return headerAuth.substring(7, headerAuth.length());
        }

        return null;
    }
}
AuthEntryPointJwt.java
java
package com.teleconsultation.api.security.jwt;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Component
public class AuthEntryPointJwt implements AuthenticationEntryPoint {

    private static final Logger logger = LoggerFactory.getLogger(AuthEntryPointJwt.class);

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException authException) throws IOException, ServletException {
        logger.error("Unauthorized error: {}", authException.getMessage());
        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Erreur: Non autorisé");
    }
}
UserDetailsImpl.java
java
package com.teleconsultation.api.security.services;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.teleconsultation.api.models.User;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

public class UserDetailsImpl implements UserDetails {
    private static final long serialVersionUID = 1L;

    private Long id;
    private String email;
    @JsonIgnore
    private String password;
    private String nom;
    private String prenom;
    private Collection<? extends GrantedAuthority> authorities;
    private boolean compteValide;
    private boolean actif;

    public UserDetailsImpl(Long id, String email, String password, String nom, String prenom,
                          Collection<? extends GrantedAuthority> authorities, boolean compteValide, boolean actif) {
        this.id = id;
        this.email = email;
        this.password = password;
        this.nom = nom;
        this.prenom = prenom;
        this.authorities = authorities;
        this.compteValide = compteValide;
        this.actif = actif;
    }

    public static UserDetailsImpl build(User user) {
        List<GrantedAuthority> authorities = user.getRoles().stream()
                .map(role -> new SimpleGrantedAuthority(role.getName().name()))
                .collect(Collectors.toList());

        return new UserDetailsImpl(
                user.getId(),
                user.getEmail(),
                user.getMotDePasse(),
                user.getNom(),
                user.getPrenom(),
                authorities,
                user.isCompteValide(),
                user.isActif());
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return authorities;
    }

    public Long getId() {
        return id;
    }

    public String getEmail() {
        return email;
    }

    public String getNom() {
        return nom;
    }

    public String getPrenom() {
        return prenom;
    }

    @Override
    public String getPassword() {
        return password;
    }

    @Override
    public String getUsername() {
        return email;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return actif;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return compteValide;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        UserDetailsImpl user = (UserDetailsImpl) o;
        return Objects.equals(id, user.id);
    }
}
UserDetailsServiceImpl.java
java
package com.teleconsultation.api.security.services;

import com.teleconsultation.api.models.User;
import com.teleconsultation.api.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {
    @Autowired
    UserRepository userRepository;

    @Override
    @Transactional
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("Utilisateur non trouvé avec l'email: " + email));

        return UserDetailsImpl.build(user);
    }
}
2.2 Repositories et Services
Créons maintenant les repositories et services nécessaires pour la gestion des utilisateurs.

UserRepository.java
java
package com.teleconsultation.api.repository;

import com.teleconsultation.api.models.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
    Boolean existsByEmail(String email);
    List<User> findAllByCompteValide(boolean compteValide);
}
RoleRepository.java
java
package com.teleconsultation.api.repository;

import com.teleconsultation.api.models.ERole;
import com.teleconsultation.api.models.Role;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface RoleRepository extends JpaRepository<Role, Long> {
    Optional<Role> findByName(ERole name);
}
PatientRepository.java
java
package com.teleconsultation.api.repository;

import com.teleconsultation.api.models.Patient;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface PatientRepository extends JpaRepository<Patient, Long> {
}
MedecinRepository.java
java
package com.teleconsultation.api.repository;

import com.teleconsultation.api.models.Medecin;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface MedecinRepository extends JpaRepository<Medecin, Long> {
}
SecretaireMedicalRepository.java
java
package com.teleconsultation.api.repository;

import com.teleconsultation.api.models.SecretaireMedical;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface SecretaireMedicalRepository extends JpaRepository<SecretaireMedical, Long> {
}
AdminRepository.java
java
package com.teleconsultation.api.repository;

import com.teleconsultation.api.models.Admin;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface AdminRepository extends JpaRepository<Admin, Long> {
}
UserService.java
java
package com.teleconsultation.api.service;

import com.teleconsultation.api.models.*;
import com.teleconsultation.api.repository.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private RoleRepository roleRepository;
    
    @Autowired
    private PatientRepository patientRepository;
    
    @Autowired
    private MedecinRepository medecinRepository;
    
    @Autowired
    private SecretaireMedicalRepository secretaireRepository;
    
    @Autowired
    private AdminRepository adminRepository;
    
    @Autowired
    private PasswordEncoder encoder;
    
    @Autowired
    private EmailService emailService;
    
    public List<User> findAllUsers() {
        return userRepository.findAll();
    }
    
    public List<User> findAllByCompteValide(boolean compteValide) {
        return userRepository.findAllByCompteValide(compteValide);
    }
    
    public User findById(Long id) {
        return userRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Utilisateur non trouvé avec l'ID: " + id));
    }
    
    public User findByEmail(String email) {
        return userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Utilisateur non trouvé avec l'email: " + email));
    }
    
    @Transactional
    public Patient registerPatient(PatientRequest patientRequest) {
        // Vérifier si l'email existe déjà
        if (userRepository.existsByEmail(patientRequest.getEmail())) {
            throw new RuntimeException("Erreur: Cet email est déjà utilisé!");
        }
        
        // Créer le nouvel utilisateur patient
        Patient patient = new Patient();
        patient.setNom(patientRequest.getNom());
        patient.setPrenom(patientRequest.getPrenom());
        patient.setEmail(patientRequest.getEmail());
        patient.setMotDePasse(encoder.encode(patientRequest.getMotDePasse()));
        patient.setTelephone(patientRequest.getTelephone());
        patient.setCompteValide(false);
        patient.setActif(true);
        
        // Informations spécifiques au patient
        patient.setNumeroSecuriteSociale(patientRequest.getNumeroSecuriteSociale());
        patient.setDateNaissance(patientRequest.getDateNaissance());
        patient.setAdresse(patientRequest.getAdresse());
        
        // Définir le rôle
        Set<Role> roles = new HashSet<>();
        Role userRole = roleRepository.findByName(ERole.ROLE_PATIENT)
                .orElseThrow(() -> new RuntimeException("Erreur: Rôle non trouvé."));
        roles.add(userRole);
        patient.setRoles(roles);
        
        // Enregistrer le patient
        Patient savedPatient = patientRepository.save(patient);
        
        // Envoyer un email de confirmation à l'administrateur
        emailService.envoyerEmailNouvelleInscription(patient);
        
        return savedPatient;
    }
    
    @Transactional
    public Medecin registerMedecin(MedecinRequest medecinRequest) {
        // Vérifier si l'email existe déjà
        if (userRepository.existsByEmail(medecinRequest.getEmail())) {
            throw new RuntimeException("Erreur: Cet email est déjà utilisé!");
        }
        
        // Créer le nouvel utilisateur médecin
        Medecin medecin = new Medecin();
        medecin.setNom(medecinRequest.getNom());
        medecin.setPrenom(medecinRequest.getPrenom());
        medecin.setEmail(medecinRequest.getEmail());
        medecin.setMotDePasse(encoder.encode(medecinRequest.getMotDePasse()));
        medecin.setTelephone(medecinRequest.getTelephone());
        medecin.setCompteValide(false);
        medecin.setActif(true);
        
        // Informations spécifiques au médecin
        medecin.setSpecialite(medecinRequest.getSpecialite());
        medecin.setNumeroOrdre(medecinRequest.getNumeroOrdre());
        
        // Définir le rôle
        Set<Role> roles = new HashSet<>();
        Role userRole = roleRepository.findByName(ERole.ROLE_MEDECIN)
                .orElseThrow(() -> new RuntimeException("Erreur: Rôle non trouvé."));
        roles.add(userRole);
        medecin.setRoles(roles);
        
        // Enregistrer le médecin
        Medecin savedMedecin = medecinRepository.save(medecin);
        
        // Envoyer un email de confirmation à l'administrateur
        emailService.envoyerEmailNouvelleInscription(medecin);
        
        return savedMedecin;
    }
    
    @Transactional
    public SecretaireMedical registerSecretaire(SecretaireRequest secretaireRequest) {
        // Vérifier si l'email existe déjà
        if (userRepository.existsByEmail(secretaireRequest.getEmail())) {
            throw new RuntimeException("Erreur: Cet email est déjà utilisé!");
        }
        
        // Créer le nouvel utilisateur secrétaire
        SecretaireMedical secretaire = new SecretaireMedical();
        secretaire.setNom(secretaireRequest.getNom());
        secretaire.setPrenom(secretaireRequest.getPrenom());
        secretaire.setEmail(secretaireRequest.getEmail());
        secretaire.setMotDePasse(encoder.encode(secretaireRequest.getMotDePasse()));
        secretaire.setTelephone(secretaireRequest.getTelephone());
        secretaire.setCompteValide(false);
        secretaire.setActif(true);
        
        // Informations spécifiques au secrétaire
        secretaire.setService(secretaireRequest.getService());
        
        // Définir le rôle
        Set<Role> roles = new HashSet<>();
        Role userRole = roleRepository.findByName(ERole.ROLE_SECRETAIRE)
                .orElseThrow(() -> new RuntimeException("Erreur: Rôle non trouvé."));
        roles.add(userRole);
        secretaire.setRoles(roles);
        
        // Enregistrer le secrétaire
        SecretaireMedical savedSecretaire = secretaireRepository.save(secretaire);
        
        // Envoyer un email de confirmation à l'administrateur
        emailService.envoyerEmailNouvelleInscription(secretaire);
        
        return savedSecretaire;
    }
    
    @Transactional
    public void validerUtilisateur(Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Utilisateur non trouvé avec l'ID: " + id));
        
        user.setCompteValide(true);
        userRepository.save(user);
        
        // Envoyer un email à l'utilisateur pour l'informer que son compte a été validé
        emailService.envoyerEmailCompteValide(user);
    }
    
    @Transactional
    public void rejeterUtilisateur(Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Utilisateur non trouvé avec l'ID: " + id));
        
        // Supprimer l'utilisateur
        userRepository.delete(user);
        
        // Envoyer un email à l'utilisateur pour l'informer que son compte a été rejeté
        emailService.envoyerEmailCompteRejete(user);
    }
    
    @Transactional
    public void activerUtilisateur(Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Utilisateur non trouvé avec l'ID: " + id));
        
        user.setActif(true);
        userRepository.save(user);
    }
    
    @Transactional
    public void desactiverUtilisateur(Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Utilisateur non trouvé avec l'ID: " + id));
        
        user.setActif(false);
        userRepository.save(user);
    }
}
EmailService.java
java
package com.teleconsultation.api.service;

import com.teleconsultation.api.models.RendezVous;
import com.teleconsultation.api.models.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;

@Service
public class EmailService {
    
    @Autowired
    private JavaMailSender emailSender;
    
    public void envoyerEmailNouvelleInscription(User user) {
        SimpleMailMessage message = new SimpleMailMessage();
        message.setTo("admin@teleconsultation.com"); // Adresse de l'administrateur
        message.setSubject("Nouvelle inscription à valider");
        message.setText("Bonjour,\n\n" +
                "Un nouvel utilisateur s'est inscrit sur la plateforme de téléconsultation.\n\n" +
                "Nom: " + user.getNom() + " " + user.getPrenom() + "\n" +
                "Email: " + user.getEmail() + "\n\n" +
                "Veuillez vous connecter pour valider ou rejeter cette inscription.\n\n" +
                "Cordialement,\n" +
                "L'équipe de téléconsultation");
        
        emailSender.send(message);
    }
    
    public void envoyerEmailCompteValide(User user) {
        SimpleMailMessage message = new SimpleMailMessage();
        message.setTo(user.getEmail());
        message.setSubject("Votre compte a été validé");
        message.setText("Bonjour " + user.getPrenom() + ",\n\n" +
                "Nous avons le plaisir de vous informer que votre compte sur la plateforme de téléconsultation a été validé.\n\n" +
                "Vous pouvez désormais vous connecter avec votre email et votre mot de passe.\n\n" +
                "Cordialement,\n" +
                "L'équipe de téléconsultation");
        
        emailSender.send(message);
    }
    
    public void envoyerEmailCompteRejete(User user) {
        SimpleMailMessage message = new SimpleMailMessage();
        message.setTo(user.getEmail());
        message.setSubject("Votre demande d'inscription");
        message.setText("Bonjour " + user.getPrenom() + ",\n\n" +
                "Nous sommes désolés de vous informer que votre demande d'inscription sur la plateforme de téléconsultation n'a pas été acceptée.\n\n" +
                "Pour plus d'informations, veuillez nous contacter.\n\n" +
                "Cordialement,\n" +
                "L'équipe de téléconsultation");
        
        emailSender.send(message);
    }
    
    public void envoyerNotificationNouveauRendezVous(RendezVous rendezVous) {
        SimpleMailMessage message = new SimpleMailMessage();
        message.setTo(rendezVous.getMedecin().getEmail());
        message.setSubject("Nouveau rendez-vous à valider");
        message.setText("Bonjour Dr. " + rendezVous.getMedecin().getPrenom() + " " + rendezVous.getMedecin().getNom() + ",\n\n" +
                "Un nouveau rendez-vous a été planifié pour vous:\n\n" +
                "Patient: " + rendezVous.getPatient().getNom() + " " + rendezVous.getPatient().getPrenom() + "\n" +
                "Date: " + rendezVous.getDateHeure() + "\n" +
                "Motif: " + rendezVous.getMotif() + "\n\n" +
                "Veuillez vous connecter pour valider ou rejeter ce rendez-vous.\n\n" +
                "Cordialement,\n" +
                "L'équipe de téléconsultation");
        
        emailSender.send(message);
    }
    
    public void envoyerNotificationRendezVousValide(RendezVous rendezVous) {
        SimpleMailMessage message = new SimpleMailMessage();
        message.setTo(rendezVous.getPatient().getEmail());
        message.setSubject("Votre rendez-vous a été validé");
        message.setText("Bonjour " + rendezVous.getPatient().getPrenom() + ",\n\n" +
                "Nous avons le plaisir de vous informer que votre rendez-vous a été validé:\n\n" +
                "Médecin: Dr. " + rendezVous.getMedecin().getNom() + " " + rendezVous.getMedecin().getPrenom() + "\n" +
                "Date: " + rendezVous.getDateHeure() + "\n" +
                "Motif: " + rendezVous.getMotif() + "\n\n" +
                "Cordialement,\n" +
                "L'équipe de téléconsultation");
        
        emailSender.send(message);
    }
}
2.3 Contrôleurs (Controllers)
Créons maintenant les contrôleurs pour gérer les requêtes HTTP.

AuthController.java
java
package com.teleconsultation.api.controllers;

import com.teleconsultation.api.models.ERole;
import com.teleconsultation.api.models.Role;
import com.teleconsultation.api.models.User;
import com.teleconsultation.api.payload.request.*;
import com.teleconsultation.api.payload.response.JwtResponse;
import com.teleconsultation.api.payload.response.MessageResponse;
import com.teleconsultation.api.repository.RoleRepository;
import com.teleconsultation.api.repository.UserRepository;
import com.teleconsultation.api.security.jwt.JwtUtils;
import



Continuer

Modifier
Continuons avec la Phase 2 de notre développement en implémentant les contrôleurs pour gérer les requêtes HTTP.

AuthController.java
java
package com.teleconsultation.api.controllers;

import com.teleconsultation.api.payload.request.LoginRequest;
import com.teleconsultation.api.payload.request.MedecinRequest;
import com.teleconsultation.api.payload.request.PatientRequest;
import com.teleconsultation.api.payload.request.SecretaireRequest;
import com.teleconsultation.api.payload.response.JwtResponse;
import com.teleconsultation.api.payload.response.MessageResponse;
import com.teleconsultation.api.security.jwt.JwtUtils;
import com.teleconsultation.api.security.services.UserDetailsImpl;
import com.teleconsultation.api.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;
import java.util.List;
import java.util.stream.Collectors;

@CrossOrigin(origins = "*", maxAge = 3600)
@RestController
@RequestMapping("/api/auth")
public class AuthController {
    @Autowired
    AuthenticationManager authenticationManager;

    @Autowired
    UserService userService;

    @Autowired
    JwtUtils jwtUtils;

    @PostMapping("/login")
    public ResponseEntity<?> authenticateUser(@Valid @RequestBody LoginRequest loginRequest) {
        Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(loginRequest.getEmail(), loginRequest.getPassword()));

        SecurityContextHolder.getContext().setAuthentication(authentication);
        String jwt = jwtUtils.generateJwtToken(authentication);
        
        UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();
        List<String> roles = userDetails.getAuthorities().stream()
                .map(item -> item.getAuthority())
                .collect(Collectors.toList());

        return ResponseEntity.ok(new JwtResponse(jwt,
                                                userDetails.getId(),
                                                userDetails.getUsername(),
                                                userDetails.getNom(),
                                                userDetails.getPrenom(),
                                                roles));
    }

    @PostMapping("/register/patient")
    public ResponseEntity<?> registerPatient(@Valid @RequestBody PatientRequest patientRequest) {
        try {
            userService.registerPatient(patientRequest);
            return ResponseEntity.ok(new MessageResponse("Patient enregistré avec succès! Veuillez attendre la validation par un administrateur."));
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(new MessageResponse(e.getMessage()));
        }
    }

    @PostMapping("/register/medecin")
    public ResponseEntity<?> registerMedecin(@Valid @RequestBody MedecinRequest medecinRequest) {
        try {
            userService.registerMedecin(medecinRequest);
            return ResponseEntity.ok(new MessageResponse("Médecin enregistré avec succès! Veuillez attendre la validation par un administrateur."));
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(new MessageResponse(e.getMessage()));
        }
    }

    @PostMapping("/register/secretaire")
    public ResponseEntity<?> registerSecretaire(@Valid @RequestBody SecretaireRequest secretaireRequest) {
        try {
            userService.registerSecretaire(secretaireRequest);
            return ResponseEntity.ok(new MessageResponse("Secrétaire enregistré avec succès! Veuillez attendre la validation par un administrateur."));
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(new MessageResponse(e.getMessage()));
        }
    }
}
AdminController.java
java
package com.teleconsultation.api.controllers;

import com.teleconsultation.api.models.User;
import com.teleconsultation.api.payload.response.MessageResponse;
import com.teleconsultation.api.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@CrossOrigin(origins = "*", maxAge = 3600)
@RestController
@RequestMapping("/api/admin")
public class AdminController {
    @Autowired
    private UserService userService;

    @GetMapping("/utilisateurs")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<List<User>> getAllUtilisateurs() {
        List<User> utilisateurs = userService.findAllUsers();
        return ResponseEntity.ok(utilisateurs);
    }

    @GetMapping("/utilisateurs/en-attente")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<List<User>> getUtilisateursEnAttente() {
        List<User> utilisateurs = userService.findAllByCompteValide(false);
        return ResponseEntity.ok(utilisateurs);
    }

    @PutMapping("/utilisateurs/{id}/valider")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<?> validerUtilisateur(@PathVariable Long id) {
        try {
            userService.validerUtilisateur(id);
            return ResponseEntity.ok(new MessageResponse("Utilisateur validé avec succès"));
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(new MessageResponse(e.getMessage()));
        }
    }

    @PutMapping("/utilisateurs/{id}/rejeter")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<?> rejeterUtilisateur(@PathVariable Long id) {
        try {
            userService.rejeterUtilisateur(id);
            return ResponseEntity.ok(new MessageResponse("Utilisateur rejeté avec succès"));
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(new MessageResponse(e.getMessage()));
        }
    }

    @PutMapping("/utilisateurs/{id}/activer")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<?> activerUtilisateur(@PathVariable Long id) {
        try {
            userService.activerUtilisateur(id);
            return ResponseEntity.ok(new MessageResponse("Utilisateur activé avec succès"));
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(new MessageResponse(e.getMessage()));
        }
    }

    @PutMapping("/utilisateurs/{id}/desactiver")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<?> desactiverUtilisateur(@PathVariable Long id) {
        try {
            userService.desactiverUtilisateur(id);
            return ResponseEntity.ok(new MessageResponse("Utilisateur désactivé avec succès"));
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(new MessageResponse(e.getMessage()));
        }
    }
}
2.4 Payload (DTO)
Créons les classes de requête et de réponse pour l'API.

LoginRequest.java
java
package com.teleconsultation.api.payload.request;

import lombok.Data;

import javax.validation.constraints.NotBlank;

@Data
public class LoginRequest {
    @NotBlank
    private String email;

    @NotBlank
    private String password;
}
PatientRequest.java
java
package com.teleconsultation.api.payload.request;

import lombok.Data;

import javax.validation.constraints.Email;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
import java.time.LocalDate;

@Data
public class PatientRequest {
    @NotBlank
    @Size(min = 2, max = 50)
    private String nom;

    @NotBlank
    @Size(min = 2, max = 50)
    private String prenom;

    @NotBlank
    @Size(max = 50)
    @Email
    private String email;

    @NotBlank
    @Size(min = 6, max = 40)
    private String motDePasse;

    @Size(max = 20)
    private String telephone;

    @NotBlank
    private String numeroSecuriteSociale;

    @NotNull
    private LocalDate dateNaissance;

    @NotBlank
    private String adresse;
}
MedecinRequest.java
java
package com.teleconsultation.api.payload.request;

import lombok.Data;

import javax.validation.constraints.Email;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Size;

@Data
public class MedecinRequest {
    @NotBlank
    @Size(min = 2, max = 50)
    private String nom;

    @NotBlank
    @Size(min = 2, max = 50)
    private String prenom;

    @NotBlank
    @Size(max = 50)
    @Email
    private String email;

    @NotBlank
    @Size(min = 6, max = 40)
    private String motDePasse;

    @Size(max = 20)
    private String telephone;

    @NotBlank
    private String specialite;

    @NotBlank
    private String numeroOrdre;
}
SecretaireRequest.java
java
package com.teleconsultation.api.payload.request;

import lombok.Data;

import javax.validation.constraints.Email;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Size;

@Data
public class SecretaireRequest {
    @NotBlank
    @Size(min = 2, max = 50)
    private String nom;

    @NotBlank
    @Size(min = 2, max = 50)
    private String prenom;

    @NotBlank
    @Size(max = 50)
    @Email
    private String email;

    @NotBlank
    @Size(min = 6, max = 40)
    private String motDePasse;

    @Size(max = 20)
    private String telephone;

    private String service;
}
JwtResponse.java
java
package com.teleconsultation.api.payload.response;

import lombok.Data;

import java.util.List;

@Data
public class JwtResponse {
    private String token;
    private String type = "Bearer";
    private Long id;
    private String email;
    private String nom;
    private String prenom;
    private List<String> roles;

    public JwtResponse(String accessToken, Long id, String email, String nom, String prenom, List<String> roles) {
        this.token = accessToken;
        this.id = id;
        this.email = email;
        this.nom = nom;
        this.prenom = prenom;
        this.roles = roles;
    }
}
MessageResponse.java
java
package com.teleconsultation.api.payload.response;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class MessageResponse {
    private String message;
}
2.5 Frontend - Authentification
Maintenant, développons les composants React pour l'authentification et la gestion des utilisateurs.

src/services/authService.js
javascript
import axios from 'axios';
import { API_URL } from '../config';

// Configuration de l'intercepteur pour ajouter le token JWT aux requêtes
axios.interceptors.request.use(config => {
    const token = localStorage.getItem('token');
    
    if (token) {
        config.headers.Authorization = `Bearer ${token}`;
    }
    
    return config;
}, error => {
    return Promise.reject(error);
});

// Connexion
export const login = (email, password) => {
    return axios.post(`${API_URL}/auth/login`, { email, password });
};

// Inscription patient
export const registerPatient = (patientData) => {
    return axios.post(`${API_URL}/auth/register/patient`, patientData);
};

// Inscription médecin
export const registerMedecin = (medecinData) => {
    return axios.post(`${API_URL}/auth/register/medecin`, medecinData);
};

// Inscription secrétaire
export const registerSecretaire = (secretaireData) => {
    return axios.post(`${API_URL}/auth/register/secretaire`, secretaireData);
};

// Déconnexion
export const logout = () => {
    localStorage.removeItem('token');
    return true;
};
src/pages/Login.jsx
jsx
import React, { useState } from 'react';
import {
    Container,
    Paper,
    Typography,
    TextField,
    Button,
    Grid,
    Link,
    Alert,
    FormControl,
    InputLabel,
    Select,
    MenuItem,
    Box
} from '@mui/material';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

const Login = () => {
    const [formData, setFormData] = useState({
        email: '',
        password: ''
    });
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);

    const { login } = useAuth();
    const navigate = useNavigate();

    const handleChange = (e) => {
        const { name, value } = e.target;
        setFormData(prevState => ({
            ...prevState,
            [name]: value
        }));
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');
        setLoading(true);

        try {
            const result = await login(formData.email, formData.password);
            
            if (result.success) {
                navigate('/redirect');
            } else {
                setError(result.message);
            }
        } catch (error) {
            setError('Une erreur est survenue lors de la connexion.');
            console.error('Erreur de connexion:', error);
        } finally {
            setLoading(false);
        }
    };

    return (
        <Container component="main" maxWidth="xs">
            <Box
                sx={{
                    marginTop: 8,
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                }}
            >
                <Paper elevation={3} sx={{ padding: 3, width: '100%' }}>
                    <Typography component="h1" variant="h5" align="center" gutterBottom>
                        Connexion
                    </Typography>

                    {error && (
                        <Alert severity="error" sx={{ mb: 2 }}>
                            {error}
                        </Alert>
                    )}

                    <form onSubmit={handleSubmit}>
                        <TextField
                            variant="outlined"
                            margin="normal"
                            required
                            fullWidth
                            id="email"
                            label="Adresse email"
                            name="email"
                            autoComplete="email"
                            autoFocus
                            value={formData.email}
                            onChange={handleChange}
                        />

                        <TextField
                            variant="outlined"
                            margin="normal"
                            required
                            fullWidth
                            name="password"
                            label="Mot de passe"
                            type="password"
                            id="password"
                            autoComplete="current-password"
                            value={formData.password}
                            onChange={handleChange}
                        />

                        <Button
                            type="submit"
                            fullWidth
                            variant="contained"
                            color="primary"
                            sx={{ mt: 3, mb: 2 }}
                            disabled={loading}
                        >
                            {loading ? 'Connexion en cours...' : 'Se connecter'}
                        </Button>

                        <Grid container justifyContent="center">
                            <Grid item>
                                <Link href="/register" variant="body2">
                                    {"Vous n'avez pas de compte ? Inscrivez-vous"}
                                </Link>
                            </Grid>
                        </Grid>
                    </form>
                </Paper>
            </Box>
        </Container>
    );
};

export default Login;
src/pages/Register.jsx
jsx
import React, { useState } from 'react';
import {
    Container,
    Paper,
    Typography,
    TextField,
    Button,
    Grid,
    Link,
    Alert,
    FormControl,
    InputLabel,
    Select,
    MenuItem,
    Box,
    Stepper,
    Step,
    StepLabel
} from '@mui/material';
import { DatePicker } from '@mui/x-date-pickers';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

const steps = ['Type de compte', 'Informations personnelles', 'Informations spécifiques'];

const Register = () => {
    const [activeStep, setActiveStep] = useState(0);
    const [userType, setUserType] = useState('');
    const [formData, setFormData] = useState({
        nom: '',
        prenom: '',
        email: '',
        motDePasse: '',
        confirmPassword: '',
        telephone: '',
        // Champs spécifiques au patient
        numeroSecuriteSociale: '',
        dateNaissance: null,
        adresse: '',
        // Champs spécifiques au médecin
        specialite: '',
        numeroOrdre: '',
        // Champs spécifiques au secrétaire
        service: ''
    });
    const [error, setError] = useState('');
    const [success, setSuccess] = useState('');
    const [loading, setLoading] = useState(false);

    const { register } = useAuth();
    const navigate = useNavigate();

    const handleNext = () => {
        if (activeStep === 0 && !userType) {
            setError('Veuillez sélectionner un type de compte');
            return;
        }

        if (activeStep === 1) {
            // Validation des champs de l'étape 1
            if (!formData.nom || !formData.prenom || !formData.email || !formData.motDePasse || !formData.confirmPassword) {
                setError('Veuillez remplir tous les champs obligatoires');
                return;
            }

            if (formData.motDePasse !== formData.confirmPassword) {
                setError('Les mots de passe ne correspondent pas');
                return;
            }

            if (formData.motDePasse.length < 6) {
                setError('Le mot de passe doit contenir au moins 6 caractères');
                return;
            }

            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(formData.email)) {
                setError('Format d\'email invalide');
                return;
            }
        }

        if (activeStep === 2) {
            // Validation des champs spécifiques à chaque type d'utilisateur
            if (userType === 'patient') {
                if (!formData.numeroSecuriteSociale || !formData.dateNaissance || !formData.adresse) {
                    setError('Veuillez remplir tous les champs obligatoires');
                    return;
                }
            } else if (userType === 'medecin') {
                if (!formData.specialite || !formData.numeroOrdre) {
                    setError('Veuillez remplir tous les champs obligatoires');
                    return;
                }
            }
            // Le secrétaire n'a pas de champs obligatoires spécifiques

            // Soumission du formulaire
            handleSubmit();
            return;
        }

        setError('');
        setActiveStep((prevActiveStep) => prevActiveStep + 1);
    };

    const handleBack = () => {
        setActiveStep((prevActiveStep) => prevActiveStep - 1);
        setError('');
    };

    const handleChange = (e) => {
        const { name, value } = e.target;
        setFormData(prevState => ({
            ...prevState,
            [name]: value
        }));
    };

    const handleUserTypeChange = (e) => {
        setUserType(e.target.value);
    };

    const handleDateChange = (date) => {
        setFormData(prevState => ({
            ...prevState,
            dateNaissance: date
        }));
    };

    const handleSubmit = async () => {
        setError('');
        setLoading(true);

        try {
            let userData = { ...formData };
            delete userData.confirmPassword;

            let result;
            if (userType === 'patient') {
                result = await register(userData, 'patient');
            } else if (userType === 'medecin') {
                result = await register(userData, 'medecin');
            } else if (userType === 'secretaire') {
                result = await register(userData, 'secretaire');
            }

            if (result.success) {
                setSuccess('Inscription réussie ! Votre compte est en attente de validation par un administrateur.');
                // Rediriger vers la page de connexion après quelques secondes
                setTimeout(() => {
                    navigate('/login');
                }, 5000);
            } else {
                setError(result.message);
                setActiveStep(1); // Retour à l'étape des informations personnelles en cas d'erreur
            }
        } catch (error) {
            setError('Une erreur est survenue lors de l\'inscription.');
            console.error('Erreur d\'inscription:', error);
            setActiveStep(1);
        } finally {
            setLoading(false);
        }
    };

    const renderStepContent = (step) => {
        switch (step) {
            case 0:
                return (
                    <FormControl fullWidth margin="normal">
                        <InputLabel id="user-type-label">Type de compte</InputLabel>
                        <Select
                            labelId="user-type-label"
                            id="userType"
                            value={userType}
                            label="Type de compte"
                            onChange={handleUserTypeChange}
                        >
                            <MenuItem value="patient">Patient</MenuItem>
                            <MenuItem value="medecin">Médecin</MenuItem>
                            <MenuItem value="secretaire">Secrétaire médical</MenuItem>
                        </Select>
                    </FormControl>
                );
            case 1:
                return (
                    <>
                        <Grid container spacing={2}>
                            <Grid item xs={12} sm={6}>
                                <TextField
                                    autoComplete="fname"
                                    name="nom"
                                    variant="outlined"
                                    required
                                    fullWidth
                                    id="nom"
                                    label="Nom"
                                    autoFocus
                                    value={formData.nom}
                                    onChange={handleChange}
                                />
                            </Grid>
                            <Grid item xs={12} sm={6}>
                                <TextField
                                    variant="outlined"
                                    required
                                    fullWidth
                                    id="prenom"
                                    label="Prénom"
                                    name="prenom"
                                    autoComplete="lname"
                                    value={formData.prenom}
                                    onChange={handleChange}
                                />
                            </Grid>
                            <Grid item xs={12}>
                                <TextField
                                    variant="outlined"
                                    required
                                    fullWidth
                                    id="email"
                                    label="Adresse email"
                                    name="email"
                                    autoComplete="email"
                                    value={formData.email}
                                    onChange={handleChange}
                                />
                            </Grid>
                            <Grid item xs={12}>
                                <TextField
                                    variant="outlined"
                                    required
                                    fullWidth
                                    name="motDePasse"
                                    label="Mot de passe"
                                    type="password"
                                    id="motDePasse"
                                    autoComplete="new-password"
                                    value={formData.motDePasse}
                                    onChange={handleChange}
                                />
                            </Grid>
                            <Grid item xs={12}>
                                <TextField
                                    variant="outlined"
                                    required
                                    fullWidth
                                    name="confirmPassword"
                                    label="Confirmer le mot de passe"
                                    type="password"
                                    id="confirmPassword"
                                    value={formData.confirmPassword}
                                    onChange={handleChange}
                                />
                            </Grid>
                            <Grid item xs={12}>
                                <TextField
                                    variant="outlined"
                                    fullWidth
                                    name="telephone"
                                    label="Téléphone"
                                    id="telephone"
                                    autoComplete="tel"
                                    value={formData.telephone}
                                    onChange={handleChange}
                                />
                            </Grid>
                        </Grid>
                    </>
                );
            case 2:
                if (userType === 'patient') {
                    return (
                        <>
                            <Grid container spacing={2}>
                                <Grid item xs={12}>
                                    <TextField
                                        variant="outlined"
                                        required
                                        fullWidth
                                        id="numeroSecuriteSociale"
                                        label="Numéro de sécurité sociale"
                                        name="numeroSecuriteSociale"
                                        value={formData.numeroSecuriteSociale}
                                        onChange={handleChange}
                                    />
                                </Grid>
                                <Grid item xs={12}>
                                    <DatePicker
                                        label="Date de naissance"
                                        value={formData.dateNaissance}
                                        onChange={handleDateChange}
                                        renderInput={(params) => <TextField {...params} required fullWidth />}
                                    />
                                </Grid>
                                <Grid item xs={12}>
                                    <TextField
                                        variant="outlined"
                                        required
                                        fullWidth
                                        id="adresse"
                                        label="Adresse"
                                        name="adresse"
                                        multiline
                                        rows={3}
                                        value={formData.adresse}
                                        onChange={handleChange}
                                    />
                                </Grid>
                            </Grid>
                        </>
                    );
                } else if (userType === 'medecin') {
                    return (
                        <>
                            <Grid container spacing={2}>
                                <Grid item xs={12}>
                                    <TextField
                                        variant="outlined"
                                        required
                                        fullWidth
                                        id="specialite"
                                        label="Spécialité"
                                        name="specialite"
                                        value={formData.specialite}
                                        onChange={handleChange}
                                    />
                                </Grid>
                                <Grid item xs={12}>
                                    <TextField
                                        variant="outlined"
                                        required
                                        fullWidth
                                        id="numeroOrdre"
                                        label="Numéro d'ordre"
                                        name="numeroOrdre"
                                        value={formData.numeroOrdre}
                                        onChange={handleChange}
                                    />
                                </Grid>
                            </Grid>
                        </>
                    );
                } else if (userType === 'secretaire') {
                    return (
                        <>
                            <Grid container spacing={2}>
                                <Grid item xs={12}>
                                    <TextField
                                        variant="outlined"
                                        fullWidth
                                        id="service"
                                        label="Service"
                                        name="service"
                                        value={formData.service}
                                        onChange={handleChange}
                                    />
                                </Grid>
                            </Grid>
                        </>
                    );
                }
                return null;
            default:
                return null;
        }
    };

    return (
        <Container component="main" maxWidth="md">
            <Box
                sx={{
                    marginTop: 8,
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                }}
            >
                <Paper elevation={3} sx={{ padding: 3, width: '100%' }}>
                    <Typography component="h1" variant="h5" align="center" gutterBottom>
                        Inscription
                    </Typography>

                    {error && (
                        <Alert severity="error" sx={{ mb: 2 }}>
                            {error}
                        </Alert>
                    )}

                    {success && (
                        <Alert severity="success" sx={{ mb: 2 }}>
                            {success}
                        </Alert>
                    )}

                    <Stepper activeStep={activeStep} sx={{ mb: 4 }}>
                        {steps.map((label) => (
                            <Step key={label}>
                                <StepLabel>{label}</StepLabel>
                            </Step>
                        ))}
                    </Stepper>

                    <form>
                        {renderStepContent(activeStep)}

                        <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 3 }}>
                            <Button
                                onClick={handleBack}
                                disabled={activeStep === 0 || loading}
                            >
                                Retour
                            </Button>
                            <Button
                                variant="contained"
                                color="primary"
                                onClick={handleNext}
                                disabled={loading}
                            >
                                {activeStep === steps.length - 1 ? (loading ? 'Inscription en cours...' : 'S\'inscrire') : 'Suivant'}
                            </Button>
                        </Box>

                        <Grid container justifyContent="center" sx={{ mt: 2 }}>
                            <Grid item>
                                <Link href="/login" variant="body2">
                                    {"Vous avez déjà un compte ? Connectez-vous"}
                                </Link>
                            </Grid>
                        </Grid>
                    </form>
                </Paper>
            </Box>
        </Container>
    );
};

export default Register;
2.6 Frontend - Administration des utilisateurs
Créons maintenant l'interface d'administration pour gérer les utilisateurs.

src/services/adminService.js
javascript
import axios from 'axios';
import { API_URL } from '../config';

// Récupérer tous les utilisateurs
export const getAllUtilisateurs = () => {
    return axios.get(`${API_URL}/admin/utilisateurs`);
};

// Récupérer les utilisateurs en attente de validation
export const getUtilisateursEnAttente = () => {
    return axios.get(`${API_URL}/admin/utilisateurs/en-attente`);
};

// Valider un utilisateur
export const validerUtilisateur = (id) => {
    return axios.put(`${API_URL}/admin/utilisateurs/${id}/valider`);
};

// Rejeter un utilisateur
export const rejeterUtilisateur = (id) => {
    return axios.put(`${API_URL}/admin/utilisateurs/${id}/rejeter



Continuer

Modifier
Continuons avec l'interface d'administration pour gérer les utilisateurs dans notre application de téléconsultation.

src/services/adminService.js (suite)
javascript
// Rejeter un utilisateur
export const rejeterUtilisateur = (id) => {
    return axios.put(`${API_URL}/admin/utilisateurs/${id}/rejeter`);
};

// Activer un utilisateur
export const activerUtilisateur = (id) => {
    return axios.put(`${API_URL}/admin/utilisateurs/${id}/activer`);
};

// Désactiver un utilisateur
export const desactiverUtilisateur = (id) => {
    return axios.put(`${API_URL}/admin/utilisateurs/${id}/desactiver`);
};
src/components/layouts/AdminLayout.jsx
jsx
import React from 'react';
import { Routes, Route } from 'react-router-dom';
import { Box, CssBaseline } from '@mui/material';
import AdminDashboard from '../../pages/admin/AdminDashboard';
import GestionUtilisateurs from '../../pages/admin/GestionUtilisateurs';
import AdminSidebar from '../admin/AdminSidebar';
import AdminHeader from '../admin/AdminHeader';
import NotFound from '../../pages/NotFound';

const AdminLayout = () => {
    const [open, setOpen] = React.useState(true);

    const toggleDrawer = () => {
        setOpen(!open);
    };

    return (
        <Box sx={{ display: 'flex' }}>
            <CssBaseline />
            <AdminHeader open={open} toggleDrawer={toggleDrawer} />
            <AdminSidebar open={open} toggleDrawer={toggleDrawer} />
            <Box
                component="main"
                sx={{
                    flexGrow: 1,
                    height: '100vh',
                    overflow: 'auto',
                    paddingTop: '64px', // Hauteur de l'en-tête
                }}
            >
                <Routes>
                    <Route path="dashboard" element={<AdminDashboard />} />
                    <Route path="utilisateurs" element={<GestionUtilisateurs />} />
                    <Route path="*" element={<NotFound />} />
                </Routes>
            </Box>
        </Box>
    );
};

export default AdminLayout;
src/components/admin/AdminHeader.jsx
jsx
import React from 'react';
import {
    AppBar,
    Toolbar,
    Typography,
    IconButton,
    Badge,
    Menu,
    MenuItem,
    Box
} from '@mui/material';
import {
    Menu as MenuIcon,
    Notifications as NotificationsIcon,
    AccountCircle,
    MoreVert as MoreIcon
} from '@mui/icons-material';
import { useAuth } from '../../context/AuthContext';
import { useNavigate } from 'react-router-dom';

const AdminHeader = ({ open, toggleDrawer }) => {
    const [anchorEl, setAnchorEl] = React.useState(null);
    const [mobileMoreAnchorEl, setMobileMoreAnchorEl] = React.useState(null);

    const isMenuOpen = Boolean(anchorEl);
    const isMobileMenuOpen = Boolean(mobileMoreAnchorEl);

    const { currentUser, logout } = useAuth();
    const navigate = useNavigate();

    const handleProfileMenuOpen = (event) => {
        setAnchorEl(event.currentTarget);
    };

    const handleMobileMenuClose = () => {
        setMobileMoreAnchorEl(null);
    };

    const handleMenuClose = () => {
        setAnchorEl(null);
        handleMobileMenuClose();
    };

    const handleMobileMenuOpen = (event) => {
        setMobileMoreAnchorEl(event.currentTarget);
    };

    const handleLogout = () => {
        logout();
        navigate('/login');
    };

    const menuId = 'primary-search-account-menu';
    const renderMenu = (
        <Menu
            anchorEl={anchorEl}
            anchorOrigin={{ vertical: 'top', horizontal: 'right' }}
            id={menuId}
            keepMounted
            transformOrigin={{ vertical: 'top', horizontal: 'right' }}
            open={isMenuOpen}
            onClose={handleMenuClose}
        >
            <MenuItem onClick={handleMenuClose}>Mon Profil</MenuItem>
            <MenuItem onClick={handleLogout}>Déconnexion</MenuItem>
        </Menu>
    );

    const mobileMenuId = 'primary-search-account-menu-mobile';
    const renderMobileMenu = (
        <Menu
            anchorEl={mobileMoreAnchorEl}
            anchorOrigin={{ vertical: 'top', horizontal: 'right' }}
            id={mobileMenuId}
            keepMounted
            transformOrigin={{ vertical: 'top', horizontal: 'right' }}
            open={isMobileMenuOpen}
            onClose={handleMobileMenuClose}
        >
            <MenuItem>
                <IconButton
                    size="large"
                    aria-label="show 17 new notifications"
                    color="inherit"
                >
                    <Badge badgeContent={17} color="error">
                        <NotificationsIcon />
                    </Badge>
                </IconButton>
                <p>Notifications</p>
            </MenuItem>
            <MenuItem onClick={handleProfileMenuOpen}>
                <IconButton
                    size="large"
                    aria-label="account of current user"
                    aria-controls="primary-search-account-menu"
                    aria-haspopup="true"
                    color="inherit"
                >
                    <AccountCircle />
                </IconButton>
                <p>Profil</p>
            </MenuItem>
        </Menu>
    );

    return (
        <>
            <AppBar position="fixed" sx={{ zIndex: (theme) => theme.zIndex.drawer + 1 }}>
                <Toolbar>
                    <IconButton
                        edge="start"
                        color="inherit"
                        aria-label="open drawer"
                        onClick={toggleDrawer}
                        sx={{
                            marginRight: '36px',
                        }}
                    >
                        <MenuIcon />
                    </IconButton>
                    <Typography
                        variant="h6"
                        noWrap
                        component="div"
                        sx={{ display: { xs: 'none', sm: 'block' } }}
                    >
                        Téléconsultation - Administration
                    </Typography>
                    <Box sx={{ flexGrow: 1 }} />
                    <Box sx={{ display: { xs: 'none', md: 'flex' } }}>
                        <IconButton
                            size="large"
                            aria-label="show new notifications"
                            color="inherit"
                        >
                            <Badge badgeContent={0} color="error">
                                <NotificationsIcon />
                            </Badge>
                        </IconButton>
                        <IconButton
                            size="large"
                            edge="end"
                            aria-label="account of current user"
                            aria-controls={menuId}
                            aria-haspopup="true"
                            onClick={handleProfileMenuOpen}
                            color="inherit"
                        >
                            <AccountCircle />
                        </IconButton>
                    </Box>
                    <Box sx={{ display: { xs: 'flex', md: 'none' } }}>
                        <IconButton
                            size="large"
                            aria-label="show more"
                            aria-controls={mobileMenuId}
                            aria-haspopup="true"
                            onClick={handleMobileMenuOpen}
                            color="inherit"
                        >
                            <MoreIcon />
                        </IconButton>
                    </Box>
                </Toolbar>
            </AppBar>
            {renderMobileMenu}
            {renderMenu}
        </>
    );
};

export default AdminHeader;
src/components/admin/AdminSidebar.jsx
jsx
import React from 'react';
import {
    Box,
    Drawer,
    List,
    Divider,
    ListItem,
    ListItemButton,
    ListItemIcon,
    ListItemText,
    Toolbar
} from '@mui/material';
import {
    Dashboard as DashboardIcon,
    Person as PersonIcon,
    EventNote as EventNoteIcon,
    Settings as SettingsIcon
} from '@mui/icons-material';
import { useNavigate, useLocation } from 'react-router-dom';

const drawerWidth = 240;

const AdminSidebar = ({ open, toggleDrawer }) => {
    const navigate = useNavigate();
    const location = useLocation();

    const menuItems = [
        {
            text: 'Tableau de bord',
            icon: <DashboardIcon />,
            path: '/admin/dashboard'
        },
        {
            text: 'Gestion des utilisateurs',
            icon: <PersonIcon />,
            path: '/admin/utilisateurs'
        },
        {
            text: 'Paramètres',
            icon: <SettingsIcon />,
            path: '/admin/parametres'
        }
    ];

    return (
        <Drawer
            variant="permanent"
            sx={{
                width: drawerWidth,
                flexShrink: 0,
                [`& .MuiDrawer-paper`]: {
                    width: drawerWidth,
                    boxSizing: 'border-box',
                    whiteSpace: 'nowrap',
                    overflowX: 'hidden',
                    transition: (theme) => theme.transitions.create('width', {
                        easing: theme.transitions.easing.sharp,
                        duration: theme.transitions.duration.enteringScreen,
                    }),
                    ...(!open && {
                        width: theme => theme.spacing(7),
                        transition: (theme) => theme.transitions.create('width', {
                            easing: theme.transitions.easing.sharp,
                            duration: theme.transitions.duration.leavingScreen,
                        }),
                    }),
                },
            }}
            open={open}
        >
            <Toolbar />
            <Box sx={{ overflow: 'auto' }}>
                <List>
                    {menuItems.map((item) => (
                        <ListItem
                            key={item.text}
                            disablePadding
                            sx={{
                                display: 'block',
                                backgroundColor: location.pathname === item.path ? 'rgba(0, 0, 0, 0.04)' : 'transparent'
                            }}
                        >
                            <ListItemButton
                                sx={{
                                    minHeight: 48,
                                    justifyContent: open ? 'initial' : 'center',
                                    px: 2.5,
                                }}
                                onClick={() => navigate(item.path)}
                            >
                                <ListItemIcon
                                    sx={{
                                        minWidth: 0,
                                        mr: open ? 3 : 'auto',
                                        justifyContent: 'center',
                                    }}
                                >
                                    {item.icon}
                                </ListItemIcon>
                                <ListItemText primary={item.text} sx={{ opacity: open ? 1 : 0 }} />
                            </ListItemButton>
                        </ListItem>
                    ))}
                </List>
            </Box>
        </Drawer>
    );
};

export default AdminSidebar;
src/pages/admin/AdminDashboard.jsx
jsx
import React, { useState, useEffect } from 'react';
import {
    Container,
    Grid,
    Paper,
    Typography,
    Box,
    Card,
    CardContent,
    CardHeader,
    List,
    ListItem,
    ListItemText,
    Divider
} from '@mui/material';
import {
    Person as PersonIcon,
    MedicalServices as MedicinIcon,
    AssignmentInd as SecretaryIcon,
    SupervisorAccount as AdminIcon,
    Event as EventIcon
} from '@mui/icons-material';
import { getUtilisateursEnAttente } from '../../services/adminService';

const AdminDashboard = () => {
    const [utilisateursEnAttente, setUtilisateursEnAttente] = useState([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const fetchData = async () => {
            try {
                const response = await getUtilisateursEnAttente();
                setUtilisateursEnAttente(response.data);
            } catch (error) {
                console.error('Erreur lors du chargement des utilisateurs en attente:', error);
            } finally {
                setLoading(false);
            }
        };

        fetchData();
    }, []);

    // Données fictives pour le tableau de bord
    const stats = {
        totalUsers: 120,
        totalPatients: 80,
        totalMedecins: 25,
        totalSecretaires: 14,
        totalAdmins: 1,
        rendezVousSemaine: 45
    };

    return (
        <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
            <Typography variant="h4" gutterBottom>
                Tableau de bord
            </Typography>

            <Grid container spacing={3}>
                {/* Statistiques */}
                <Grid item xs={12} md={8}>
                    <Paper sx={{ p: 2, display: 'flex', flexDirection: 'column' }}>
                        <Typography variant="h6" gutterBottom>
                            Statistiques générales
                        </Typography>
                        <Grid container spacing={3}>
                            <Grid item xs={6} sm={4}>
                                <Card sx={{ bgcolor: '#f5f5f5' }}>
                                    <CardContent sx={{ textAlign: 'center' }}>
                                        <PersonIcon color="primary" sx={{ fontSize: 40 }} />
                                        <Typography variant="h5">{stats.totalUsers}</Typography>
                                        <Typography variant="body2" color="text.secondary">
                                            Utilisateurs
                                        </Typography>
                                    </CardContent>
                                </Card>
                            </Grid>
                            <Grid item xs={6} sm={4}>
                                <Card sx={{ bgcolor: '#f5f5f5' }}>
                                    <CardContent sx={{ textAlign: 'center' }}>
                                        <PersonIcon color="info" sx={{ fontSize: 40 }} />
                                        <Typography variant="h5">{stats.totalPatients}</Typography>
                                        <Typography variant="body2" color="text.secondary">
                                            Patients
                                        </Typography>
                                    </CardContent>
                                </Card>
                            </Grid>
                            <Grid item xs={6} sm={4}>
                                <Card sx={{ bgcolor: '#f5f5f5' }}>
                                    <CardContent sx={{ textAlign: 'center' }}>
                                        <MedicinIcon color="success" sx={{ fontSize: 40 }} />
                                        <Typography variant="h5">{stats.totalMedecins}</Typography>
                                        <Typography variant="body2" color="text.secondary">
                                            Médecins
                                        </Typography>
                                    </CardContent>
                                </Card>
                            </Grid>
                            <Grid item xs={6} sm={4}>
                                <Card sx={{ bgcolor: '#f5f5f5' }}>
                                    <CardContent sx={{ textAlign: 'center' }}>
                                        <SecretaryIcon color="warning" sx={{ fontSize: 40 }} />
                                        <Typography variant="h5">{stats.totalSecretaires}</Typography>
                                        <Typography variant="body2" color="text.secondary">
                                            Secrétaires
                                        </Typography>
                                    </CardContent>
                                </Card>
                            </Grid>
                            <Grid item xs={6} sm={4}>
                                <Card sx={{ bgcolor: '#f5f5f5' }}>
                                    <CardContent sx={{ textAlign: 'center' }}>
                                        <AdminIcon color="error" sx={{ fontSize: 40 }} />
                                        <Typography variant="h5">{stats.totalAdmins}</Typography>
                                        <Typography variant="body2" color="text.secondary">
                                            Administrateurs
                                        </Typography>
                                    </CardContent>
                                </Card>
                            </Grid>
                            <Grid item xs={6} sm={4}>
                                <Card sx={{ bgcolor: '#f5f5f5' }}>
                                    <CardContent sx={{ textAlign: 'center' }}>
                                        <EventIcon color="secondary" sx={{ fontSize: 40 }} />
                                        <Typography variant="h5">{stats.rendezVousSemaine}</Typography>
                                        <Typography variant="body2" color="text.secondary">
                                            RDV cette semaine
                                        </Typography>
                                    </CardContent>
                                </Card>
                            </Grid>
                        </Grid>
                    </Paper>
                </Grid>

                {/* Utilisateurs en attente */}
                <Grid item xs={12} md={4}>
                    <Paper sx={{ p: 2, display: 'flex', flexDirection: 'column' }}>
                        <Typography variant="h6" gutterBottom>
                            Utilisateurs en attente de validation
                        </Typography>
                        {loading ? (
                            <Typography variant="body2">Chargement...</Typography>
                        ) : utilisateursEnAttente.length > 0 ? (
                            <List>
                                {utilisateursEnAttente.map((user, index) => (
                                    <React.Fragment key={user.id}>
                                        <ListItem>
                                            <ListItemText
                                                primary={`${user.nom} ${user.prenom}`}
                                                secondary={user.email}
                                            />
                                        </ListItem>
                                        {index < utilisateursEnAttente.length - 1 && <Divider />}
                                    </React.Fragment>
                                ))}
                            </List>
                        ) : (
                            <Typography variant="body2">Aucun utilisateur en attente</Typography>
                        )}
                    </Paper>
                </Grid>
            </Grid>
        </Container>
    );
};

export default AdminDashboard;
src/pages/admin/GestionUtilisateurs.jsx
jsx
import React, { useState, useEffect } from 'react';
import {
    Container,
    Typography,
    Paper,
    Button,
    Box,
    Tabs,
    Tab,
    Dialog,
    DialogActions,
    DialogContent,
    DialogContentText,
    DialogTitle,
    Alert,
    Snackbar,
    Chip
} from '@mui/material';
import { DataGrid } from '@mui/x-data-grid';
import {
    CheckCircle as CheckCircleIcon,
    Cancel as CancelIcon,
    Block as BlockIcon,
    Info as InfoIcon,
    PersonAdd as PersonAddIcon
} from '@mui/icons-material';
import {
    getAllUtilisateurs,
    getUtilisateursEnAttente,
    validerUtilisateur,
    rejeterUtilisateur,
    activerUtilisateur,
    desactiverUtilisateur
} from '../../services/adminService';

function TabPanel(props) {
    const { children, value, index, ...other } = props;
    return (
        <div
            role="tabpanel"
            hidden={value !== index}
            id={`utilisateurs-tabpanel-${index}`}
            aria-labelledby={`utilisateurs-tab-${index}`}
            {...other}
        >
            {value === index && (
                <Box sx={{ p: 3 }}>
                    {children}
                </Box>
            )}
        </div>
    );
}

const GestionUtilisateurs = () => {
    const [tabValue, setTabValue] = useState(0);
    const [utilisateurs, setUtilisateurs] = useState([]);
    const [utilisateursEnAttente, setUtilisateursEnAttente] = useState([]);
    const [loading, setLoading] = useState(true);
    const [selectedUser, setSelectedUser] = useState(null);
    const [dialogOpen, setDialogOpen] = useState(false);
    const [dialogType, setDialogType] = useState('');
    const [snackbar, setSnackbar] = useState({
        open: false,
        message: '',
        severity: 'success'
    });

    useEffect(() => {
        fetchData();
    }, []);

    const fetchData = async () => {
        setLoading(true);
        try {
            const [utilisateursResponse, enAttenteResponse] = await Promise.all([
                getAllUtilisateurs(),
                getUtilisateursEnAttente()
            ]);
            setUtilisateurs(utilisateursResponse.data);
            setUtilisateursEnAttente(enAttenteResponse.data);
        } catch (error) {
            console.error('Erreur lors du chargement des utilisateurs:', error);
            showSnackbar('Erreur lors du chargement des données', 'error');
        } finally {
            setLoading(false);
        }
    };

    const handleTabChange = (event, newValue) => {
        setTabValue(newValue);
    };

    const handleOpenDialog = (type, user) => {
        setSelectedUser(user);
        setDialogType(type);
        setDialogOpen(true);
    };

    const handleCloseDialog = () => {
        setDialogOpen(false);
        setSelectedUser(null);
    };

    const handleConfirmDialog = async () => {
        try {
            switch (dialogType) {
                case 'valider':
                    await validerUtilisateur(selectedUser.id);
                    showSnackbar(`L'utilisateur ${selectedUser.nom} ${selectedUser.prenom} a été validé avec succès`);
                    break;
                case 'rejeter':
                    await rejeterUtilisateur(selectedUser.id);
                    showSnackbar(`L'utilisateur ${selectedUser.nom} ${selectedUser.prenom} a été rejeté`);
                    break;
                case 'activer':
                    await activerUtilisateur(selectedUser.id);
                    showSnackbar(`L'utilisateur ${selectedUser.nom} ${selectedUser.prenom} a été activé avec succès`);
                    break;
                case 'desactiver':
                    await desactiverUtilisateur(selectedUser.id);
                    showSnackbar(`L'utilisateur ${selectedUser.nom} ${selectedUser.prenom} a été désactivé avec succès`);
                    break;
                default:
                    break;
            }
            fetchData();
        } catch (error) {
            console.error('Erreur lors de l\'opération:', error);
            showSnackbar('Erreur lors de l\'opération', 'error');
        } finally {
            handleCloseDialog();
        }
    };

    const showSnackbar = (message, severity = 'success') => {
        setSnackbar({
            open: true,
            message,
            severity
        });
    };

    const handleCloseSnackbar = () => {
        setSnackbar({ ...snackbar, open: false });
    };

    const getRoleLabel = (role) => {
        switch (role) {
            case 'ROLE_ADMIN':
                return 'Administrateur';
            case 'ROLE_MEDECIN':
                return 'Médecin';
            case 'ROLE_PATIENT':
                return 'Patient';
            case 'ROLE_SECRETAIRE':
                return 'Secrétaire';
            default:
                return role;
        }
    };

    const getRoleChip = (role) => {
        let color;
        switch (role) {
            case 'ROLE_ADMIN':
                color = 'error';
                break;
            case 'ROLE_MEDECIN':
                color = 'success';
                break;
            case 'ROLE_PATIENT':
                color = 'primary';
                break;
            case 'ROLE_SECRETAIRE':
                color = 'warning';
                break;
            default:
                color = 'default';
        }
        return <Chip label={getRoleLabel(role)} color={color} size="small" />;
    };

    const getStatusChip = (status) => {
        return status ? (
            <Chip label="Actif" color="success" size="small" icon={<CheckCircleIcon />} />
        ) : (
            <Chip label="Inactif" color="error" size="small" icon={<BlockIcon />} />
        );
    };

    const columnsUtilisateurs = [
        { field: 'id', headerName: 'ID', width: 70 },
        {
            field: 'nom',
            headerName: 'Nom',
            width: 150,
            valueGetter: (params) => `${params.row.nom} ${params.row.prenom}`
        },
        { field: 'email', headerName: 'Email', width: 200 },
        {
            field: 'roles',
            headerName: 'Rôle',
            width: 150,
            renderCell: (params) => getRoleChip(params.row.roles[0]?.name)
        },
        {
            field: 'actif',
            headerName: 'Statut',
            width: 120,
            renderCell: (params) => getStatusChip(params.row.actif)
        },
        {
            field: 'actions',
            headerName: 'Actions',
            width: 200,
            renderCell: (params) => (
                <Box sx={{ display: 'flex', gap: 1 }}>
                    <Button
                        variant="outlined"
                        size="small"
                        startIcon={<InfoIcon />}
                    >
                        Détails
                    </Button>
                    {params.row.actif ? (
                        <Button
                            variant="outlined"
                            color="error"
                            size="small"
                            startIcon={<BlockIcon />}
                            onClick={() => handleOpenDialog('desactiver', params.row)}
                        >
                            Désactiver
                        </Button>
                    ) : (
                        <Button
                            variant="outlined"
                            color="success"
                            size="small"
                            startIcon={<CheckCircleIcon />}
                            onClick={() => handleOpenDialog('activer', params.row)}
                        >
                            Activer
                        </Button>
                    )}
                </Box>
            )
        }
    ];

    const columnsEnAttente = [
        { field: 'id', headerName: 'ID', width: 70 },
        {
            field: 'nom',
            headerName: 'Nom',
            width: 150,
            valueGetter: (params) => `${params.row.nom} ${params.row.prenom}`
        },
        { field: 'email', headerName: 'Email', width: 200 },
        {
            field: 'roles',
            headerName: 'Rôle',
            width: 150,
            renderCell: (params) => getRoleChip(params.row.roles[0]?.name)
        },
        {
            field: 'dateCreation',
            headerName: 'Date d\'inscription',
            width: 180,
            valueFormatter: (params) => {
                if (!params.value) return '';
                const date = new Date(params.value);
                return date.toLocaleDateString('fr-FR') + ' ' + date.toLocaleTimeString('fr-FR');
            }
        },
        {
            field: 'actions',
            headerName: 'Actions',
            width: 200,
            renderCell: (params) => (
                <Box sx={{ display: 'flex', gap: 1 }}>
                    <Button
                        variant="contained"
                        color="success"
                        size="small"
                        startIcon={<CheckCircleIcon />}
                        onClick={() => handleOpenDialog('valider', params.row)}
                    >
                        Valider
                    </Button>
                    <Button
                        variant="contained"
                        color="error"
                        size="small"
                        startIcon={<CancelIcon />}
                        onClick={() => handleOpenDialog('rejeter', params.row)}
                    >
                        Rejeter
                    </Button>
                </Box>
            )
        }
    ];

    return (
        <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                <Typography variant="h4" gutterBottom>
                    Gestion des utilisateurs
                </Typography>
                <Button
                    variant="contained"
                    color="primary"
                    startIcon={<PersonAddIcon />}
                >
                    Ajouter un utilisateur
                </Button>
            </Box>

            <Paper sx={{ width: '100%', mb: 2 }}>
                <Tabs
                    value={tabValue}
                    onChange={handleTabChange}
                    indicatorColor="primary"
                    textColor="primary"
                >
                    <Tab label="Utilisateurs actifs" />
                    <Tab label={`En attente (${utilisateursEnAttente.length})`} />
                </Tabs>

                <TabPanel value={tabValue} index={0}>
                    <Box sx={{ height: 500, width: '100%' }}>
                        <DataGrid
                            rows={utilisateurs}
                            columns={columnsUtilisateurs}
                            pageSize={10}
                            rowsPerPageOptions={[10, 25, 50]}
                            loading={loading}
                            disableSelectionOnClick
                        />
                    </Box>
                </TabPanel>

                <TabPanel value={tabValue} index={1}>
                    <Box sx={{ height: 500, width: '100%' }}>
                        <DataGrid
                            rows={utilisateursEnAttente}
                            columns={columnsEnAttente}
                            pageSize={10}
                            rowsPerPageOptions={[10, 25, 50]}
                            loading={loading}
                            disableSelectionOnClick
                        />
                    </Box>
                </TabPanel>
            </Paper>

            {/* Dialogue de confirmation */}
            <Dialog
                open={dialogOpen}
                onClose={handleCloseDialog}
            >
                <DialogTitle>
                    {dialogType === 'valider' ? 'Valider cet utilisateur' :
                        dialogType === 'rejeter' ? 'Rejeter cet utilisateur' :
                            dialogType === 'activer' ? 'Activer cet utilisateur' :
                                'Désactiver cet utilisateur'}
                </DialogTitle>
                <DialogContent>
                    <DialogContentText>
                        {dialogType === 'valider' ? 'Voulez-vous vraiment valider cet utilisateur ? Il pourra alors se connecter à la plateforme.' :
                            dialogType === 'rejeter' ? 'Voulez-vous vraiment rejeter cet utilisateur ? Cette action est irréversible.' :
                                dialogType === 'activer' ? 'Voulez-vous vraiment activer cet utilisateur ?' :
                                    'Voulez-vous vraiment désactiver cet utilisateur ? Il ne pourra plus se connecter à la plateforme.'}
                    </DialogContentText>
                    {selectedUser && (
                        <Typography variant="body1" sx={{ mt: 2 }}>
                            {selectedUser.nom



Continuer

Modifier
Continuons avec la gestion des utilisateurs dans notre application de téléconsultation.

src/pages/admin/GestionUtilisateurs.jsx (suite)
jsx
                    {selectedUser && (
                        <Typography variant="body1" sx={{ mt: 2 }}>
                            {selectedUser.nom} {selectedUser.prenom} ({selectedUser.email})
                        </Typography>
                    )}
                </DialogContent>
                <DialogActions>
                    <Button onClick={handleCloseDialog}>Annuler</Button>
                    <Button
                        onClick={handleConfirmDialog}
                        variant="contained"
                        color={dialogType === 'rejeter' || dialogType === 'desactiver' ? 'error' : 'primary'}
                        autoFocus
                    >
                        Confirmer
                    </Button>
                </DialogActions>
            </Dialog>

            {/* Snackbar pour les notifications */}
            <Snackbar
                open={snackbar.open}
                autoHideDuration={6000}
                onClose={handleCloseSnackbar}
                anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
            >
                <Alert
                    onClose={handleCloseSnackbar}
                    severity={snackbar.severity}
                    sx={{ width: '100%' }}
                >
                    {snackbar.message}
                </Alert>
            </Snackbar>
        </Container>
    );
};

export default GestionUtilisateurs;
Cela complète notre Phase 2 pour l'authentification et la gestion des utilisateurs. Nous avons mis en place:

Côté Backend:
Configuration de la sécurité avec Spring Security et JWT
Service d'authentification
Contrôleurs pour l'inscription et la connexion
Service de gestion des utilisateurs (validation, activation, etc.)
Service d'envoi d'emails pour les notifications
Côté Frontend:
Contexte d'authentification avec React
Pages de connexion et d'inscription
Layout administrateur avec en-tête et barre latérale
Tableau de bord administrateur
Gestion des utilisateurs (liste, validation, activation/désactivation)
Cette phase nous donne une base solide pour construire les fonctionnalités spécifiques à chaque type d'utilisateur dans les phases suivantes.

Dans la Phase 3, nous allons développer les tableaux de bord et les fonctionnalités de base pour les différents types d'utilisateurs (médecin, patient, secrétaire), puis nous passerons à la gestion des rendez-vous dans la Phase 4.

Voulez-vous que nous passions à la Phase 3, ou souhaitez-vous d'abord apporter des modifications à ce que nous avons fait pour la Phase 2?




WebSecurityConfigurerAdapter utilisé dans SecurityConfig est déprécié, il faut utilisé une approche compatible avec les versions recentes de spring security

Modifier
Vous avez tout à fait raison. La classe WebSecurityConfigurerAdapter est effectivement dépréciée dans les versions récentes de Spring Security (à partir de Spring Security 5.7.0). Utilisons l'approche recommandée pour configurer la sécurité dans notre application.

Voici la version mise à jour de notre classe SecurityConfig.java:

java
package com.teleconsultation.api.config;

import com.teleconsultation.api.security.jwt.AuthEntryPointJwt;
import com.teleconsultation.api.security.jwt.AuthTokenFilter;
import com.teleconsultation.api.security.services.UserDetailsServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;

@Configuration
@EnableMethodSecurity
public class SecurityConfig {
    
    @Autowired
    UserDetailsServiceImpl userDetailsService;

    @Autowired
    private AuthEntryPointJwt unauthorizedHandler;

    @Bean
    public AuthTokenFilter authenticationJwtTokenFilter() {
        return new AuthTokenFilter();
    }
    
    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        
        return authProvider;
    }
    
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList("http://localhost:3000")); // Origine du frontend
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("Authorization", "Content-Type"));
        configuration.setAllowCredentials(true);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.cors().configurationSource(corsConfigurationSource())
            .and().csrf().disable()
            .exceptionHandling().authenticationEntryPoint(unauthorizedHandler)
            .and().sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and().authorizeHttpRequests()
            .antMatchers("/api/auth/**").permitAll() // Endpoints d'authentification publics
            .antMatchers("/api/public/**").permitAll() // Autres endpoints publics
            .anyRequest().authenticated();
        
        http.authenticationProvider(authenticationProvider());
        http.addFilterBefore(authenticationJwtTokenFilter(), UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
}
Vous devrez également mettre à jour l'annotation @EnableGlobalMethodSecurity vers @EnableMethodSecurity comme je l'ai fait dans le code mis à jour.

À noter que pour Spring Security 6.1+ (Spring Boot 3.x+), la méthode antMatchers est également dépréciée et devrait être remplacée par requestMatchers. Voici comment cela se traduirait si vous utilisez Spring Boot 3.x:

java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http.cors().configurationSource(corsConfigurationSource())
        .and().csrf().disable()
        .exceptionHandling().authenticationEntryPoint(unauthorizedHandler)
        .and().sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
        .and().authorizeHttpRequests()
        .requestMatchers("/api/auth/**").permitAll() // Endpoints d'authentification publics
        .requestMatchers("/api/public/**").permitAll() // Autres endpoints publics
        .anyRequest().authenticated();
    
    http.authenticationProvider(authenticationProvider());
    http.addFilterBefore(authenticationJwtTokenFilter(), UsernamePasswordAuthenticationFilter.class);
    
    return http.build();
}
De plus, dans Spring Security 6.1+, la configuration utilise souvent le style lambda pour plus de lisibilité et moins de méthodes en chaîne:

java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .cors(cors -> cors.configurationSource(corsConfigurationSource()))
        .csrf(csrf -> csrf.disable())
        .exceptionHandling(exception -> exception.authenticationEntryPoint(unauthorizedHandler))
        .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
        .authorizeHttpRequests(auth -> 
            auth
                .requestMatchers("/api/auth/**").permitAll()
                .requestMatchers("/api/public/**").permitAll()
                .anyRequest().authenticated()
        );
    
    http.authenticationProvider(authenticationProvider());
    http.addFilterBefore(authenticationJwtTokenFilter(), UsernamePasswordAuthenticationFilter.class);
    
    return http.build();
}
Ces modifications permettront à notre application de fonctionner avec les versions récentes de Spring Security tout en maintenant le même niveau de sécurité et de fonctionnalité.




j'ai fini la phase 2 mais vant d'aller à la phase 3 est-il possible de tester ce qui a déjà été fait ?

Modifier
Absolument, c'est une excellente idée de tester ce que nous avons mis en place avant de passer à la phase suivante. Cela nous permettra d'identifier et de corriger tout problème potentiel.

Voici comment nous pouvons tester les fonctionnalités de la Phase 2 :

Tests pour la Phase 2 : Authentification et gestion des utilisateurs
1. Test de la base de données et des entités
Créons une classe de test pour vérifier que nos entités sont correctement mappées à la base de données :

java
package com.teleconsultation.api.repository;

import com.teleconsultation.api.models.*;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.test.context.ActiveProfiles;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Optional;
import java.util.Set;

import static org.assertj.core.api.Assertions.assertThat;

@DataJpaTest
@ActiveProfiles("test")
public class UserRepositoryTest {

    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private RoleRepository roleRepository;
    
    @Autowired
    private PatientRepository patientRepository;

    @Test
    public void testCreatePatient() {
        // Créer un rôle
        Role rolePatient = new Role(ERole.ROLE_PATIENT);
        roleRepository.save(rolePatient);
        
        // Créer un patient
        Patient patient = new Patient();
        patient.setNom("Dupont");
        patient.setPrenom("Jean");
        patient.setEmail("jean.dupont@example.com");
        patient.setMotDePasse(new BCryptPasswordEncoder().encode("password"));
        patient.setTelephone("0123456789");
        patient.setNumeroSecuriteSociale("1234567890123");
        patient.setDateNaissance(LocalDate.of(1980, 1, 1));
        patient.setAdresse("1 rue de Paris, 75001 Paris");
        patient.setCompteValide(true);
        patient.setActif(true);
        
        // Ajouter le rôle au patient
        Set<Role> roles = new HashSet<>();
        roles.add(rolePatient);
        patient.setRoles(roles);
        
        // Sauvegarder le patient
        patientRepository.save(patient);
        
        // Vérifier que le patient a été créé
        Optional<User> foundUser = userRepository.findByEmail("jean.dupont@example.com");
        assertThat(foundUser).isPresent();
        assertThat(foundUser.get()).isInstanceOf(Patient.class);
        
        Patient foundPatient = (Patient) foundUser.get();
        assertThat(foundPatient.getNom()).isEqualTo("Dupont");
        assertThat(foundPatient.getPrenom()).isEqualTo("Jean");
        assertThat(foundPatient.getNumeroSecuriteSociale()).isEqualTo("1234567890123");
    }
}
2. Test des contrôleurs avec Postman/Insomnia
Nous pouvons tester nos API REST avec Postman ou Insomnia pour s'assurer qu'elles fonctionnent correctement.

Inscription
URL: POST http://localhost:8080/api/auth/register/patient
Body:
json
{
  "nom": "Dupont",
  "prenom": "Jean",
  "email": "jean.dupont@example.com",
  "motDePasse": "password123",
  "telephone": "0123456789",
  "numeroSecuriteSociale": "1234567890123",
  "dateNaissance": "1980-01-01",
  "adresse": "1 rue de Paris, 75001 Paris"
}
Connexion
URL: POST http://localhost:8080/api/auth/login
Body:
json
{
  "email": "jean.dupont@example.com",
  "password": "password123"
}
Liste des utilisateurs (nécessite le token JWT)
URL: GET http://localhost:8080/api/admin/utilisateurs
Header: Authorization: Bearer <token_jwt>
Valider un utilisateur (nécessite le token JWT d'un administrateur)
URL: PUT http://localhost:8080/api/admin/utilisateurs/1/valider
Header: Authorization: Bearer <token_jwt>
3. Test de l'interface frontend
Nous devrions également tester notre interface frontend pour nous assurer que tout fonctionne comme prévu :

Tester la page d'inscription
Accéder à http://localhost:3000/register
Remplir le formulaire d'inscription pour un patient
Vérifier que la soumission du formulaire fonctionne et que le message de succès s'affiche
Tester la page de connexion
Accéder à http://localhost:3000/login
Essayer de se connecter avec un compte invalide (vérifier les messages d'erreur)
Se connecter avec un compte valide (vérifier la redirection)
Tester l'interface d'administration
Se connecter en tant qu'administrateur
Vérifier que le tableau de bord s'affiche correctement
Accéder à la page de gestion des utilisateurs
Tester les fonctionnalités de validation/rejet des utilisateurs
4. Script pour initialiser la base de données
Pour faciliter les tests, nous pouvons créer un script qui initialise la base de données avec des utilisateurs de test, y compris un administrateur. Ce script peut être exécuté au démarrage de l'application en mode développement.

java
package com.teleconsultation.api.config;

import com.teleconsultation.api.models.*;
import com.teleconsultation.api.repository.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

@Configuration
@Profile("dev")
public class DevInitializer {

    @Autowired
    private RoleRepository roleRepository;
    
    @Autowired
    private AdminRepository adminRepository;
    
    @Autowired
    private MedecinRepository medecinRepository;
    
    @Autowired
    private PatientRepository patientRepository;
    
    @Autowired
    private SecretaireMedicalRepository secretaireRepository;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    @Bean
    public CommandLineRunner initDevData() {
        return args -> {
            System.out.println("Initialisation des données de développement...");
            
            // Créer les rôles s'ils n'existent pas
            createRoleIfNotExists(ERole.ROLE_ADMIN);
            createRoleIfNotExists(ERole.ROLE_MEDECIN);
            createRoleIfNotExists(ERole.ROLE_PATIENT);
            createRoleIfNotExists(ERole.ROLE_SECRETAIRE);
            
            // Créer un administrateur
            if (adminRepository.count() == 0) {
                Admin admin = new Admin();
                admin.setNom("Admin");
                admin.setPrenom("System");
                admin.setEmail("admin@teleconsultation.com");
                admin.setMotDePasse(passwordEncoder.encode("admin123"));
                admin.setCompteValide(true);
                admin.setActif(true);
                
                Set<Role> adminRoles = new HashSet<>();
                adminRoles.add(roleRepository.findByName(ERole.ROLE_ADMIN).get());
                admin.setRoles(adminRoles);
                
                adminRepository.save(admin);
                System.out.println("Admin créé");
            }
            
            // Créer un médecin
            if (medecinRepository.count() == 0) {
                Medecin medecin = new Medecin();
                medecin.setNom("Docteur");
                medecin.setPrenom("Martin");
                medecin.setEmail("docteur.martin@teleconsultation.com");
                medecin.setMotDePasse(passwordEncoder.encode("medecin123"));
                medecin.setTelephone("0123456789");
                medecin.setSpecialite("Généraliste");
                medecin.setNumeroOrdre("12345");
                medecin.setCompteValide(true);
                medecin.setActif(true);
                
                Set<Role> medecinRoles = new HashSet<>();
                medecinRoles.add(roleRepository.findByName(ERole.ROLE_MEDECIN).get());
                medecin.setRoles(medecinRoles);
                
                medecinRepository.save(medecin);
                System.out.println("Médecin créé");
            }
            
            // Créer un patient
            if (patientRepository.count() == 0) {
                Patient patient = new Patient();
                patient.setNom("Dupont");
                patient.setPrenom("Jean");
                patient.setEmail("jean.dupont@example.com");
                patient.setMotDePasse(passwordEncoder.encode("patient123"));
                patient.setTelephone("0123456789");
                patient.setNumeroSecuriteSociale("1234567890123");
                patient.setDateNaissance(LocalDate.of(1980, 1, 1));
                patient.setAdresse("1 rue de Paris, 75001 Paris");
                patient.setCompteValide(true);
                patient.setActif(true);
                
                Set<Role> patientRoles = new HashSet<>();
                patientRoles.add(roleRepository.findByName(ERole.ROLE_PATIENT).get());
                patient.setRoles(patientRoles);
                
                patientRepository.save(patient);
                System.out.println("Patient créé");
            }
            
            // Créer un secrétaire
            if (secretaireRepository.count() == 0) {
                SecretaireMedical secretaire = new SecretaireMedical();
                secretaire.setNom("Dubois");
                secretaire.setPrenom("Marie");
                secretaire.setEmail("marie.dubois@teleconsultation.com");
                secretaire.setMotDePasse(passwordEncoder.encode("secretaire123"));
                secretaire.setTelephone("0123456789");
                secretaire.setService("Accueil");
                secretaire.setCompteValide(true);
                secretaire.setActif(true);
                
                Set<Role> secretaireRoles = new HashSet<>();
                secretaireRoles.add(roleRepository.findByName(ERole.ROLE_SECRETAIRE).get());
                secretaire.setRoles(secretaireRoles);
                
                secretaireRepository.save(secretaire);
                System.out.println("Secrétaire créé");
            }
            
            System.out.println("Initialisation terminée");
        };
    }
    
    private void createRoleIfNotExists(ERole roleName) {
        if (!roleRepository.findByName(roleName).isPresent()) {
            Role role = new Role(roleName);
            roleRepository.save(role);
            System.out.println("Rôle " + roleName + " créé");
        }
    }
}
5. Tests automatisés pour les services
Nous pouvons également écrire des tests automatisés pour nos services :

java
package com.teleconsultation.api.service;

import com.teleconsultation.api.models.ERole;
import com.teleconsultation.api.models.Role;
import com.teleconsultation.api.models.User;
import com.teleconsultation.api.payload.request.PatientRequest;
import com.teleconsultation.api.repository.PatientRepository;
import com.teleconsultation.api.repository.RoleRepository;
import com.teleconsultation.api.repository.UserRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.time.LocalDate;
import java.util.Optional;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

public class UserServiceTest {

    @InjectMocks
    private UserService userService;
    
    @Mock
    private UserRepository userRepository;
    
    @Mock
    private PatientRepository patientRepository;
    
    @Mock
    private RoleRepository roleRepository;
    
    @Mock
    private PasswordEncoder passwordEncoder;
    
    @Mock
    private EmailService emailService;
    
    @BeforeEach
    public void setup() {
        MockitoAnnotations.openMocks(this);
    }
    
    @Test
    public void testRegisterPatient() {
        // Préparer les données de test
        PatientRequest patientRequest = new PatientRequest();
        patientRequest.setNom("Dupont");
        patientRequest.setPrenom("Jean");
        patientRequest.setEmail("jean.dupont@example.com");
        patientRequest.setMotDePasse("password123");
        patientRequest.setNumeroSecuriteSociale("1234567890123");
        patientRequest.setDateNaissance(LocalDate.of(1980, 1, 1));
        patientRequest.setAdresse("1 rue de Paris, 75001 Paris");
        
        // Configurer les mocks
        when(userRepository.existsByEmail("jean.dupont@example.com")).thenReturn(false);
        when(passwordEncoder.encode("password123")).thenReturn("encoded_password");
        when(roleRepository.findByName(ERole.ROLE_PATIENT)).thenReturn(Optional.of(new Role(ERole.ROLE_PATIENT)));
        when(patientRepository.save(any())).thenReturn(null); // Pour simplifier
        doNothing().when(emailService).envoyerEmailNouvelleInscription(any());
        
        // Exécuter la méthode à tester
        userService.registerPatient(patientRequest);
        
        // Vérifier que les méthodes attendues ont été appelées
        verify(userRepository).existsByEmail("jean.dupont@example.com");
        verify(passwordEncoder).encode("password123");
        verify(roleRepository).findByName(ERole.ROLE_PATIENT);
        verify(patientRepository).save(any());
        verify(emailService).envoyerEmailNouvelleInscription(any());
    }
    
    @Test
    public void testRegisterPatientWithExistingEmail() {
        // Préparer les données de test
        PatientRequest patientRequest = new PatientRequest();
        patientRequest.setEmail("jean.dupont@example.com");
        
        // Configurer les mocks pour simuler un email déjà existant
        when(userRepository.existsByEmail("jean.dupont@example.com")).thenReturn(true);
        
        // Vérifier que l'exception est levée
        Exception exception = assertThrows(RuntimeException.class, () -> {
            userService.registerPatient(patientRequest);
        });
        
        assertTrue(exception.getMessage().contains("Cet email est déjà utilisé"));
        
        // Vérifier que les méthodes attendues ont été appelées
        verify(userRepository).existsByEmail("jean.dupont@example.com");
        // Vérifier que les autres méthodes n'ont pas été appelées
        verify(patientRepository, never()).save(any());
        verify(emailService, never()).envoyerEmailNouvelleInscription(any());
    }
}
Plan de test global
Démarrer avec la base de données vide
Exécuter le script d'initialisation pour créer les utilisateurs de test
Vérifier que les utilisateurs sont bien créés dans la base de données
Tester l'inscription
Inscrire un nouveau patient via l'API
Vérifier que l'utilisateur est créé dans la base de données avec le statut "non validé"
Vérifier que le service d'email est appelé pour notifier l'administrateur
Tester la validation d'un utilisateur
Se connecter en tant qu'administrateur
Valider un utilisateur en attente
Vérifier que le statut de l'utilisateur est mis à jour
Vérifier que le service d'email est appelé pour notifier l'utilisateur
Tester la connexion
Essayer de se connecter avec un utilisateur non validé (devrait échouer)
Essayer de se connecter avec un utilisateur validé (devrait réussir)
Vérifier que le token JWT est généré et retourné
Tester les autorisations
Essayer d'accéder à une ressource protégée sans token (devrait échouer)
Essayer d'accéder à une ressource protégée avec un token valide (devrait réussir)
Essayer d'accéder à une ressource réservée à un rôle spécifique avec un autre rôle (devrait échouer)
En exécutant ces tests, nous pourrons nous assurer que notre système d'authentification et de gestion des utilisateurs fonctionne correctement avant de passer à la Phase 3.




quand je demarre l'application frontend j'ai ceci : 
ERROR in ./src/App.js 21:0-63
Module not found: Error: Can't resolve './components/layouts/MedecinLayout' in 'D:\teleconsultation-frontend\src'
ERROR in ./src/App.js 22:0-63
Module not found: Error: Can't resolve './components/layouts/PatientLayout' in 'D:\teleconsultation-frontend\src'
ERROR in ./src/App.js 23:0-69
Module not found: Error: Can't resolve './components/layouts/SecretaireLayout' in 'D:\teleconsultation-frontend\src'
ERROR in ./src/context/AuthContext.js 30:29-39
export 'default' (imported as 'jwt_decode') was not found in 'jwt-decode' (possible exports: InvalidTokenError, jwtDecode)
ERROR in ./src/context/AuthContext.js 75:29-37
export 'register' (imported as 'register') was not found in '../services/authService' (possible exports: login, logout, registerMedecin, registerPatient, registerSecretaire)

Modifier
Il semble que nous ayons quelques erreurs à résoudre avant de pouvoir démarrer correctement l'application frontend. Les erreurs sont de deux types :

Fichiers manquants : Certains composants de layout que nous utilisons dans App.js ne sont pas encore créés.
Erreurs d'importation : Il y a des problèmes avec les importations de jwt-decode et register.
Résolvons ces problèmes un par un :

1. Création des fichiers de layout manquants
Nous devons créer les layouts pour les différents types d'utilisateurs :

src/components/layouts/MedecinLayout.jsx
jsx
import React from 'react';
import { Routes, Route } from 'react-router-dom';
import { Box, CssBaseline } from '@mui/material';
import NotFound from '../../pages/NotFound';

// Placeholder pour les futures pages
const MedecinDashboard = () => <div>Tableau de bord médecin</div>;

const MedecinLayout = () => {
    return (
        <Box sx={{ display: 'flex' }}>
            <CssBaseline />
            {/* Ici nous ajouterons l'en-tête et la barre latérale du médecin dans le futur */}
            <Box
                component="main"
                sx={{
                    flexGrow: 1,
                    height: '100vh',
                    overflow: 'auto',
                    padding: (theme) => theme.spacing(3),
                    paddingTop: '64px', // Hauteur de l'en-tête
                }}
            >
                <Routes>
                    <Route path="dashboard" element={<MedecinDashboard />} />
                    <Route path="*" element={<NotFound />} />
                </Routes>
            </Box>
        </Box>
    );
};

export default MedecinLayout;
src/components/layouts/PatientLayout.jsx
jsx
import React from 'react';
import { Routes, Route } from 'react-router-dom';
import { Box, CssBaseline } from '@mui/material';
import NotFound from '../../pages/NotFound';

// Placeholder pour les futures pages
const PatientDashboard = () => <div>Tableau de bord patient</div>;

const PatientLayout = () => {
    return (
        <Box sx={{ display: 'flex' }}>
            <CssBaseline />
            {/* Ici nous ajouterons l'en-tête et la barre latérale du patient dans le futur */}
            <Box
                component="main"
                sx={{
                    flexGrow: 1,
                    height: '100vh',
                    overflow: 'auto',
                    padding: (theme) => theme.spacing(3),
                    paddingTop: '64px', // Hauteur de l'en-tête
                }}
            >
                <Routes>
                    <Route path="dashboard" element={<PatientDashboard />} />
                    <Route path="*" element={<NotFound />} />
                </Routes>
            </Box>
        </Box>
    );
};

export default PatientLayout;
src/components/layouts/SecretaireLayout.jsx
jsx
import React from 'react';
import { Routes, Route } from 'react-router-dom';
import { Box, CssBaseline } from '@mui/material';
import NotFound from '../../pages/NotFound';

// Placeholder pour les futures pages
const SecretaireDashboard = () => <div>Tableau de bord secrétaire</div>;

const SecretaireLayout = () => {
    return (
        <Box sx={{ display: 'flex' }}>
            <CssBaseline />
            {/* Ici nous ajouterons l'en-tête et la barre latérale du secrétaire dans le futur */}
            <Box
                component="main"
                sx={{
                    flexGrow: 1,
                    height: '100vh',
                    overflow: 'auto',
                    padding: (theme) => theme.spacing(3),
                    paddingTop: '64px', // Hauteur de l'en-tête
                }}
            >
                <Routes>
                    <Route path="dashboard" element={<SecretaireDashboard />} />
                    <Route path="*" element={<NotFound />} />
                </Routes>
            </Box>
        </Box>
    );
};

export default SecretaireLayout;
2. Correction des erreurs d'importation
1. Correction pour jwt-decode
Il semble que la bibliothèque jwt-decode a changé son export par défaut. Modifions src/context/AuthContext.js :

jsx
// Remplacer cette ligne
import jwt_decode from 'jwt-decode';

// Par celle-ci
import { jwtDecode } from 'jwt-decode';

// Et remplacer toutes les occurrences de jwt_decode par jwtDecode dans le fichier
// Par exemple :
// const decodedToken = jwt_decode(token);
// devient
// const decodedToken = jwtDecode(token);
2. Correction pour la fonction register
Dans le fichier src/context/AuthContext.js, nous importons une fonction register qui n'existe pas dans notre service d'authentification. Nous avons plutôt des fonctions spécifiques pour chaque type d'utilisateur.

Modifions src/context/AuthContext.js :

jsx
// Remplacer cette ligne
import { login, register, logout } from '../services/authService';

// Par celle-ci
import { login, registerPatient, registerMedecin, registerSecretaire, logout } from '../services/authService';

// Et mettre à jour la fonction handleRegister
const handleRegister = async (userData, role) => {
    try {
        let response;
        
        switch (role) {
            case 'patient':
                response = await registerPatient(userData);
                break;
            case 'medecin':
                response = await registerMedecin(userData);
                break;
            case 'secretaire':
                response = await registerSecretaire(userData);
                break;
            default:
                throw new Error('Type d\'utilisateur non reconnu');
        }
        
        return { success: true, data: response.data };
    } catch (error) {
        return { 
            success: false, 
            message: error.response?.data?.message || 'Erreur lors de l\'inscription' 
        };
    }
};
3. Création de la page NotFound
Il semble que nous utilisions un composant NotFound qui n'est pas encore créé. Créons-le :

src/pages/NotFound.jsx
jsx
import React from 'react';
import { Box, Container, Typography, Button } from '@mui/material';
import { useNavigate } from 'react-router-dom';

const NotFound = () => {
    const navigate = useNavigate();

    return (
        <Container maxWidth="md">
            <Box
                sx={{
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    justifyContent: 'center',
                    minHeight: '80vh',
                    textAlign: 'center',
                }}
            >
                <Typography variant="h1" component="h1" gutterBottom>
                    404
                </Typography>
                <Typography variant="h4" component="h2" gutterBottom>
                    Page non trouvée
                </Typography>
                <Typography variant="body1" paragraph>
                    La page que vous recherchez n'existe pas ou a été déplacée.
                </Typography>
                <Button
                    variant="contained"
                    color="primary"
                    onClick={() => navigate('/')}
                    sx={{ mt: 2 }}
                >
                    Retour à l'accueil
                </Button>
            </Box>
        </Container>
    );
};

export default NotFound;
4. Mise à jour du fichier App.js
Si vous rencontrez une erreur concernant les locales dans App.js, assurez-vous que la version de @mui/x-date-pickers et date-fns est compatible. Voici comment mettre à jour App.js pour qu'il soit compatible avec les versions récentes :

jsx
import React from 'react';
import { Routes, Route, Navigate } from 'react-router-dom';
import { ThemeProvider, createTheme } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { fr } from 'date-fns/locale';
import { frFR } from '@mui/material/locale';

// Pages
import Login from './pages/Login';
import Register from './pages/Register';
import NotFound from './pages/NotFound';

// Layouts
import AdminLayout from './components/layouts/AdminLayout';
import MedecinLayout from './components/layouts/MedecinLayout';
import PatientLayout from './components/layouts/PatientLayout';
import SecretaireLayout from './components/layouts/SecretaireLayout';

// Route Guards
import PrivateRoute from './routes/PrivateRoute';
import RoleRoute from './routes/RoleRoute';

// Context
import { useAuth } from './context/AuthContext';

// Thème personnalisé
const theme = createTheme({
  palette: {
    primary: {
      main: '#2196f3',
    },
    secondary: {
      main: '#f50057',
    },
  },
}, frFR);

function App() {
  const { isAuthenticated, userRole } = useAuth();

  return (
    <ThemeProvider theme={theme}>
      <LocalizationProvider dateAdapter={AdapterDateFns} adapterLocale={fr}>
        <CssBaseline />
        <Routes>
          {/* Public Routes */}
          <Route path="/login" element={!isAuthenticated ? <Login /> : <Navigate to="/redirect" />} />
          <Route path="/register" element={!isAuthenticated ? <Register /> : <Navigate to="/redirect" />} />
          
          {/* Redirect based on role */}
          <Route 
            path="/redirect" 
            element={
              isAuthenticated ? (
                userRole === 'ROLE_ADMIN' ? <Navigate to="/admin/dashboard" /> :
                userRole === 'ROLE_MEDECIN' ? <Navigate to="/medecin/dashboard" /> :
                userRole === 'ROLE_PATIENT' ? <Navigate to="/patient/dashboard" /> :
                userRole === 'ROLE_SECRETAIRE' ? <Navigate to="/secretaire/dashboard" /> :
                <Navigate to="/login" />
              ) : <Navigate to="/login" />
            } 
          />
          
          {/* Protected Routes */}
          <Route path="/admin/*" element={
            <RoleRoute requiredRole="ROLE_ADMIN">
              <AdminLayout />
            </RoleRoute>
          } />
          
          <Route path="/medecin/*" element={
            <RoleRoute requiredRole="ROLE_MEDECIN">
              <MedecinLayout />
            </RoleRoute>
          } />
          
          <Route path="/patient/*" element={
            <RoleRoute requiredRole="ROLE_PATIENT">
              <PatientLayout />
            </RoleRoute>
          } />
          
          <Route path="/secretaire/*" element={
            <RoleRoute requiredRole="ROLE_SECRETAIRE">
              <SecretaireLayout />
            </RoleRoute>
          } />
          
          {/* Redirect root to login or dashboard */}
          <Route path="/" element={<Navigate to={isAuthenticated ? "/redirect" : "/login"} />} />
          
          {/* 404 Not Found */}
          <Route path="*" element={<NotFound />} />
        </Routes>
      </LocalizationProvider>
    </ThemeProvider>
  );
}

export default App;
Une fois ces modifications apportées, l'application frontend devrait démarrer sans erreurs. Vous pourrez alors tester l'inscription et la connexion pour vérifier que tout fonctionne correctement.

Si vous rencontrez d'autres erreurs, n'hésitez pas à me les communiquer pour que je puisse vous aider à les résoudre.




quand j'essaye de m'inscrire j'ai ça : 
Hibernate: select r1_0.id,r1_0.name from roles r1_0 where r1_0.name=?
Hibernate: select u1_0.id from users u1_0 where u1_0.email=? fetch first ? rows only
Hibernate: select r1_0.id,r1_0.name from roles r1_0 where r1_0.name=?
Hibernate: select u1_0.id from users u1_0 where u1_0.email=? fetch first ? rows only
Hibernate: select r1_0.id,r1_0.name from roles r1_0 where r1_0.name=?
Hibernate: select u1_0.id from users u1_0 where u1_0.email=? fetch first ? rows only
Hibernate: select r1_0.id,r1_0.name from roles r1_0 where r1_0.name=?
2025-05-08T00:35:51.811Z  WARN 12140 --- [api] [nio-8080-exec-9] .w.s.m.s.DefaultHandlerExceptionResolver : Resolved [org.springframework.web.HttpRequestMethodNotSupportedException: Request method 'GET' is not supported]
2025-05-08T00:35:51.832Z ERROR 12140 --- [api] [nio-8080-exec-9] c.t.api.security.jwt.AuthEntryPointJwt   : Unauthorized error: Full authentication is required to access this resource

et sur l'interface graphique :
Erreur: Rôle non trouvé.

Modifier
Il semble que nous ayons un problème avec les rôles lors de l'inscription. L'erreur "Rôle non trouvé" indique que le rôle demandé n'existe pas dans la base de données.

Voici comment résoudre ce problème:

1. Assurez-vous que les rôles sont créés dans la base de données
Avant de pouvoir les utiliser, les rôles doivent être présents dans la table roles. Créons une classe pour initialiser ces rôles au démarrage de l'application:

java
package com.teleconsultation.api.config;

import com.teleconsultation.api.models.ERole;
import com.teleconsultation.api.models.Role;
import com.teleconsultation.api.repository.RoleRepository;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RoleInitializer {

    @Bean
    public CommandLineRunner initRoles(RoleRepository roleRepository) {
        return args -> {
            System.out.println("Initialisation des rôles...");
            
            // Créer les rôles s'ils n'existent pas
            createRoleIfNotExists(roleRepository, ERole.ROLE_ADMIN);
            createRoleIfNotExists(roleRepository, ERole.ROLE_MEDECIN);
            createRoleIfNotExists(roleRepository, ERole.ROLE_PATIENT);
            createRoleIfNotExists(roleRepository, ERole.ROLE_SECRETAIRE);
            
            System.out.println("Initialisation des rôles terminée");
        };
    }
    
    private void createRoleIfNotExists(RoleRepository roleRepository, ERole roleName) {
        if (!roleRepository.findByName(roleName).isPresent()) {
            Role role = new Role(roleName);
            roleRepository.save(role);
            System.out.println("Rôle " + roleName + " créé");
        }
    }
}
2. Vérifiez le contrôleur d'inscription
Il est également possible que la méthode HTTP utilisée pour l'inscription ne soit pas correcte. L'erreur "Request method 'GET' is not supported" suggère que vous utilisez une requête GET alors que le contrôleur attend une requête POST.

Assurez-vous que dans votre frontend, vous envoyez bien une requête POST:

javascript
// Dans src/services/authService.js
export const registerPatient = (patientData) => {
    return axios.post(`${API_URL}/auth/register/patient`, patientData);
};
3. Vérifiez les problèmes CORS
Assurez-vous que votre backend est bien configuré pour accepter les requêtes CORS depuis le frontend. Votre configuration CORS devrait ressembler à ceci:

java
@Bean
public CorsConfigurationSource corsConfigurationSource() {
    CorsConfiguration configuration = new CorsConfiguration();
    configuration.setAllowedOrigins(Arrays.asList("http://localhost:3000")); // URL du frontend
    configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
    configuration.setAllowedHeaders(Arrays.asList("Authorization", "Content-Type"));
    configuration.setAllowCredentials(true);
    
    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    source.registerCorsConfiguration("/**", configuration);
    return source;
}
4. Vérifiez l'erreur d'authentification
L'erreur "Unauthorized error: Full authentication is required to access this resource" indique que vous essayez d'accéder à une ressource protégée sans être authentifié. Assurez-vous que les endpoints d'inscription sont configurés comme publics dans votre configuration de sécurité:

java
http
    .cors(cors -> cors.configurationSource(corsConfigurationSource()))
    .csrf(csrf -> csrf.disable())
    .exceptionHandling(exception -> exception.authenticationEntryPoint(unauthorizedHandler))
    .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
    .authorizeHttpRequests(auth -> 
        auth
            .requestMatchers("/api/auth/**").permitAll() // Les endpoints d'authentification sont publics
            .requestMatchers("/api/public/**").permitAll()
            .anyRequest().authenticated()
    );
5. Débuguer le problème de rôle
Pour débuguer le problème spécifique de "Rôle non trouvé", ajoutez des logs supplémentaires dans votre service d'inscription:

java
@Transactional
public Patient registerPatient(PatientRequest patientRequest) {
    // Vérifier si l'email existe déjà
    if (userRepository.existsByEmail(patientRequest.getEmail())) {
        throw new RuntimeException("Erreur: Cet email est déjà utilisé!");
    }
    
    // Créer le nouvel utilisateur patient
    Patient patient = new Patient();
    patient.setNom(patientRequest.getNom());
    patient.setPrenom(patientRequest.getPrenom());
    patient.setEmail(patientRequest.getEmail());
    patient.setMotDePasse(encoder.encode(patientRequest.getMotDePasse()));
    patient.setTelephone(patientRequest.getTelephone());
    patient.setCompteValide(false);
    patient.setActif(true);
    
    // Informations spécifiques au patient
    patient.setNumeroSecuriteSociale(patientRequest.getNumeroSecuriteSociale());
    patient.setDateNaissance(patientRequest.getDateNaissance());
    patient.setAdresse(patientRequest.getAdresse());
    
    // Définir le rôle
    Set<Role> roles = new HashSet<>();
    Optional<Role> optionalRole = roleRepository.findByName(ERole.ROLE_PATIENT);
    
    System.out.println("Recherche du rôle ROLE_PATIENT: " + (optionalRole.isPresent() ? "Trouvé" : "Non trouvé"));
    
    // Vérifier si le rôle existe
    if (!optionalRole.isPresent()) {
        // Création automatique du rôle s'il n'existe pas
        System.out.println("Création automatique du rôle ROLE_PATIENT");
        Role newRole = new Role(ERole.ROLE_PATIENT);
        roleRepository.save(newRole);
        roles.add(newRole);
    } else {
        roles.add(optionalRole.get());
    }
    
    patient.setRoles(roles);
    
    // Enregistrer le patient
    Patient savedPatient = patientRepository.save(patient);
    
    // Envoyer un email de confirmation à l'administrateur
    // Commentez cette ligne si vous n'avez pas configuré le service d'email
    // emailService.envoyerEmailNouvelleInscription(patient);
    
    return savedPatient;
}
Avec ces modifications, l'application devrait:

Initialiser automatiquement les rôles au démarrage
Créer le rôle automatiquement s'il n'existe pas lors de l'inscription
Fournir plus d'informations de débogage pour identifier le problème
Redémarrez votre application backend et essayez à nouveau de vous inscrire. Si le problème persiste, les logs supplémentaires devraient vous aider à mieux comprendre ce qui se passe.




okay ça a marché je veux initialisé aussi un administrateur dans la base de données pour valider les comptes

Modifier
Je comprends que vous voulez initialiser automatiquement un administrateur dans la base de données pour pouvoir valider les comptes des utilisateurs. C'est une bonne idée pour faciliter vos tests.

Créons une classe qui initialisera à la fois les rôles et un administrateur par défaut :

java
package com.teleconsultation.api.config;

import com.teleconsultation.api.models.*;
import com.teleconsultation.api.repository.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.util.HashSet;
import java.util.Set;

@Configuration
public class DataInitializer {

    @Autowired
    private RoleRepository roleRepository;
    
    @Autowired
    private AdminRepository adminRepository;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    @Bean
    public CommandLineRunner initData() {
        return args -> {
            System.out.println("Initialisation des données...");
            
            // Initialisation des rôles
            initRoles();
            
            // Initialisation de l'administrateur
            initAdmin();
            
            System.out.println("Initialisation terminée");
        };
    }
    
    private void initRoles() {
        System.out.println("Initialisation des rôles...");
        
        createRoleIfNotExists(ERole.ROLE_ADMIN);
        createRoleIfNotExists(ERole.ROLE_MEDECIN);
        createRoleIfNotExists(ERole.ROLE_PATIENT);
        createRoleIfNotExists(ERole.ROLE_SECRETAIRE);
        
        System.out.println("Initialisation des rôles terminée");
    }
    
    private void createRoleIfNotExists(ERole roleName) {
        if (!roleRepository.findByName(roleName).isPresent()) {
            Role role = new Role(roleName);
            roleRepository.save(role);
            System.out.println("Rôle " + roleName + " créé");
        } else {
            System.out.println("Rôle " + roleName + " déjà existant");
        }
    }
    
    private void initAdmin() {
        System.out.println("Initialisation de l'administrateur...");
        
        // Vérifier si un administrateur existe déjà
        if (adminRepository.count() == 0) {
            // Créer un nouvel administrateur
            Admin admin = new Admin();
            admin.setNom("Admin");
            admin.setPrenom("System");
            admin.setEmail("admin@teleconsultation.com");
            admin.setMotDePasse(passwordEncoder.encode("admin123")); // Mot de passe à changer en production
            admin.setCompteValide(true);
            admin.setActif(true);
            
            // Attribuer le rôle ADMIN
            Set<Role> roles = new HashSet<>();
            Role adminRole = roleRepository.findByName(ERole.ROLE_ADMIN)
                    .orElseThrow(() -> new RuntimeException("Erreur: Rôle Admin non trouvé."));
            roles.add(adminRole);
            admin.setRoles(roles);
            
            // Sauvegarder l'administrateur
            adminRepository.save(admin);
            
            System.out.println("Administrateur créé avec succès. Email: admin@teleconsultation.com, Mot de passe: admin123");
        } else {
            System.out.println("Un administrateur existe déjà dans la base de données");
        }
    }
}
Quelques points importants à noter sur ce code :

Cette classe remplace RoleInitializer que nous avions proposée précédemment, car elle combine l'initialisation des rôles et de l'administrateur.
Les informations d'identification de l'administrateur par défaut sont :
Email : admin@teleconsultation.com
Mot de passe : admin123
Ces informations sont affichées dans les logs au démarrage pour vous rappeler les identifiants.
Pour des raisons de sécurité, dans un environnement de production, vous devriez changer ce mot de passe ou utiliser des variables d'environnement pour le définir.
La classe vérifie d'abord si un administrateur existe déjà dans la base de données avant d'en créer un nouveau, pour éviter la duplication.
Après avoir ajouté cette classe à votre projet, redémarrez l'application. L'administrateur sera créé automatiquement, et vous pourrez l'utiliser pour vous connecter et valider les comptes des autres utilisateurs.





Hibernate: select u1_0.id,case when u1_1.id is not null then 1 when u1_2.id is not null then 2 when u1_3.id is not null then 3 when u1_4.id is not null then 4 end,u1_0.actif,u1_0.compte_valide,u1_0.date_creation,u1_0.email,u1_0.mot_de_passe,u1_0.nom,u1_0.prenom,u1_0.telephone,u1_2.numero_ordre,u1_2.

pasted

quand j'essaye de me connecter etant administrateur j'ai le message suivant :

Modifier
Je vois qu'il y a une erreur lors de la tentative de connexion. Le message d'erreur indique un problème avec la bibliothèque JAXB (java.lang.ClassNotFoundException: javax.xml.bind.DatatypeConverter). Cette erreur est courante lorsqu'on utilise Java 11 ou supérieur avec une version plus ancienne de la bibliothèque JWT.

Le problème est que la version de la bibliothèque JWT que vous utilisez (jjwt-0.9.1) dépend de JAXB, qui faisait partie du JDK jusqu'à Java 8, mais a été retiré dans Java 9 et versions ultérieures.

Pour résoudre ce problème, vous devez mettre à jour vos dépendances JWT dans votre fichier pom.xml :

Remplacez les dépendances JWT actuelles par celles-ci :
xml
<!-- JWT -->
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-api</artifactId>
    <version>0.11.5</version>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-impl</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-jackson</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>
</dependency>
Ensuite, vous devrez également mettre à jour votre classe JwtUtils pour qu'elle utilise la nouvelle API:
java
package com.teleconsultation.api.security.jwt;

import com.teleconsultation.api.security.services.UserDetailsImpl;
import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;

import java.security.Key;
import java.util.Date;

@Component
public class JwtUtils {
    private static final Logger logger = LoggerFactory.getLogger(JwtUtils.class);

    @Value("${app.jwt.secret}")
    private String jwtSecret;

    @Value("${app.jwt.expiration}")
    private int jwtExpirationMs;

    public String generateJwtToken(Authentication authentication) {
        UserDetailsImpl userPrincipal = (UserDetailsImpl) authentication.getPrincipal();

        // Utiliser Keys.hmacShaKeyFor() pour générer une clé à partir de la chaîne secrète
        byte[] keyBytes = jwtSecret.getBytes();
        Key key = Keys.hmacShaKeyFor(keyBytes);

        return Jwts.builder()
                .setSubject(userPrincipal.getUsername())
                .setIssuedAt(new Date())
                .setExpiration(new Date((new Date()).getTime() + jwtExpirationMs))
                .signWith(key)
                .compact();
    }

    public String getUserNameFromJwtToken(String token) {
        // Utiliser Keys.hmacShaKeyFor() pour générer une clé à partir de la chaîne secrète
        byte[] keyBytes = jwtSecret.getBytes();
        Key key = Keys.hmacShaKeyFor(keyBytes);

        return Jwts.parserBuilder().setSigningKey(key).build()
                .parseClaimsJws(token).getBody().getSubject();
    }

    public boolean validateJwtToken(String authToken) {
        try {
            // Utiliser Keys.hmacShaKeyFor() pour générer une clé à partir de la chaîne secrète
            byte[] keyBytes = jwtSecret.getBytes();
            Key key = Keys.hmacShaKeyFor(keyBytes);

            Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(authToken);
            return true;
        } catch (SignatureException e) {
            logger.error("Invalid JWT signature: {}", e.getMessage());
        } catch (MalformedJwtException e) {
            logger.error("Invalid JWT token: {}", e.getMessage());
        } catch (ExpiredJwtException e) {
            logger.error("JWT token is expired: {}", e.getMessage());
        } catch (UnsupportedJwtException e) {
            logger.error("JWT token is unsupported: {}", e.getMessage());
        } catch (IllegalArgumentException e) {
            logger.error("JWT claims string is empty: {}", e.getMessage());
        }

        return false;
    }
}
Assurez-vous également que votre clé secrète JWT dans application.properties est suffisamment longue (au moins 256 bits, ou 32 caractères):
properties
# Au moins 32 caractères pour une clé HMAC-SHA-256
app.jwt.secret=votreclésecretesuffisammentlonguepourhmacsha256
Après ces modifications, redémarrez votre application et essayez de vous connecter à nouveau en tant qu'administrateur. Cela devrait résoudre l'erreur liée à javax.xml.bind.DatatypeConverter.




2025-05-08T01:15:26.810Z  INFO 15612 --- [api] [nio-8080-exec-3] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2025-05-08T01:15:26.810Z  INFO 15612 --- [api] [nio-8080-exec-3] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2025-05-08T01:15:26.812Z  INFO 15612 --- [api] [nio-8080-exec-3] o.s.web.servlet.DispatcherServlet        : Completed initialization in 1 ms
Hibernate: select u1_0.id,case when u1_1.id is not null then 1 when u1_2.id is not null then 2 when u1_3.id is not null then 3 when u1_4.id is not null then 4 end,u1_0.actif,u1_0.compte_valide,u1_0.date_creation,u1_0.email,u1_0.mot_de_passe,u1_0.nom,u1_0.prenom,u1_0.telephone,u1_2.numero_ordre,u1_2.specialite,u1_3.adresse,u1_3.date_naissance,u1_3.numero_securite_sociale,u1_4.service from users u1_0 left join admins u1_1 on u1_0.id=u1_1.id left join medecins u1_2 on u1_0.id=u1_2.id left join patients u1_3 on u1_0.id=u1_3.id left join secretaires u1_4 on u1_0.id=u1_4.id where u1_0.email=?
Hibernate: select r1_0.user_id,r1_1.id,r1_1.name from user_roles r1_0 join roles r1_1 on r1_1.id=r1_0.role_id where r1_0.user_id=?

j'ai maintenant ça

Modifier
Il semble que votre application fonctionne désormais et que vous avez résolu le problème lié à la bibliothèque JWT. Les logs montrent que l'application interroge correctement la base de données pour trouver l'utilisateur et ses rôles lors de la tentative de connexion.

Cependant, je ne vois pas dans les logs si la connexion a réussi ou non. Si vous avez pu vous connecter en tant qu'administrateur, c'est parfait ! Sinon, voici quelques points à vérifier :

Vérifiez que l'administrateur existe réellement dans la base de données
Si vous n'êtes pas sûr, vous pouvez ajouter quelques logs dans votre DataInitializer pour confirmer que l'administrateur a bien été créé.
Assurez-vous d'utiliser les bons identifiants
Email : admin@teleconsultation.com
Mot de passe : admin123
Vérifiez la connexion côté frontend
Assurez-vous que votre service d'authentification dans le frontend fait correctement les requêtes vers le backend.
Vérifiez dans la console du navigateur s'il y a des erreurs.
Test avec Postman ou Insomnia
Pour isoler le problème, essayez de vous connecter directement via Postman ou Insomnia avec une requête POST :
URL : http://localhost:8080/api/auth/login
Headers : Content-Type: application/json
Body :
json
{
    "email": "admin@teleconsultation.com",
    "password": "admin123"
}



voici la reponse sur postman :
{
    "id": 2,
    "email": "admin@teleconsultation.com",
    "nom": "Admin",
    "prenom": "System",
    "roles": [
        "ROLE_ADMIN"
    ],
    "token": "eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbkB0ZWxlY29uc3VsdGF0aW9uLmNvbSIsImlhdCI6MTc0NjY2ODA0MCwiZXhwIjoxNzQ2NzU0NDQwfQ.zEvZkgrINcjT08IIPKCLJ6WuKZp8FR7NV3BZESThQJ5hjpjDsQzMsU-82GjQHUW6Xhg_37-qBX_0ztorOlyGGA",
    "type": "Bearer"
}

mais sur l'interface graphique ça me dit erreur lors de la connexion

Modifier
Il semble que l'authentification fonctionne correctement côté backend puisque Postman reçoit une réponse valide avec un token JWT. Le problème se situe donc probablement dans l'interface frontend.

Voici quelques pistes à vérifier pour résoudre le problème d'interface graphique:

1. Vérifiez le format des données envoyées depuis le frontend
Dans votre fichier src/services/authService.js, assurez-vous que la fonction login envoie les bonnes clés:

javascript
// Assurez-vous que les noms des champs correspondent à ce que le backend attend
export const login = (email, password) => {
    return axios.post(`${API_URL}/auth/login`, { email, password });
};
Le backend attend probablement email et password comme noms de paramètres (comme vu dans la requête Postman).

2. Vérifiez la gestion des erreurs dans le composant Login
Dans votre composant Login, assurez-vous que vous gérez correctement la réponse et les erreurs:

jsx
const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    setLoading(true);

    try {
        // Appel au service d'authentification
        const response = await login(formData.email, formData.password);
        
        // Si la connexion réussit, stockez le token
        const { token, id, email, nom, prenom, roles } = response.data;
        localStorage.setItem('token', token);
        
        // Mettre à jour le contexte d'authentification
        setCurrentUser({ id, email, nom, prenom, roles });
        setUserRole(roles[0]);
        setIsAuthenticated(true);
        
        // Rediriger vers le tableau de bord approprié
        navigate('/redirect');
    } catch (error) {
        console.error('Erreur lors de la connexion:', error);
        setError('Email ou mot de passe incorrect');
    } finally {
        setLoading(false);
    }
};
3. Vérifiez la console du navigateur
Ouvrez les outils de développement de votre navigateur (F12) et regardez la console pour voir s'il y a des erreurs JavaScript qui pourraient indiquer le problème spécifique.

4. Vérifiez le flux d'authentification dans le contexte
Dans votre fichier src/context/AuthContext.js, assurez-vous que la fonction handleLogin gère correctement la réponse:

javascript
const handleLogin = async (email, password) => {
    try {
        const response = await login(email, password);
        const { token, id, email: userEmail, nom, prenom, roles } = response.data;
        
        // Stocker le token et les infos utilisateur
        localStorage.setItem('token', token);
        setCurrentUser({ id, email: userEmail, nom, prenom, roles });
        setUserRole(roles[0]);
        setIsAuthenticated(true);
        
        console.log("Login successful, token:", token); // Pour débogage
        
        return { success: true };
    } catch (error) {
        console.error("Login error:", error.response?.data || error); // Pour débogage
        return { 
            success: false, 
            message: error.response?.data?.message || 'Erreur lors de la connexion' 
        };
    }
};
5. Vérifiez que les clés dans la réponse correspondent à ce que votre frontend attend
La réponse de Postman montre:

json
{
    "id": 2,
    "email": "admin@teleconsultation.com",
    "nom": "Admin",
    "prenom": "System",
    "roles": ["ROLE_ADMIN"],
    "token": "eyJhbGciOiJIUzUxMiJ9...",
    "type": "Bearer"
}
Assurez-vous que votre frontend s'attend à ce format, notamment pour l'utilisation de token et non accessToken ou autre nom.

Solution proposée
Modifiez le fichier src/pages/Login.jsx pour mieux gérer la réponse et afficher les erreurs de manière plus détaillée:

jsx
const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    setLoading(true);

    try {
        // Déboguer les données envoyées
        console.log("Sending login request with:", formData);
        
        // Appel au service d'authentification
        const result = await login(formData.email, formData.password);
        
        console.log("Login response:", result);
        
        if (result.success) {
            navigate('/redirect');
        } else {
            setError(result.message || 'Échec de la connexion');
        }
    } catch (error) {
        console.error('Erreur inattendue lors de la connexion:', error);
        setError('Une erreur inattendue est survenue. Veuillez réessayer.');
    } finally {
        setLoading(false);
    }
};
Et mettez à jour src/context/AuthContext.js pour mieux déboguer le problème:

javascript
const handleLogin = async (email, password) => {
    try {
        console.log("AuthContext: Attempting login with", { email });
        const response = await login(email, password);
        console.log("AuthContext: Raw response:", response);
        
        const { token, id, email: userEmail, nom, prenom, roles } = response.data;
        
        // Stocker le token et les infos utilisateur
        localStorage.setItem('token', token);
        setCurrentUser({ id, email: userEmail, nom, prenom, roles });
        setUserRole(roles[0]);
        setIsAuthenticated(true);
        
        console.log("AuthContext: Login successful, user role:", roles[0]);
        
        return { success: true, user: { id, email: userEmail, nom, prenom, roles } };
    } catch (error) {
        console.error("AuthContext: Login error:", error);
        console.error("Error details:", error.response?.data);
        return { 
            success: false, 
            message: error.response?.data?.message || 'Erreur lors de la connexion' 
        };
    }
};
Avec ces modifications, vous devriez obtenir plus d'informations de débogage dans la console du navigateur, ce qui vous aidera à identifier la cause exacte du problème.




voici mon script actuel dans le fichier Login.jsx :
const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');
        setLoading(true);

        try {
            const result = await login(formData.email, formData.password);

            if (result.success) {
                navigate('/redirect');
            } else {
                setError(result.message);
            }
        } catch (error) {
            setError('Une erreur est survenue lors de la connexion.');
            console.error('Erreur de connexion:', error);
        } finally {
            setLoading(false);
        }
    }

Modifier
Je vois le script actuel de votre Login.jsx. Le problème pourrait être lié à la façon dont la fonction login du contexte d'authentification gère la réponse et la transmet au composant de connexion.

Essayons de modifier votre fichier src/services/authService.js pour voir si c'est la source du problème:

javascript
// src/services/authService.js
import axios from 'axios';
import { API_URL } from '../config';

// Configuration de l'intercepteur pour ajouter le token JWT aux requêtes
axios.interceptors.request.use(config => {
    const token = localStorage.getItem('token');
    
    if (token) {
        config.headers.Authorization = `Bearer ${token}`;
    }
    
    return config;
}, error => {
    return Promise.reject(error);
});

// Connexion
export const login = async (email, password) => {
    try {
        console.log("Tentative de connexion avec:", { email });
        const response = await axios.post(`${API_URL}/auth/login`, { email, password });
        console.log("Réponse de connexion:", response.data);
        
        // Stocker le token
        localStorage.setItem('token', response.data.token);
        
        return { success: true, user: response.data };
    } catch (error) {
        console.error("Erreur de connexion:", error.response?.data || error);
        return { 
            success: false, 
            message: error.response?.data?.message || 'Email ou mot de passe incorrect' 
        };
    }
};

// Autres fonctions...
Le problème pourrait venir du fait que la fonction login du service d'authentification renvoie toujours un objet avec success: true/false, mais votre contexte d'authentification pourrait attendre la réponse brute d'axios.

Vérifiez également votre fonction handleLogin dans AuthContext.js. Assurez-vous qu'elle est compatible avec ce que retourne votre service authService.js:

javascript
// src/context/AuthContext.js (partie concernant la fonction handleLogin)
const handleLogin = async (email, password) => {
    try {
        // Appeler le service d'authentification
        const result = await login(email, password);
        
        // Si la connexion réussit, mettre à jour le contexte
        if (result.success) {
            const userData = result.user;
            setCurrentUser(userData);
            setUserRole(userData.roles[0]);
            setIsAuthenticated(true);
            
            return { success: true, user: userData };
        } else {
            return { success: false, message: result.message };
        }
    } catch (error) {
        console.error("Erreur dans handleLogin:", error);
        return { 
            success: false, 
            message: 'Une erreur inattendue est survenue' 
        };
    }
};
Pour déboguer davantage le problème, modifiez votre composant Login.jsx pour afficher plus d'informations:

jsx
const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    setLoading(true);

    try {
        console.log("Tentative de connexion avec:", formData);
        const result = await login(formData.email, formData.password);
        console.log("Résultat de la connexion:", result);
        
        if (result.success) {
            console.log("Connexion réussie, redirection...");
            navigate('/redirect');
        } else {
            console.log("Échec de la connexion:", result.message);
            setError(result.message || "Erreur de connexion");
        }
    } catch (error) {
        console.error("Exception lors de la connexion:", error);
        setError('Une erreur est survenue lors de la connexion.');
    } finally {
        setLoading(false);
    }
}
Ces modifications vous aideront à identifier où exactement le processus d'authentification échoue. Vérifiez la console du navigateur après avoir tenté de vous connecter pour voir les messages de débogage.

Aussi, assurez-vous que votre configuration API_URL dans src/config.js pointe vers la bonne URL de votre API backend (par exemple, http://localhost:8080/api).





import React, { useState } from 'react'; import { Container, Paper, Typography, TextField, Button, Grid, Link, Alert, FormControl, InputLabel, Select, MenuItem, Box } from '@mui/material'; import { useNavigate } from 'react-router-d

pasted

voici les composants et renvoie moi les scripts pour déboguer : 

import React, { createContext, useState, useContext, useEffect } from 'react';
import { jwtDecode } from 'jwt-decode';
import { login, registerPatient, registerMedecin, registerSecretaire, logout } from '../services/AuthService';

const AuthContext = createContext();

export function useAuth() {
  return useContext(AuthContext);
}

export function AuthProvider({ children }) {
  const [currentUser, setCurrentUser] = useState(null);
  const [userRole, setUserRole] = useState(null);
  const [loading, setLoading] = useState(true);
  const [isAuthenticated, setIsAuthenticated] = useState(false);

  useEffect(() => {
    // Vérifier si un token existe déjà
    const token = localStorage.getItem('token');

    if (token) {
      try {
        // Vérifier si le token est valide
        const decodedToken = jwtDecode(token);
        const currentTime = Date.now() / 1000;

        if (decodedToken.exp > currentTime) {
          // Token valide, récupérer les informations de l'utilisateur
          setCurrentUser(decodedToken.user);
          setUserRole(decodedToken.roles[0]); // Supposons que nous prenons le premier rôle
          setIsAuthenticated(true);
        } else {
          // Token expiré, nettoyer
          handleLogout();
        }
      } catch (error) {
        // Erreur de décodage, nettoyer
        handleLogout();
      }
    }

    setLoading(false);
  }, []);

  const handleLogin = async (email, password) => {
    try {
      const response = await login(email, password);
      const { token, user } = response.data;

      // Stocker le token et les infos utilisateur
      localStorage.setItem('token', token);
      setCurrentUser(user);
      setUserRole(user.roles[0].name); // Supposons que nous prenons le premier rôle
      setIsAuthenticated(true);

      return { success: true, user };
    } catch (error) {
      return { 
        success: false, 
        message: error.response?.data?.message || 'Erreur lors de la connexion' 
      };
    }
  };

 // Et mettre à jour la fonction handleRegister
const handleRegister = async (userData, role) => {
  try {
      let response;

      switch (role) {
          case 'patient':
              response = await registerPatient(userData);
              break;
          case 'medecin':
              response = await registerMedecin(userData);
              break;
          case 'secretaire':
              response = await registerSecretaire(userData);
              break;
          default:
              throw new Error('Type d\'utilisateur non reconnu');
      }

      return { success: true, data: response.data };
  } catch (error) {
      return { 
          success: false, 
          message: error.response?.data?.message || 'Erreur lors de l\'inscription' 
      };
  }
};

  const handleLogout = () => {
    // Nettoyer les données de session
    localStorage.removeItem('token');
    setCurrentUser(null);
    setUserRole(null);
    setIsAuthenticated(false);

    // Appel au service de déconnexion
    logout();
  };

  const value = {
    currentUser,
    userRole,
    isAuthenticated,
    login: handleLogin,
    register: handleRegister,
    logout: handleLogout
  };

  return (
    <AuthContext.Provider value={value}>
      {!loading && children}
    </AuthContext.Provider>
  );
}

Modifier
Je vois votre code d'authentification. Pour déboguer le problème de connexion, je vais vous proposer des modifications dans vos fichiers pour ajouter des logs détaillés qui nous aideront à comprendre ce qui ne fonctionne pas.

1. Modification du Login.jsx
jsx
import React, { useState } from 'react';
import {
    Container,
    Paper,
    Typography,
    TextField,
    Button,
    Grid,
    Link,
    Alert,
    Box
} from '@mui/material';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

const Login = () => {
    const [formData, setFormData] = useState({
        email: '',
        password: ''
    });
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);

    const { login } = useAuth();
    const navigate = useNavigate();

    const handleChange = (e) => {
        const { name, value } = e.target;
        setFormData(prevState => ({
            ...prevState,
            [name]: value
        }));
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');
        setLoading(true);

        try {
            console.log("Login.jsx: Tentative de connexion avec:", { email: formData.email });
            
            const result = await login(formData.email, formData.password);
            console.log("Login.jsx: Résultat de la connexion:", result);
            
            if (result.success) {
                console.log("Login.jsx: Connexion réussie, redirection...");
                navigate('/redirect');
            } else {
                console.log("Login.jsx: Échec de la connexion:", result.message);
                setError(result.message || "Une erreur s'est produite lors de la connexion");
            }
        } catch (error) {
            console.error('Login.jsx: Exception lors de la connexion:', error);
            setError('Une erreur est survenue lors de la connexion.');
        } finally {
            setLoading(false);
        }
    };

    return (
        <Container component="main" maxWidth="xs">
            <Box
                sx={{
                    marginTop: 8,
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                }}
            >
                <Paper elevation={3} sx={{ padding: 3, width: '100%' }}>
                    <Typography component="h1" variant="h5" align="center" gutterBottom>
                        Connexion
                    </Typography>

                    {error && (
                        <Alert severity="error" sx={{ mb: 2 }}>
                            {error}
                        </Alert>
                    )}

                    <form onSubmit={handleSubmit}>
                        <TextField
                            variant="outlined"
                            margin="normal"
                            required
                            fullWidth
                            id="email"
                            label="Adresse email"
                            name="email"
                            autoComplete="email"
                            autoFocus
                            value={formData.email}
                            onChange={handleChange}
                        />

                        <TextField
                            variant="outlined"
                            margin="normal"
                            required
                            fullWidth
                            name="password"
                            label="Mot de passe"
                            type="password"
                            id="password"
                            autoComplete="current-password"
                            value={formData.password}
                            onChange={handleChange}
                        />

                        <Button
                            type="submit"
                            fullWidth
                            variant="contained"
                            color="primary"
                            sx={{ mt: 3, mb: 2 }}
                            disabled={loading}
                        >
                            {loading ? 'Connexion en cours...' : 'Se connecter'}
                        </Button>

                        <Grid container justifyContent="center">
                            <Grid item>
                                <Link href="/register" variant="body2">
                                    {"Vous n'avez pas de compte ? Inscrivez-vous"}
                                </Link>
                            </Grid>
                        </Grid>
                    </form>
                </Paper>
            </Box>
        </Container>
    );
};

export default Login;
2. Modification du AuthContext.js
jsx
import React, { createContext, useState, useContext, useEffect } from 'react';
import { jwtDecode } from 'jwt-decode';
import { login, registerPatient, registerMedecin, registerSecretaire, logout } from '../services/AuthService';

const AuthContext = createContext();

export function useAuth() {
  return useContext(AuthContext);
}

export function AuthProvider({ children }) {
  const [currentUser, setCurrentUser] = useState(null);
  const [userRole, setUserRole] = useState(null);
  const [loading, setLoading] = useState(true);
  const [isAuthenticated, setIsAuthenticated] = useState(false);

  useEffect(() => {
    // Vérifier si un token existe déjà
    const token = localStorage.getItem('token');
    console.log("AuthContext: Token au chargement:", token ? "Présent" : "Absent");
    
    if (token) {
      try {
        // Vérifier si le token est valide
        const decodedToken = jwtDecode(token);
        console.log("AuthContext: Token décodé:", decodedToken);
        
        const currentTime = Date.now() / 1000;
        
        if (decodedToken.exp > currentTime) {
          // Token valide, récupérer les informations de l'utilisateur
          console.log("AuthContext: Token valide, expiration:", new Date(decodedToken.exp * 1000).toLocaleString());
          setCurrentUser(decodedToken.user);
          setUserRole(decodedToken.roles?.[0]); // Supposons que nous prenons le premier rôle
          setIsAuthenticated(true);
        } else {
          // Token expiré, nettoyer
          console.log("AuthContext: Token expiré");
          handleLogout();
        }
      } catch (error) {
        // Erreur de décodage, nettoyer
        console.error("AuthContext: Erreur de décodage du token:", error);
        handleLogout();
      }
    }
    
    setLoading(false);
  }, []);

  const handleLogin = async (email, password) => {
    try {
      console.log("AuthContext: Tentative de connexion avec:", { email });
      
      const response = await login(email, password);
      console.log("AuthContext: Réponse brute de l'API:", response);
      
      // L'ajustement clé: vérifier la structure de la réponse
      if (response && response.data) {
        const { token, id, email: userEmail, nom, prenom, roles } = response.data;
        console.log("AuthContext: Données extraites:", { token: !!token, id, userEmail, nom, prenom, roles });
        
        if (!token) {
          console.error("AuthContext: Token manquant dans la réponse");
          return { success: false, message: "Erreur d'authentification: token manquant" };
        }
        
        // Stocker le token et décoder pour obtenir les informations utilisateur
        localStorage.setItem('token', token);
        
        try {
          const decodedToken = jwtDecode(token);
          console.log("AuthContext: Token décodé après connexion:", decodedToken);
        } catch (e) {
          console.error("AuthContext: Erreur lors du décodage du token:", e);
        }
        
        // Mettre à jour l'état avec les informations de l'utilisateur
        const userData = { id, email: userEmail, nom, prenom, roles };
        setCurrentUser(userData);
        setUserRole(Array.isArray(roles) ? roles[0] : roles);
        setIsAuthenticated(true);
        
        console.log("AuthContext: Utilisateur connecté:", userData);
        console.log("AuthContext: Rôle défini:", Array.isArray(roles) ? roles[0] : roles);
        
        return { success: true, user: userData };
      } else {
        console.error("AuthContext: Structure de réponse inattendue:", response);
        return { success: false, message: "Format de réponse incorrect" };
      }
    } catch (error) {
      console.error("AuthContext: Erreur lors de la connexion:", error);
      console.error("AuthContext: Détails de l'erreur:", {
        message: error.message,
        response: error.response?.data,
        status: error.response?.status
      });
      
      return { 
        success: false, 
        message: error.response?.data?.message || 'Erreur lors de la connexion' 
      };
    }
  };

  // Et mettre à jour la fonction handleRegister
  const handleRegister = async (userData, role) => {
    try {
      console.log("AuthContext: Tentative d'inscription comme", role, "avec", userData.email);
      
      let response;
      
      switch (role) {
        case 'patient':
          response = await registerPatient(userData);
          break;
        case 'medecin':
          response = await registerMedecin(userData);
          break;
        case 'secretaire':
          response = await registerSecretaire(userData);
          break;
        default:
          throw new Error('Type d\'utilisateur non reconnu');
      }
      
      console.log("AuthContext: Inscription réussie:", response.data);
      return { success: true, data: response.data };
    } catch (error) {
      console.error("AuthContext: Erreur lors de l'inscription:", error);
      return { 
        success: false, 
        message: error.response?.data?.message || 'Erreur lors de l\'inscription' 
      };
    }
  };

  const handleLogout = () => {
    console.log("AuthContext: Déconnexion utilisateur");
    // Nettoyer les données de session
    localStorage.removeItem('token');
    setCurrentUser(null);
    setUserRole(null);
    setIsAuthenticated(false);
    
    // Appel au service de déconnexion
    logout();
  };

  const value = {
    currentUser,
    userRole,
    isAuthenticated,
    login: handleLogin,
    register: handleRegister,
    logout: handleLogout
  };

  return (
    <AuthContext.Provider value={value}>
      {!loading && children}
    </AuthContext.Provider>
  );
}
3. Vérification du AuthService.js
Il semble que vous avez un fichier AuthService.js. Assurez-vous qu'il est correctement configuré pour gérer les requêtes d'authentification. Voici comment il devrait être structuré:

jsx
import axios from 'axios';
import { API_URL } from '../config';

// Configuration de l'intercepteur pour ajouter le token JWT aux requêtes
axios.interceptors.request.use(config => {
    const token = localStorage.getItem('token');
    
    if (token) {
        config.headers.Authorization = `Bearer ${token}`;
    }
    
    return config;
}, error => {
    return Promise.reject(error);
});

// Connexion
export const login = async (email, password) => {
    try {
        console.log("AuthService: Tentative de connexion avec:", { email });
        const response = await axios.post(`${API_URL}/auth/login`, { email, password });
        console.log("AuthService: Réponse brute de l'API:", response);
        return response;
    } catch (error) {
        console.error("AuthService: Erreur de connexion:", error);
        throw error;
    }
};

// Inscription patient
export const registerPatient = (patientData) => {
    console.log("AuthService: Inscription patient:", patientData.email);
    return axios.post(`${API_URL}/auth/register/patient`, patientData);
};

// Inscription médecin
export const registerMedecin = (medecinData) => {
    console.log("AuthService: Inscription médecin:", medecinData.email);
    return axios.post(`${API_URL}/auth/register/medecin`, medecinData);
};

// Inscription secrétaire
export const registerSecretaire = (secretaireData) => {
    console.log("AuthService: Inscription secrétaire:", secretaireData.email);
    return axios.post(`${API_URL}/auth/register/secretaire`, secretaireData);
};

// Déconnexion
export const logout = () => {
    console.log("AuthService: Déconnexion");
    localStorage.removeItem('token');
    return true;
};
4. Vérification du config.js
Assurez-vous que votre fichier config.js est correctement configuré avec l'URL de votre API backend:

jsx
// src/config.js
export const API_URL = 'http://localhost:8080/api';
Avec ces modifications, vous aurez beaucoup plus d'informations de débogage dans la console du navigateur, ce qui vous aidera à identifier précisément où se trouve le problème. Les logs suivent le flux complet d'authentification, depuis la tentative de connexion jusqu'à la gestion de la réponse de l'API.

Après avoir appliqué ces changements, essayez de vous connecter à nouveau et examinez attentivement les logs dans la console du navigateur pour voir ce qui se passe exactement.




AuthContext.js:20 AuthContext: Token au chargement: Présent
AuthContext.js:26 AuthContext: Token décodé: Objectexp: 1746754279iat: 1746667879sub: "admin@teleconsultation.com"[[Prototype]]: Objectconstructor: ƒ Object()hasOwnProperty: ƒ hasOwnProperty()isPrototypeOf: ƒ isPrototypeOf()propertyIsEnumerable: ƒ propertyIsEnumerable()toLocaleString: ƒ toLocaleString()toString: ƒ toString()valueOf: ƒ valueOf()defineGetter: ƒ defineGetter()defineSetter: ƒ defineSetter()lookupGetter: ƒ lookupGetter()lookupSetter: ƒ lookupSetter()proto: (…)get proto: ƒ proto()set proto: ƒ proto()
AuthContext.js:32 AuthContext: Token valide, expiration: 09/05/2025 01:31:19
hook.js:377 AuthContext: Token au chargement: Présent
hook.js:377 AuthContext: Token décodé: Objectexp: 1746754279iat: 1746667879sub: "admin@teleconsultation.com"[[Prototype]]: Object
hook.js:377 AuthContext: Token valide, expiration: 09/05/2025 01:31:19
hook.js:608 Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.
overrideMethod @ hook.js:608
hook.js:608 Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.
overrideMethod @ hook.js:608
hook.js:608 Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.
overrideMethod @ hook.js:608
chunk-AYJ5UCUI.mjs:286 Throttling navigation to prevent the browser from hanging. See https://crbug.com/1038223. Command line switch --disable-ipc-flooding-protection can be used to bypass the protection
push @ chunk-AYJ5UCUI.mjs:286

Modifier
Je vois que vous rencontrez une boucle infinie d'actualisations dans votre application React. Ce problème est indiqué par l'erreur "Maximum update depth exceeded", qui se produit généralement lorsqu'un composant appelle setState à l'intérieur d'un useEffect sans dépendances appropriées, créant ainsi une boucle infinie de mises à jour.

Voici comment résoudre ce problème:

Correction du hook useEffect dans AuthContext.js
Le problème principal semble venir de votre hook useEffect dans AuthContext.js. Voici une version corrigée:

jsx
useEffect(() => {
  // Vérifier si un token existe déjà
  const token = localStorage.getItem('token');
  console.log("AuthContext: Token au chargement:", token ? "Présent" : "Absent");
  
  if (token) {
    try {
      // Vérifier si le token est valide
      const decodedToken = jwtDecode(token);
      console.log("AuthContext: Token décodé:", decodedToken);
      
      const currentTime = Date.now() / 1000;
      
      if (decodedToken.exp > currentTime) {
        // Token valide, récupérer les informations de l'utilisateur
        console.log("AuthContext: Token valide, expiration:", new Date(decodedToken.exp * 1000).toLocaleString());
        
        // Le problème est probablement ici, car decodedToken.user peut être undefined
        // et vous essayez d'y accéder, ce qui crée une boucle infinie de mises à jour
        
        // Au lieu de decodedToken.user, utilisez les infos du token
        const userData = {
          email: decodedToken.sub,
          // Autres propriétés si disponibles
        };
        
        setCurrentUser(userData);
        
        // Vérifiez si decodedToken.roles existe avant d'y accéder
        // Si roles n'existe pas dans le token, ne mettez pas à jour userRole
        if (decodedToken.roles && decodedToken.roles.length > 0) {
          setUserRole(decodedToken.roles[0]);
        }
        
        setIsAuthenticated(true);
      } else {
        // Token expiré, nettoyer
        console.log("AuthContext: Token expiré");
        handleLogout();
      }
    } catch (error) {
      // Erreur de décodage, nettoyer
      console.error("AuthContext: Erreur de décodage du token:", error);
      handleLogout();
    }
  }
  
  setLoading(false);
  // Pas besoin d'ajouter de dépendances ici car ce useEffect ne doit s'exécuter qu'une fois au chargement
}, []);
Définition explicite de la fonction handleLogout en dehors du useEffect
Ajoutez cette ligne avant le useEffect pour éviter les problèmes de dépendance circulaire:

jsx
// Définition de handleLogout en dehors de useEffect pour éviter les dépendances circulaires
const handleLogout = () => {
  console.log("AuthContext: Déconnexion utilisateur");
  // Nettoyer les données de session
  localStorage.removeItem('token');
  setCurrentUser(null);
  setUserRole(null);
  setIsAuthenticated(false);
};
Vérification du format du token JWT
D'après vos logs, le token JWT décodé ne contient que exp, iat et sub, mais pas les informations utilisateur comme user ou roles. C'est probablement la source du problème. Votre backend doit inclure ces informations dans le payload du token.

Voici comment vous pouvez modifier votre fonction handleLogin pour s'adapter à ce format de token:

jsx
const handleLogin = async (email, password) => {
  try {
    console.log("AuthContext: Tentative de connexion avec:", { email });
    
    const response = await login(email, password);
    console.log("AuthContext: Réponse brute de l'API:", response);
    
    if (response && response.data) {
      const { token, id, email: userEmail, nom, prenom, roles } = response.data;
      console.log("AuthContext: Données extraites:", { token: !!token, id, userEmail, nom, prenom, roles });
      
      if (!token) {
        console.error("AuthContext: Token manquant dans la réponse");
        return { success: false, message: "Erreur d'authentification: token manquant" };
      }
      
      // Stocker le token
      localStorage.setItem('token', token);
      
      // Créer l'objet utilisateur à partir des données de la réponse, pas du token
      const userData = { id, email: userEmail, nom, prenom, roles };
      setCurrentUser(userData);
      
      // Gérer le format de roles qui peut être un tableau ou une chaîne
      const roleValue = Array.isArray(roles) ? roles[0] : roles;
      setUserRole(roleValue);
      
      setIsAuthenticated(true);
      
      console.log("AuthContext: Utilisateur connecté:", userData);
      console.log("AuthContext: Rôle défini:", roleValue);
      
      return { success: true, user: userData };
    } else {
      console.error("AuthContext: Structure de réponse inattendue:", response);
      return { success: false, message: "Format de réponse incorrect" };
    }
  } catch (error) {
    console.error("AuthContext: Erreur lors de la connexion:", error);
    return { 
      success: false, 
      message: error.response?.data?.message || 'Erreur lors de la connexion' 
    };
  }
};
Ces modifications devraient résoudre le problème de boucle infinie en adaptant votre code au format réel du token JWT généré par votre backend. Le problème principal était probablement que vous essayiez d'accéder à decodedToken.user et decodedToken.roles qui n'existent pas dans votre token.

Une fois ces changements effectués, votre application devrait fonctionner correctement sans générer de boucles infinies d'actualisations.




j'ai pas bien compris les modifications à faire

Modifier
Je comprends que mes explications étaient un peu complexes. Laissez-moi simplifier et vous fournir exactement ce que vous devez modifier dans votre code.

Problème principal
Le problème est que votre application entre dans une boucle infinie de mises à jour, probablement parce que votre code essaie d'accéder à des propriétés qui n'existent pas dans votre token JWT (comme user et roles).

Modifications à faire
1. Remplacez entièrement votre fonction useEffect dans AuthContext.js par celle-ci:
jsx
useEffect(() => {
  // Vérifier si un token existe déjà
  const token = localStorage.getItem('token');
  
  if (token) {
    try {
      // Vérifier si le token est valide
      const decodedToken = jwtDecode(token);
      const currentTime = Date.now() / 1000;
      
      if (decodedToken.exp > currentTime) {
        // Token valide
        setIsAuthenticated(true);
        
        // Récupérer les informations de l'utilisateur depuis les claims du token
        // Notez: votre token ne contient que 'sub', pas 'user' ni 'roles'
        // Il faut donc adapter notre code
        setCurrentUser({
          email: decodedToken.sub // Utiliser le 'sub' comme email
        });
        
        // Ne pas essayer de définir le rôle à partir du token
        // Le rôle sera défini lors de la connexion
      } else {
        // Token expiré, nettoyer
        localStorage.removeItem('token');
        setCurrentUser(null);
        setUserRole(null);
        setIsAuthenticated(false);
      }
    } catch (error) {
      // Erreur de décodage, nettoyer
      localStorage.removeItem('token');
      setCurrentUser(null);
      setUserRole(null);
      setIsAuthenticated(false);
    }
  }
  
  setLoading(false);
}, []); // Aucune dépendance pour éviter les boucles infinies
2. Remplacez votre fonction handleLogin par celle-ci:
jsx
const handleLogin = async (email, password) => {
  try {
    const response = await login(email, password);
    
    if (response && response.data) {
      const { token, id, email: userEmail, nom, prenom, roles } = response.data;
      
      // Stocker le token
      localStorage.setItem('token', token);
      
      // Définir l'utilisateur avec les données de la réponse API (pas du token)
      const userData = { id, email: userEmail, nom, prenom, roles };
      setCurrentUser(userData);
      
      // Définir le rôle
      if (Array.isArray(roles)) {
        setUserRole(roles[0]); // Premier rôle s'il s'agit d'un tableau
      } else {
        setUserRole(roles); // Le rôle directement s'il s'agit d'une chaîne
      }
      
      setIsAuthenticated(true);
      
      return { success: true, user: userData };
    } else {
      return { success: false, message: "Format de réponse incorrect" };
    }
  } catch (error) {
    return { 
      success: false, 
      message: error.response?.data?.message || 'Erreur lors de la connexion' 
    };
  }
};
3. Assurez-vous que votre fonction login dans AuthService.js est correcte:
jsx
// Connexion
export const login = (email, password) => {
  return axios.post(`${API_URL}/auth/login`, { email, password });
};
4. Assurez-vous que votre API_URL est correcte dans config.js:
jsx
export const API_URL = 'http://localhost:8080/api';
Ces modifications devraient résoudre votre problème de boucle infinie en adaptant votre code pour qu'il gère correctement le format de votre token JWT, qui ne contient pas les informations d'utilisateur directement dans le token.

Après avoir fait ces modifications, redémarrez votre application et essayez de vous connecter à nouveau.





AuthContext.js:20 AuthContext: Token au chargement: Présent AuthContext.js:26 AuthContext: Token décodé: {sub: 'admin@teleconsultation.com', iat: 1746667879, exp: 1746754279} AuthContext.js:32 AuthContext: Token valide, expiration: 09/05/2025 01:31:19 AuthContext.js:20 AuthContext: Token au charg

pasted

j'ai apporté les modifications, voici ce que j'ai :

Modifier
Je vois que vous avez toujours le problème de "Maximum update depth exceeded", qui indique une boucle infinie de mises à jour. L'erreur se produit à la ligne 60 de votre fichier App.js, qui semble être liée à un composant <Navigate>.

Pour résoudre ce problème spécifique, je vous propose une solution plus directe. Voici les étapes à suivre :

1. Modifiez votre fichier App.js
Ouvrez votre fichier App.js et localisez la ligne qui cause le problème. D'après l'erreur, il s'agit probablement de la ligne 60 qui contient un composant <Navigate>. Le problème est que ce composant provoque une redirection qui déclenche à nouveau le rendu, créant ainsi une boucle infinie.

Voici comment vous pourriez modifier cette section :

jsx
{/* Redirect based on role */}
<Route 
  path="/redirect" 
  element={
    isAuthenticated ? (
      // Au lieu d'utiliser Navigate qui provoque des redirections immédiates
      // Utilisez une fonction qui effectue une redirection conditionnelle
      <RedirectBasedOnRole userRole={userRole} />
    ) : <Navigate to="/login" />
  } 
/>
Et ajoutez ce composant dans le même fichier :

jsx
// Composant pour gérer la redirection en fonction du rôle
const RedirectBasedOnRole = ({ userRole }) => {
  const navigate = useNavigate();
  
  React.useEffect(() => {
    let path = '/login';
    
    if (userRole === 'ROLE_ADMIN') {
      path = '/admin/dashboard';
    } else if (userRole === 'ROLE_MEDECIN') {
      path = '/medecin/dashboard';
    } else if (userRole === 'ROLE_PATIENT') {
      path = '/patient/dashboard';
    } else if (userRole === 'ROLE_SECRETAIRE') {
      path = '/secretaire/dashboard';
    }
    
    navigate(path, { replace: true });
  }, [navigate, userRole]);
  
  // Retourner un élément vide ou un indicateur de chargement
  return <div>Redirection en cours...</div>;
};
2. Modifiez votre useEffect dans AuthContext.js
jsx
useEffect(() => {
  // Vérifier si un token existe déjà
  const token = localStorage.getItem('token');
  
  if (token) {
    try {
      // Vérifier si le token est valide
      const decodedToken = jwtDecode(token);
      const currentTime = Date.now() / 1000;
      
      if (decodedToken.exp > currentTime) {
        // Si le token contient seulement l'email dans le claim "sub"
        setCurrentUser({ email: decodedToken.sub });
        // Ne pas essayer de définir le rôle à partir du token si roles n'existe pas
        setIsAuthenticated(true);
      } else {
        // Token expiré, nettoyer
        localStorage.removeItem('token');
        setCurrentUser(null);
        setUserRole(null);
        setIsAuthenticated(false);
      }
    } catch (error) {
      // Erreur de décodage, nettoyer
      localStorage.removeItem('token');
      setCurrentUser(null);
      setUserRole(null);
      setIsAuthenticated(false);
    }
  }
  
  setLoading(false);
}, []); // Aucune dépendance pour éviter les boucles infinies
3. Si le problème persiste, une solution radicale
Si les solutions ci-dessus ne fonctionnent pas, vous pouvez essayer une approche plus radicale : désactiver temporairement la vérification du token au démarrage jusqu'à ce que vous puissiez vous connecter et déboguer davantage.

jsx
useEffect(() => {
  // Désactiver temporairement la vérification du token jusqu'à ce que le problème soit résolu
  /*
  const token = localStorage.getItem('token');
  if (token) {
    // Code de vérification du token...
  }
  */
  
  // Forcer l'état non authentifié pour démarrer avec l'écran de connexion
  localStorage.removeItem('token');
  setCurrentUser(null);
  setUserRole(null);
  setIsAuthenticated(false);
  setLoading(false);
}, []);
Cette solution radicale vous permettra de repartir d'un état propre. Après vous être connecté avec succès, vous pourrez réactiver la vérification du token.

4. Alternative : utilisez localStorage pour stocker les informations complètes de l'utilisateur
Une autre solution consiste à stocker les informations complètes de l'utilisateur dans localStorage en plus du token :

jsx
// Dans handleLogin
const handleLogin = async (email, password) => {
  try {
    const response = await login(email, password);
    
    if (response && response.data) {
      const { token, id, email: userEmail, nom, prenom, roles } = response.data;
      
      // Stocker le token
      localStorage.setItem('token', token);
      
      // Stocker également les données utilisateur complètes
      const userData = { id, email: userEmail, nom, prenom, roles };
      localStorage.setItem('userData', JSON.stringify(userData));
      
      setCurrentUser(userData);
      setUserRole(Array.isArray(roles) ? roles[0] : roles);
      setIsAuthenticated(true);
      
      return { success: true, user: userData };
    } else {
      return { success: false, message: "Format de réponse incorrect" };
    }
  } catch (error) {
    return { 
      success: false, 
      message: error.response?.data?.message || 'Erreur lors de la connexion' 
    };
  }
};

// Dans useEffect
useEffect(() => {
  const token = localStorage.getItem('token');
  const userDataString = localStorage.getItem('userData');
  
  if (token && userDataString) {
    try {
      const decodedToken = jwtDecode(token);
      const currentTime = Date.now() / 1000;
      
      if (decodedToken.exp > currentTime) {
        // Token valide, restaurer les données utilisateur depuis localStorage
        const userData = JSON.parse(userDataString);
        setCurrentUser(userData);
        setUserRole(Array.isArray(userData.roles) ? userData.roles[0] : userData.roles);
        setIsAuthenticated(true);
      } else {
        // Token expiré
        handleLogout();
      }
    } catch (error) {
      handleLogout();
    }
  }
  
  setLoading(false);
}, []);

// Dans handleLogout
const handleLogout = () => {
  localStorage.removeItem('token');
  localStorage.removeItem('userData');
  setCurrentUser(null);
  setUserRole(null);
  setIsAuthenticated(false);
};
Essayez l'une de ces solutions pour résoudre votre problème de boucle infinie. Si aucune ne fonctionne, veuillez me fournir le code de votre fichier App.js, en particulier la ligne 60 où l'erreur se produit.




voici le fichier app.js :
import React from 'react';
import { Routes, Route, Navigate } from 'react-router-dom';
import { ThemeProvider, createTheme } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { LocalizationProvider } from '@mui/x-date-pickers';
import { frFR } from '@mui/material/locale';
import { fr } from 'date-fns/locale';

// Pages
import Login from './pages/Login';
import Register from './pages/Register';
import NotFound from './pages/NotFound';

// Layouts
import AdminLayout from './components/layouts/AdminLayout';
import MedecinLayout from './components/layouts/MedecinLayout';
import PatientLayout from './components/layouts/PatientLayout';
import SecretaireLayout from './components/layouts/SecretaireLayout';

// Route Guards
import PrivateRoute from './routes/PrivateRoute';
import RoleRoute from './routes/RoleRoute';

// Context
import { useAuth } from './context/AuthContext';

// Thème personnalisé
const theme = createTheme({
  palette: {
    primary: {
      main: '
#2196f3',
    },
    secondary: {
      main: '
#f50057',
    },
  },
}, frFR);

function App() {
  const { isAuthenticated, userRole } = useAuth();

  return (
    <ThemeProvider theme={theme}>
      <LocalizationProvider dateAdapter={AdapterDateFns} locale={fr}>
        <CssBaseline />
        <Routes>
          {/* Public Routes */}
          <Route path="/login" element={!isAuthenticated ? <Login /> : <Navigate to="/redirect" />} />
          <Route path="/register" element={!isAuthenticated ? <Register /> : <Navigate to="/redirect" />} />

          {/* Redirect based on role */}
          <Route 
            path="/redirect" 
            element={
              isAuthenticated ? (
                userRole === 'ROLE_ADMIN' ? <Navigate to="/admin/dashboard" /> :
                userRole === 'ROLE_MEDECIN' ? <Navigate to="/medecin/dashboard" /> :
                userRole === 'ROLE_PATIENT' ? <Navigate to="/patient/dashboard" /> :
                userRole === 'ROLE_SECRETAIRE' ? <Navigate to="/secretaire/dashboard" /> :
                <Navigate to="/login" />
              ) : <Navigate to="/login" />
            } 
          />

          {/* Protected Routes /}
          <Route path="/admin/" element={
            <RoleRoute requiredRole="ROLE_ADMIN">
              <AdminLayout />
            </RoleRoute>
          } />

          <Route path="/medecin/*" element={
            <RoleRoute requiredRole="ROLE_MEDECIN">
              <MedecinLayout />
            </RoleRoute>
          } />

          <Route path="/patient/*" element={
            <RoleRoute requiredRole="ROLE_PATIENT">
              <PatientLayout />
            </RoleRoute>
          } />

          <Route path="/secretaire/*" element={
            <RoleRoute requiredRole="ROLE_SECRETAIRE">
              <SecretaireLayout />
            </RoleRoute>
          } />

          {/* Redirect root to login or dashboard */}
          <Route path="/" element={<Navigate to={isAuthenticated ? "/redirect" : "/login"} />} />

          {/* */}

          <Route path="*" element={<NotFound />} />

        </Routes>
      </LocalizationProvider>
    </ThemeProvider>
  );
}

export default App;

Modifier
Je vois le problème dans votre fichier App.js. C'est bien la section "Redirect based on role" qui crée la boucle infinie. Voici comment modifier cette partie pour résoudre le problème :

Solution 1 : Créez un composant RedirectBasedOnRole
Remplacez la partie problématique par un composant spécifique :

jsx
// Ajoutez ce composant au début de votre fichier App.js
const RedirectBasedOnRole = ({ userRole }) => {
  const navigate = useNavigate();
  
  React.useEffect(() => {
    let path = '/login';
    
    if (userRole === 'ROLE_ADMIN') {
      path = '/admin/dashboard';
    } else if (userRole === 'ROLE_MEDECIN') {
      path = '/medecin/dashboard';
    } else if (userRole === 'ROLE_PATIENT') {
      path = '/patient/dashboard';
    } else if (userRole === 'ROLE_SECRETAIRE') {
      path = '/secretaire/dashboard';
    }
    
    navigate(path, { replace: true });
  }, [navigate, userRole]);
  
  return <div>Redirection en cours...</div>;
};
Puis modifiez votre route de redirection :

jsx
{/* Redirect based on role */}
<Route 
  path="/redirect" 
  element={
    isAuthenticated ? <RedirectBasedOnRole userRole={userRole} /> : <Navigate to="/login" />
  } 
/>
Solution 2 : Simplifiez la logique de redirection
Si la première solution ne fonctionne pas, essayez cette approche plus simple :

jsx
// Modifiez votre route root pour éviter d'utiliser /redirect
<Route path="/" element={
  isAuthenticated ? (
    userRole === 'ROLE_ADMIN' ? <Navigate to="/admin/dashboard" /> :
    userRole === 'ROLE_MEDECIN' ? <Navigate to="/medecin/dashboard" /> :
    userRole === 'ROLE_PATIENT' ? <Navigate to="/patient/dashboard" /> :
    userRole === 'ROLE_SECRETAIRE' ? <Navigate to="/secretaire/dashboard" /> :
    <Login />
  ) : <Login />
} />

// Supprimez la route /redirect et remplacez toutes les redirections vers /redirect par des redirections vers /
<Route path="/login" element={!isAuthenticated ? <Login /> : <Navigate to="/" />} />
<Route path="/register" element={!isAuthenticated ? <Register /> : <Navigate to="/" />} />
Solution 3 : Corrigez le problème dans AuthContext.js
Si votre token ne contient pas les informations de rôle, vous devez modifier votre fonction useEffect dans AuthContext.js pour qu'elle ne tente pas d'accéder à des propriétés inexistantes :

jsx
useEffect(() => {
  // Alternative: désactiver temporairement le chargement du token pour déboguer
  localStorage.removeItem('token');
  setCurrentUser(null);
  setUserRole(null);
  setIsAuthenticated(false);
  setLoading(false);
  // Cela vous permettra de repartir d'un état propre et de vous connecter à nouveau
}, []);
Cette solution radicale vous permettra de vous connecter à nouveau et de voir si le problème persiste. Une fois connecté avec succès, vous pourrez restaurer la logique normale de vérification du token.

À long terme, vous devriez corriger les problèmes dans le format du token JWT pour qu'il contienne toutes les informations nécessaires, ou stocker également les informations complètes de l'utilisateur dans localStorage comme je l'ai suggéré précédemment.

Essayez l'une de ces solutions et voyez si cela résout votre problème de boucle infinie.




allons pour la solution 2

Modifier
D'accord, allons-y avec la solution 2 ! Voici comment vous devez modifier votre fichier App.js :

jsx
import React from 'react';
import { Routes, Route, Navigate } from 'react-router-dom';
import { ThemeProvider, createTheme } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { LocalizationProvider } from '@mui/x-date-pickers';
import { frFR } from '@mui/material/locale';
import { fr } from 'date-fns/locale';

// Pages
import Login from './pages/Login';
import Register from './pages/Register';
import NotFound from './pages/NotFound';

// Layouts
import AdminLayout from './components/layouts/AdminLayout';
import MedecinLayout from './components/layouts/MedecinLayout';
import PatientLayout from './components/layouts/PatientLayout';
import SecretaireLayout from './components/layouts/SecretaireLayout';

// Route Guards
import PrivateRoute from './routes/PrivateRoute';
import RoleRoute from './routes/RoleRoute';

// Context
import { useAuth } from './context/AuthContext';

// Thème personnalisé
const theme = createTheme({
  palette: {
    primary: {
      main: '#2196f3',
    },
    secondary: {
      main: '#f50057',
    },
  },
}, frFR);

function App() {
  const { isAuthenticated, userRole } = useAuth();

  return (
    <ThemeProvider theme={theme}>
      <LocalizationProvider dateAdapter={AdapterDateFns} locale={fr}>
        <CssBaseline />
        <Routes>
          {/* Public Routes */}
          <Route path="/login" element={!isAuthenticated ? <Login /> : <Navigate to="/" />} />
          <Route path="/register" element={!isAuthenticated ? <Register /> : <Navigate to="/" />} />
          
          {/* Protected Routes */}
          <Route path="/admin/*" element={
            <RoleRoute requiredRole="ROLE_ADMIN">
              <AdminLayout />
            </RoleRoute>
          } />
          
          <Route path="/medecin/*" element={
            <RoleRoute requiredRole="ROLE_MEDECIN">
              <MedecinLayout />
            </RoleRoute>
          } />
          
          <Route path="/patient/*" element={
            <RoleRoute requiredRole="ROLE_PATIENT">
              <PatientLayout />
            </RoleRoute>
          } />
          
          <Route path="/secretaire/*" element={
            <RoleRoute requiredRole="ROLE_SECRETAIRE">
              <SecretaireLayout />
            </RoleRoute>
          } />
          
          {/* Redirect root to login or dashboard based on role */}
          <Route path="/" element={
            isAuthenticated ? (
              userRole === 'ROLE_ADMIN' ? <Navigate to="/admin/dashboard" /> :
              userRole === 'ROLE_MEDECIN' ? <Navigate to="/medecin/dashboard" /> :
              userRole === 'ROLE_PATIENT' ? <Navigate to="/patient/dashboard" /> :
              userRole === 'ROLE_SECRETAIRE' ? <Navigate to="/secretaire/dashboard" /> :
              <Login />
            ) : <Login />
          } />
          
          {/* 404 Not Found */}
          <Route path="*" element={<NotFound />} />
        </Routes>
      </LocalizationProvider>
    </ThemeProvider>
  );
}

export default App;
Principales modifications :

J'ai supprimé complètement la route /redirect qui causait la boucle infinie
J'ai modifié les redirections dans /login et /register pour qu'elles pointent vers / au lieu de /redirect
J'ai intégré la logique de redirection directement dans la route racine (/)
Cette approche est plus simple et devrait éviter les boucles infinies. Dès qu'un utilisateur accède à la racine, il est immédiatement redirigé vers le bon tableau de bord en fonction de son rôle, ou vers la page de connexion s'il n'est pas authentifié.





import React, { useState, useEffect } from 'react'; import { Container, Typography, Paper, Button, Box, Tabs, Tab, Dialog, DialogActions, DialogContent, DialogContentText, DialogTitle, Alert, Snackbar, Chip } from '@mui/mat

pasted

sur la gestion des utilisateurs les noms et prenoms ne s'affichent pas mais l'email et le rôle si. voici le script actuel :

Modifier
Je vois que vous avez un problème d'affichage des noms et prénoms dans votre grille de gestion des utilisateurs. Le problème semble venir de la manière dont vous accédez aux propriétés nom et prenom dans votre fonction valueGetter.

Actuellement, vous avez :

jsx
{
    field: 'nom',
    headerName: 'Nom',
    width: 150,
    valueGetter: (params) => `${params.row?.nom || ''} ${params.row?.prenom || ''}`
}
Ce code utilise l'opérateur de chaînage optionnel (?.), ce qui est correct, mais il est possible que la structure des données que vous recevez de votre API soit différente de ce que vous attendez.

Essayons de résoudre ce problème :

Solution 1 : Ajouter des logs pour déboguer
Modifiez votre composant pour ajouter des logs et comprendre la structure exacte des données :

jsx
useEffect(() => {
    fetchData();
}, []);

const fetchData = async () => {
    setLoading(true);
    try {
        const [utilisateursResponse, enAttenteResponse] = await Promise.all([
            getAllUtilisateurs(),
            getUtilisateursEnAttente()
        ]);
        
        // Ajout de logs pour déboguer
        console.log("Utilisateurs:", utilisateursResponse.data);
        if (utilisateursResponse.data.length > 0) {
            console.log("Premier utilisateur:", utilisateursResponse.data[0]);
        }
        
        setUtilisateurs(utilisateursResponse.data);
        setUtilisateursEnAttente(enAttenteResponse.data);
    } catch (error) {
        console.error('Erreur lors du chargement des utilisateurs:', error);
        showSnackbar('Erreur lors du chargement des données', 'error');
    } finally {
        setLoading(false);
    }
};
Solution 2 : Modifier la définition de la colonne Nom
Si vous avez vérifié la structure et constaté que les propriétés sont directement accessibles (sans être imbriquées), vous pourriez modifier la colonne comme ceci :

jsx
{
    field: 'nomComplet',
    headerName: 'Nom',
    width: 150,
    valueGetter: (params) => {
        // Déboguer la structure de l'objet
        console.log("Row data:", params.row);
        
        // Vérifier si nom et prenom existent et ne sont pas undefined
        const nom = params.row.nom !== undefined ? params.row.nom : '';
        const prenom = params.row.prenom !== undefined ? params.row.prenom : '';
        
        return `${nom} ${prenom}`.trim();
    }
}
Solution 3 : Adapter la colonne à la structure exacte des données
Si les données sont structurées différemment, par exemple si le nom et le prénom sont dans une propriété imbriquée comme user.nom et user.prenom, ajustez la colonne en conséquence :

jsx
{
    field: 'nomComplet',
    headerName: 'Nom',
    width: 150,
    valueGetter: (params) => {
        // Si les données utilisateur sont imbriquées dans une propriété user
        if (params.row.user) {
            return `${params.row.user.nom || ''} ${params.row.user.prenom || ''}`.trim();
        }
        // Sinon, essayer d'accéder directement
        return `${params.row.nom || ''} ${params.row.prenom || ''}`.trim();
    }
}
Solution 4 : Utiliser une fonction renderCell au lieu de valueGetter
Si les méthodes précédentes ne fonctionnent pas, vous pouvez essayer d'utiliser renderCell qui vous donne plus de contrôle :

jsx
{
    field: 'nom',
    headerName: 'Nom',
    width: 150,
    renderCell: (params) => {
        // Déboguer
        console.log("Cell data:", params.row);
        
        // Construire le nom complet en fonction de la structure disponible
        let nomComplet = '';
        if (params.row.nom !== undefined && params.row.prenom !== undefined) {
            nomComplet = `${params.row.nom} ${params.row.prenom}`;
        } else if (params.row.user) {
            nomComplet = `${params.row.user.nom || ''} ${params.row.user.prenom || ''}`;
        }
        
        return <span>{nomComplet}</span>;
    }
}
Essayez l'une de ces solutions et vérifiez les logs dans la console pour comprendre exactement comment sont structurées vos données. Cela vous aidera à ajuster votre code en conséquence.




j'ai apporté la solution 1 et j'ai eu ça sur ma console : 
AuthContext.js:20 AuthContext: Token au chargement: Présent
AuthContext.js:26 AuthContext: Token décodé: Object
AuthContext.js:32 AuthContext: Token valide, expiration: 09/05/2025 02:29:26
hook.js:377 AuthContext: Token au chargement: Présent
hook.js:377 AuthContext: Token décodé: Object
hook.js:377 AuthContext: Token valide, expiration: 09/05/2025 02:29:26
hook.js:608 MUI Grid: The item prop has been removed and is no longer necessary. You can safely remove it.
overrideMethod @ hook.js:608
Login.jsx:41 Login.jsx: Tentative de connexion avec: Object
AuthContext.js:70 AuthContext: Tentative de connexion avec: Object
AuthContext.js:73 AuthContext: Réponse brute de l'API: Object
AuthContext.js:77 AuthContext: Données extraites: Object
AuthContext.js:97 AuthContext: Utilisateur connecté: Object
AuthContext.js:98 AuthContext: Rôle défini: ROLE_ADMIN
Login.jsx:44 Login.jsx: Résultat de la connexion: Object
Login.jsx:47 Login.jsx: Connexion réussie, redirection...
hook.js:608 MUI Grid: The xs prop has been removed. See https://mui.com/material-ui/migration/upgrade-to-grid-v2/ for migration instructions.
overrideMethod @ hook.js:608
hook.js:608 MUI Grid: The md prop has been removed. See https://mui.com/material-ui/migration/upgrade-to-grid-v2/ for migration instructions.
overrideMethod @ hook.js:608
hook.js:608 MUI Grid: The sm prop has been removed. See https://mui.com/material-ui/migration/upgrade-to-grid-v2/ for migration instructions.
overrideMethod @ hook.js:608
GestionUtilisateurs.jsx:82 Utilisateurs: Array(2)0: {id: 2, nom: 'Admin', prenom: 'System', email: 'admin@teleconsultation.com', motDePasse: '$2a$10$HR/cMhqoLVjuIg8u1w3GJ.l5P0RrzywJZ6V0h6hUNPtj0bziY.TN6', …}1: {id: 1, nom: 'diallo', prenom: 'moussa', email: 'japhetmokoumbou@esp.sn', motDePasse: '$2a$10$HklI.uhEd3Yef36FUIxISuvNM8qf0HIKNqQCMi7EnhajyFPTdng5e', …}length: 2[[Prototype]]: Array(0)
GestionUtilisateurs.jsx:84 Premier utilisateur: Objectactif: truecompteValide: truedateCreation: "2025-05-08T01:05:07.882888"email: "admin@teleconsultation.com"id: 2motDePasse: "$2a$10$HR/cMhqoLVjuIg8u1w3GJ.l5P0RrzywJZ6V0h6hUNPtj0bziY.TN6"nom: "Admin"prenom: "System"roles: [{…}]telephone: null[[Prototype]]: Object
GestionUtilisateurs.jsx:82 Utilisateurs: Array(2)
GestionUtilisateurs.jsx:84 Premier utilisateur: Object

Modifier
D'après les logs, je vois que vos données d'utilisateurs sont bien structurées et contiennent directement les propriétés nom et prenom :

Premier utilisateur: Object
actif: true
compteValide: true
dateCreation: "2025-05-08T01:05:07.882888"
email: "admin@teleconsultation.com"
id: 2
motDePasse: "$2a$10$HR/cMhqoLVjuIg8u1w3GJ.l5P0RrzywJZ6V0h6hUNPtj0bziY.TN6"
nom: "Admin"
prenom: "System"
roles: [{…}]
telephone: null
Le problème pourrait être lié à la façon dont le DataGrid traite les données ou aux propriétés de colonne. Essayons la solution 2 pour résoudre ce problème :

jsx
{
    field: 'nomComplet',
    headerName: 'Nom',
    width: 150,
    valueGetter: (params) => {
        // Les logs confirment que ces propriétés existent
        return `${params.row.nom || ''} ${params.row.prenom || ''}`.trim();
    }
}
Si cette modification ne résout pas le problème, essayons la solution 4 qui utilise renderCell :

jsx
{
    field: 'nom',
    headerName: 'Nom',
    width: 150,
    renderCell: (params) => {
        return <span>{params.row.nom} {params.row.prenom}</span>;
    }
}
Vous pouvez également essayer de déboguer directement dans le composant DataGrid en ajoutant des logs dans les colonnes :

jsx
const columnsUtilisateurs = [
    { field: 'id', headerName: 'ID', width: 70 },
    {
        field: 'nom',
        headerName: 'Nom',
        width: 150,
        renderCell: (params) => {
            console.log("Rendering nom cell:", params.row);
            return <span>{params.row.nom} {params.row.prenom}</span>;
        }
    },
    { field: 'email', headerName: 'Email', width: 200 },
    // Autres colonnes...
];
Une autre possibilité est que le DataGrid ne réagisse pas correctement aux changements de données. Essayez d'ajouter une clé unique à chaque ligne dans votre composant DataGrid :

jsx
<DataGrid
    rows={utilisateurs.map(user => ({...user, id: user.id}))}
    columns={columnsUtilisateurs}
    pageSize={10}
    rowsPerPageOptions={[10, 25, 50]}
    loading={loading}
    disableSelectionOnClick
/>
Si ces solutions ne fonctionnent pas, vérifiez si vous utilisez une version récente du DataGrid qui pourrait avoir des modifications dans la façon dont les données sont traitées. Dans ce cas, consultez la documentation officielle pour voir s'il y a des changements dans l'API.




ça a marché avec renderCell mais fait ça également avec 
 {
            field: 'dateCreation',
            headerName: 'Date d\'inscription',
            width: 180,
            valueFormatter: (params) => {
                if (!params.value) return '';
                const date = new Date(params.value);
                return date.toLocaleDateString('fr-FR') + ' ' + date.toLocaleTimeString('fr-FR');
            }
        }

Modifier
Parfait, la solution avec renderCell a fonctionné pour la colonne des noms ! Maintenant, appliquons la même approche au formatage de la date d'inscription en remplaçant valueFormatter par renderCell :

jsx
{
    field: 'dateCreation',
    headerName: 'Date d\'inscription',
    width: 180,
    renderCell: (params) => {
        if (!params.row.dateCreation) return <span>-</span>;
        
        try {
            const date = new Date(params.row.dateCreation);
            return <span>{date.toLocaleDateString('fr-FR') + ' ' + date.toLocaleTimeString('fr-FR')}</span>;
        } catch (error) {
            console.error("Erreur de formatage de date:", error);
            return <span>{params.row.dateCreation}</span>;
        }
    }
}
Cette modification devrait résoudre le problème pour la colonne de date d'inscription également.

La différence clé entre valueFormatter et renderCell est que :

valueFormatter transforme la valeur d'une cellule avant son affichage, mais attend toujours que la valeur soit accessible via params.value.
renderCell vous donne un contrôle total sur le rendu de la cellule et vous permet d'accéder directement à l'objet complet de la ligne via params.row.
Il semble que dans votre cas, l'accès direct à l'objet de la ligne via params.row fonctionne mieux que l'accès aux propriétés spécifiques via params.value. C'est pourquoi le remplacement de valueFormatter par renderCell résout le problème.





import React, { useState } from 'react'; import { Container, Paper, Typography, TextField, Button, Grid, Link, Alert, Box } from '@mui/material'; import { useNavigate } from 'react-router-dom'; import { useAuth } from '../context/AuthContext'; cons

pasted

sur la page de connexion quand je clique sur le lien pour inscrire un nouvel utilisateur, ça me recharge la même page

Modifier
Le problème avec le lien d'inscription est probablement lié au fait que vous utilisez un élément Link de Material UI au lieu d'un Link de React Router. La différence est que le Link de Material UI fonctionne comme une balise <a> HTML standard et provoque un rechargement de page, tandis que le Link de React Router gère la navigation côté client sans recharger la page.

Voici comment vous pouvez corriger cela :

Importez le composant Link de React Router :
jsx
import { Link as RouterLink, useNavigate } from 'react-router-dom';
Modifiez la section de lien dans votre formulaire :
jsx
<Grid container justifyContent="center">
    <Grid item>
        <RouterLink to="/register" style={{ textDecoration: 'none' }}>
            <Typography variant="body2" color="primary">
                {"Vous n'avez pas de compte ? Inscrivez-vous"}
            </Typography>
        </RouterLink>
    </Grid>
</Grid>
Ou, si vous préférez garder l'apparence du Link de Material UI mais avec le comportement de React Router :

jsx
<Grid container justifyContent="center">
    <Grid item>
        <Link component={RouterLink} to="/register" variant="body2">
            {"Vous n'avez pas de compte ? Inscrivez-vous"}
        </Link>
    </Grid>
</Grid>
Cette modification permettra à l'utilisateur de naviguer vers la page d'inscription sans recharger la page entière, ce qui est le comportement attendu dans une application React à page unique (SPA).

Assurez-vous également que votre route "/register" est correctement définie dans votre fichier App.js, ce qui semble être le cas d'après nos discussions précédentes.




pour la phase 2 j'ai déjà testé la connexion, la validation,  l'inscription, la déconnexion. Mais sur le dashboard de l'admin ya des choses qui sont encore en dure. Nous pouvons passer à la phase 3 ?

Modifier
Oui, nous pouvons passer à la Phase 3 ! Vous avez bien testé toutes les fonctionnalités essentielles de la Phase 2 (authentification et gestion des utilisateurs).

Phase 3: Fonctionnalités de base pour les différents utilisateurs
Dans cette phase, nous allons développer les tableaux de bord et les fonctionnalités de base pour chaque type d'utilisateur (médecin, patient, secrétaire et administrateur). Nous avons déjà une base pour le tableau de bord administrateur, mais certaines données sont encore en dur.

Voici ce que nous allons développer pour chaque type d'utilisateur :

1. Tableau de bord Médecin
Vue d'ensemble de ses rendez-vous à venir
Liste des patients associés
Statistiques (nombre de consultations, patients, etc.)
2. Tableau de bord Patient
Ses prochains rendez-vous
État de son dossier médical
Possibilité de télécharger des images DICOM
3. Tableau de bord Secrétaire
Interface de planification des rendez-vous
Liste des rendez-vous du jour
Recherche de patients et médecins
4. Finalisation du tableau de bord Admin
Amélioration avec des statistiques réelles
Ajout de fonctionnalités de monitoring
Commençons par développer ces différents tableaux de bord. Je vais vous présenter le code pour chacun d'eux, en commençant par améliorer le tableau de bord de l'administrateur.

Amélioration du tableau de bord Administrateur
Créons d'abord un service pour obtenir les statistiques réelles plutôt que des données en dur :

java
// AdminService.java (Backend)
@Service
public class AdminService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private PatientRepository patientRepository;
    
    @Autowired
    private MedecinRepository medecinRepository;
    
    @Autowired
    private SecretaireMedicalRepository secretaireRepository;
    
    @Autowired
    private RendezVousRepository rendezVousRepository;
    
    public Map<String, Object> getDashboardStats() {
        Map<String, Object> stats = new HashMap<>();
        
        stats.put("totalUsers", userRepository.count());
        stats.put("totalPatients", patientRepository.count());
        stats.put("totalMedecins", medecinRepository.count());
        stats.put("totalSecretaires", secretaireRepository.count());
        stats.put("totalAdmins", userRepository.countByRoles_Name(ERole.ROLE_ADMIN));
        
        // Rendez-vous de la semaine en cours
        LocalDateTime startOfWeek = LocalDateTime.now().with(TemporalAdjusters.previousOrSame(DayOfWeek.MONDAY));
        LocalDateTime endOfWeek = LocalDateTime.now().with(TemporalAdjusters.nextOrSame(DayOfWeek.SUNDAY));
        stats.put("rendezVousSemaine", rendezVousRepository.countByDateHeureBetween(startOfWeek, endOfWeek));
        
        // Utilisateurs récemment inscrits (5 derniers jours)
        LocalDateTime fiveDaysAgo = LocalDateTime.now().minusDays(5);
        stats.put("nouveauxUtilisateurs", userRepository.countByDateCreationAfter(fiveDaysAgo));
        
        return stats;
    }
}
Ajoutons l'API pour récupérer ces statistiques :

java
// AdminController.java (Backend)
@RestController
@RequestMapping("/api/admin")
@PreAuthorize("hasRole('ADMIN')")
public class AdminController {
    
    @Autowired
    private AdminService adminService;
    
    @GetMapping("/dashboard/stats")
    public ResponseEntity<Map<String, Object>> getDashboardStats() {
        Map<String, Object> stats = adminService.getDashboardStats();
        return ResponseEntity.ok(stats);
    }
    
    // Autres méthodes existantes...
}
Maintenant, créons le service frontend correspondant :

javascript
// src/services/adminService.js
import axios from 'axios';
import { API_URL } from '../config';

// Fonctions existantes...

// Obtenir les statistiques du tableau de bord
export const getDashboardStats = () => {
    return axios.get(`${API_URL}/admin/dashboard/stats`);
};
Enfin, mettons à jour le tableau de bord de l'administrateur pour utiliser ces données réelles :

jsx
// src/pages/admin/AdminDashboard.jsx
import React, { useState, useEffect } from 'react';
import {
    Container,
    Grid,
    Paper,
    Typography,
    Box,
    Card,
    CardContent,
    CardHeader,
    List,
    ListItem,
    ListItemText,
    Divider,
    CircularProgress
} from '@mui/material';
import {
    Person as PersonIcon,
    MedicalServices as MedicinIcon,
    AssignmentInd as SecretaryIcon,
    SupervisorAccount as AdminIcon,
    Event as EventIcon,
    TrendingUp as TrendingUpIcon
} from '@mui/icons-material';
import { getDashboardStats, getUtilisateursEnAttente } from '../../services/adminService';

const AdminDashboard = () => {
    const [stats, setStats] = useState({
        totalUsers: 0,
        totalPatients: 0,
        totalMedecins: 0,
        totalSecretaires: 0,
        totalAdmins: 0,
        rendezVousSemaine: 0,
        nouveauxUtilisateurs: 0
    });
    const [utilisateursEnAttente, setUtilisateursEnAttente] = useState([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const fetchData = async () => {
            try {
                setLoading(true);
                const [statsResponse, utilisateursResponse] = await Promise.all([
                    getDashboardStats(),
                    getUtilisateursEnAttente()
                ]);
                
                setStats(statsResponse.data);
                setUtilisateursEnAttente(utilisateursResponse.data);
            } catch (error) {
                console.error('Erreur lors du chargement des données:', error);
            } finally {
                setLoading(false);
            }
        };

        fetchData();
    }, []);

    if (loading) {
        return (
            <Container maxWidth="lg" sx={{ mt: 4, mb: 4, textAlign: 'center' }}>
                <CircularProgress />
            </Container>
        );
    }

    return (
        <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
            <Typography variant="h4" sx={{ mb: 3 }}>
                Tableau de bord Administrateur
            </Typography>

            <Grid container spacing={3}>
                {/* Statistiques */}
                <Grid item xs={12} md={8}>
                    <Paper sx={{ p: 2, display: 'flex', flexDirection: 'column' }}>
                        <Typography variant="h6" gutterBottom>
                            Statistiques générales
                        </Typography>
                        <Grid container spacing={3}>
                            <Grid item xs={6} sm={4}>
                                <Card sx={{ bgcolor: '#f5f5f5' }}>
                                    <CardContent sx={{ textAlign: 'center' }}>
                                        <PersonIcon color="primary" sx={{ fontSize: 40 }} />
                                        <Typography variant="h5">{stats.totalUsers}</Typography>
                                        <Typography variant="body2" color="text.secondary">
                                            Utilisateurs
                                        </Typography>
                                    </CardContent>
                                </Card>
                            </Grid>
                            <Grid item xs={6} sm={4}>
                                <Card sx={{ bgcolor: '#f5f5f5' }}>
                                    <CardContent sx={{ textAlign: 'center' }}>
                                        <PersonIcon color="info" sx={{ fontSize: 40 }} />
                                        <Typography variant="h5">{stats.totalPatients}</Typography>
                                        <Typography variant="body2" color="text.secondary">
                                            Patients
                                        </Typography>
                                    </CardContent>
                                </Card>
                            </Grid>
                            <Grid item xs={6} sm={4}>
                                <Card sx={{ bgcolor: '#f5f5f5' }}>
                                    <CardContent sx={{ textAlign: 'center' }}>
                                        <MedicinIcon color="success" sx={{ fontSize: 40 }} />
                                        <Typography variant="h5">{stats.totalMedecins}</Typography>
                                        <Typography variant="body2" color="text.secondary">
                                            Médecins
                                        </Typography>
                                    </CardContent>
                                </Card>
                            </Grid>
                            <Grid item xs={6} sm={4}>
                                <Card sx={{ bgcolor: '#f5f5f5' }}>
                                    <CardContent sx={{ textAlign: 'center' }}>
                                        <SecretaryIcon color="warning" sx={{ fontSize: 40 }} />
                                        <Typography variant="h5">{stats.totalSecretaires}</Typography>
                                        <Typography variant="body2" color="text.secondary">
                                            Secrétaires
                                        </Typography>
                                    </CardContent>
                                </Card>
                            </Grid>
                            <Grid item xs={6} sm={4}>
                                <Card sx={{ bgcolor: '#f5f5f5' }}>
                                    <CardContent sx={{ textAlign: 'center' }}>
                                        <AdminIcon color="error" sx={{ fontSize: 40 }} />
                                        <Typography variant="h5">{stats.totalAdmins}</Typography>
                                        <Typography variant="body2" color="text.secondary">
                                            Administrateurs
                                        </Typography>
                                    </CardContent>
                                </Card>
                            </Grid>
                            <Grid item xs={6} sm={4}>
                                <Card sx={{ bgcolor: '#f5f5f5' }}>
                                    <CardContent sx={{ textAlign: 'center' }}>
                                        <EventIcon color="secondary" sx={{ fontSize: 40 }} />
                                        <Typography variant="h5">{stats.rendezVousSemaine}</Typography>
                                        <Typography variant="body2" color="text.secondary">
                                            RDV cette semaine
                                        </Typography>
                                    </CardContent>
                                </Card>
                            </Grid>
                        </Grid>
                    </Paper>
                </Grid>

                {/* Utilisateurs en attente */}
                <Grid item xs={12} md={4}>
                    <Paper sx={{ p: 2, display: 'flex', flexDirection: 'column', height: '100%' }}>
                        <Typography variant="h6" gutterBottom>
                            Utilisateurs en attente de validation
                        </Typography>
                        {utilisateursEnAttente.length > 0 ? (
                            <List>
                                {utilisateursEnAttente.map((user, index) => (
                                    <React.Fragment key={user.id}>
                                        <ListItem>
                                            <ListItemText
                                                primary={`${user.nom} ${user.prenom}`}
                                                secondary={user.email}
                                            />
                                        </ListItem>
                                        {index < utilisateursEnAttente.length - 1 && <Divider />}
                                    </React.Fragment>
                                ))}
                            </List>
                        ) : (
                            <Typography variant="body1" sx={{ mt: 2 }}>
                                Aucun utilisateur en attente
                            </Typography>
                        )}
                    </Paper>
                </Grid>

                {/* Activité récente */}
                <Grid item xs={12}>
                    <Paper sx={{ p: 2 }}>
                        <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <TrendingUpIcon color="primary" sx={{ mr: 1 }} />
                            <Typography variant="h6">
                                Activité récente
                            </Typography>
                        </Box>
                        <Typography variant="body1">
                            {stats.nouveauxUtilisateurs} nouveaux utilisateurs ces 5 derniers jours
                        </Typography>
                    </Paper>
                </Grid>
            </Grid>
        </Container>
    );
};

export default AdminDashboard;
Tableau de bord Médecin
Maintenant, développons le tableau de bord pour le médecin :

jsx
// src/pages/medecin/MedecinDashboard.jsx
import React, { useState, useEffect } from 'react';
import {
    Container,
    Grid,
    Paper,
    Typography,
    Box,
    Card,
    CardContent,
    Divider,
    List,
    ListItem,
    ListItemText,
    CircularProgress,
    Button
} from '@mui/material';
import {
    Today as TodayIcon,
    Person as PersonIcon,
    Assignment as AssignmentIcon
} from '@mui/icons-material';
import { format } from 'date-fns';
import { fr } from 'date-fns/locale';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext';
import { getProchainRendezVous, getStatistiques } from '../../services/medecinService';

const MedecinDashboard = () => {
    const [prochainRendezVous, setProchainRendezVous] = useState([]);
    const [statistiques, setStatistiques] = useState({
        totalPatients: 0,
        totalConsultations: 0,
        rendezVousAujourdhui: 0
    });
    const [loading, setLoading] = useState(true);
    const { currentUser } = useAuth();
    const navigate = useNavigate();

    useEffect(() => {
        const fetchData = async () => {
            try {
                setLoading(true);
                const [rdvResponse, statsResponse] = await Promise.all([
                    getProchainRendezVous(currentUser.id),
                    getStatistiques(currentUser.id)
                ]);
                
                setProchainRendezVous(rdvResponse.data);
                setStatistiques(statsResponse.data);
            } catch (error) {
                console.error('Erreur lors du chargement des données:', error);
            } finally {
                setLoading(false);
            }
        };

        fetchData();
    }, [currentUser.id]);

    const navigateToRendezVous = () => {
        navigate('/medecin/rendez-vous');
    };

    const navigateToDossiers = () => {
        navigate('/medecin/dossiers');
    };

    if (loading) {
        return (
            <Container maxWidth="lg" sx={{ mt: 4, mb: 4, textAlign: 'center' }}>
                <CircularProgress />
            </Container>
        );
    }

    return (
        <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
            <Typography variant="h4" gutterBottom>
                Bienvenue, Dr. {currentUser.nom} {currentUser.prenom}
            </Typography>

            <Grid container spacing={3}>
                {/* Statistiques */}
                <Grid item xs={12} md={4}>
                    <Paper sx={{ p: 2, height: '100%' }}>
                        <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <AssignmentIcon color="primary" sx={{ mr: 1 }} />
                            <Typography variant="h6">
                                Vos statistiques
                            </Typography>
                        </Box>
                        <Divider sx={{ mb: 2 }} />
                        <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                            <Card variant="outlined">
                                <CardContent>
                                    <Typography variant="body2" color="text.secondary">
                                        Patients suivis
                                    </Typography>
                                    <Typography variant="h5">
                                        {statistiques.totalPatients}
                                    </Typography>
                                </CardContent>
                            </Card>
                            <Card variant="outlined">
                                <CardContent>
                                    <Typography variant="body2" color="text.secondary">
                                        Consultations effectuées
                                    </Typography>
                                    <Typography variant="h5">
                                        {statistiques.totalConsultations}
                                    </Typography>
                                </CardContent>
                            </Card>
                            <Card variant="outlined">
                                <CardContent>
                                    <Typography variant="body2" color="text.secondary">
                                        Rendez-vous aujourd'hui
                                    </Typography>
                                    <Typography variant="h5">
                                        {statistiques.rendezVousAujourdhui}
                                    </Typography>
                                </CardContent>
                            </Card>
                        </Box>
                    </Paper>
                </Grid>

                {/* Prochains rendez-vous */}
                <Grid item xs={12} md={8}>
                    <Paper sx={{ p: 2, height: '100%' }}>
                        <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 2 }}>
                            <Box sx={{ display: 'flex', alignItems: 'center' }}>
                                <TodayIcon color="primary" sx={{ mr: 1 }} />
                                <Typography variant="h6">
                                    Prochains rendez-vous
                                </Typography>
                            </Box>
                            <Button variant="outlined" size="small" onClick={navigateToRendezVous}>
                                Voir tous
                            </Button>
                        </Box>
                        <Divider sx={{ mb: 2 }} />
                        
                        {prochainRendezVous.length > 0 ? (
                            <List>
                                {prochainRendezVous.map((rdv, index) => (
                                    <React.Fragment key={rdv.id}>
                                        <ListItem>
                                            <ListItemText
                                                primary={
                                                    <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                                                        <Typography variant="body1">
                                                            {rdv.patient.nom} {rdv.patient.prenom}
                                                        </Typography>
                                                        <Typography variant="body2" color="text.secondary">
                                                            {format(new Date(rdv.dateHeure), 'EEEE d MMMM yyyy', { locale: fr })}
                                                        </Typography>
                                                    </Box>
                                                }
                                                secondary={
                                                    <Box>
                                                        <Typography variant="body2">
                                                            {format(new Date(rdv.dateHeure), 'HH:mm')} - {rdv.motif}
                                                        </Typography>
                                                    </Box>
                                                }
                                            />
                                        </ListItem>
                                        {index < prochainRendezVous.length - 1 && <Divider />}
                                    </React.Fragment>
                                ))}
                            </List>
                        ) : (
                            <Typography variant="body1">
                                Aucun rendez-vous à venir.
                            </Typography>
                        )}
                    </Paper>
                </Grid>

                {/* Accès rapides */}
                <Grid item xs={12}>
                    <Paper sx={{ p: 2 }}>
                        <Typography variant="h6" gutterBottom>
                            Accès rapides
                        </Typography>
                        <Box sx={{ display: 'flex', gap: 2, mt: 2 }}>
                            <Button 
                                variant="contained" 
                                startIcon={<TodayIcon />}
                                onClick={navigateToRendezVous}
                            >
                                Gérer mes rendez-vous
                            </Button>
                            <Button 
                                variant="contained" 
                                startIcon={<PersonIcon />}
                                onClick={navigateToDossiers}
                            >
                                Consulter les dossiers médicaux
                            </Button>
                        </Box>
                    </Paper>
                </Grid>
            </Grid>
        </Container>
    );
};

export default MedecinDashboard;
Tableau de bord Patient
jsx
// src/pages/patient/PatientDashboard.jsx
import React, { useState, useEffect } from 'react';
import {
    Container,
    Grid,
    Paper,
    Typography,
    Box,
    Card,
    CardContent,
    Divider,
    List,
    ListItem,
    ListItemText,
    CircularProgress,
    Button,
    Chip
} from '@mui/material';
import {
    Today as TodayIcon,
    Folder as FolderIcon,
    CloudUpload as CloudUploadIcon,
    CheckCircle as CheckCircleIcon,
    Cancel as CancelIcon,
    Schedule as ScheduleIcon
} from '@mui/icons-material';
import { format } from 'date-fns';
import { fr } from 'date-fns/locale';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext';
import { getProchainRendezVous, getDossierInfo } from '../../services/patientService';

const PatientDashboard = () => {
    const [prochainRendezVous, setProchainRendezVous] = useState([]);
    const [dossierInfo, setDossierInfo] = useState({
        exists: false,
        nombreObservations: 0,
        nombreImages: 0,
        derniereMiseAJour: null
    });
    const [loading, setLoading] = useState(true);
    const { currentUser } = useAuth();
    const navigate = useNavigate();

    useEffect(() => {
        const fetchData = async () => {
            try {
                setLoading(true);
                const [rdvResponse, dossierResponse] = await Promise.all([
                    getProchainRendezVous(currentUser.id),
                    getDossierInfo(currentUser.id)
                ]);
                
                setProchainRendezVous(rdvResponse.data);
                setDossierInfo(dossierResponse.data);
            } catch (error) {
                console.error('Erreur lors du chargement des données:', error);
            } finally {
                setLoading(false);
            }
        };

        fetchData();
    }, [currentUser.id]);

    const navigateToRendezVous = () => {
        navigate('/patient/rendez-vous');
    };

    const navigateToDossier = () => {
        navigate('/patient/dossier');
    };

    const navigateToUpload = () => {
        navigate('/patient/upload');
    };

    const getChipByStatus = (status) => {
        switch (status) {
            case 'PLANIFIE':
                return <Chip icon={<ScheduleIcon />} label="Planifié" color="warning" size="small" />;
            case 'VALIDE':
                return <Chip icon={<CheckCircleIcon />} label="Validé" color="success" size="small" />;
            case 'REJETE':
                return <Chip icon={<CancelIcon />} label="Rejeté" color="error" size="small" />;
            default:
                return null;
        }
    };

    if (loading) {
        return (
            <Container maxWidth="lg" sx={{ mt: 4, mb: 4, textAlign: 'center' }}>
                <CircularProgress />
            </Container>
        );
    }

    return (
        <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
            <Typography variant="h4" gutterBottom>
                Bienvenue, {currentUser.prenom} {currentUser.nom}
            </Typography>

            <Grid container spacing={3}>
                {/* Prochains rendez-vous */}
                <Grid item xs={12} md={8}>
                    <Paper sx={{ p: 2, height: '100%' }}>
                        <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 2 }}>
                            <Box sx={{ display: 'flex', alignItems: 'center' }}>
                                <TodayIcon color="primary" sx={{ mr: 1 }} />
                                <Typography variant="h6">
                                    Vos prochains rendez-vous
                                </Typography>
                            </Box>
                            <Button variant="outlined" size="small" onClick={navigateToRendezVous}>
                                Voir tous
                            </Button>
                        </Box>
                        <Divider sx={{ mb: 2 }} />
                        
                        {prochainRendezVous.length > 0 ? (
                            <List>
                                {prochainRendezVous.map((rdv, index) => (
                                    <React.Fragment key={rdv.id}>
                                        <ListItem>
                                            <ListItemText
                                                primary={
                                                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                        <Typography variant="body1">
                                                            Dr. {rdv.medecin.nom} {rdv.medecin.prenom}
                                                        </Typography>
                                                        {getChipByStatus(rdv.statut)}
                                                    </Box>
                                                }
                                                secondary={
                                                    <Box>
                                                        <Typography variant="body2">
                                                            {format(new Date(rdv.dateHeure), 'EEEE d MMMM yyyy à HH:mm', { locale: fr })}
                                                        </Typography>
                                                        <Typography variant="body2" color="text.secondary">
                                                            {rdv.motif}
                                                        </Typography>
                                                    </Box>
                                                }
                                            />
                                        </ListItem>
                                        {index < prochainRendezVous.length - 1 && <Divider />}
                                    </React.Fragment>
                                ))}
                            </List>
                        ) : (
                            <Typography variant="body1">
                                Vous n'avez pas de rendez-vous à venir.
                            </Typography>
                        )}
                    </Paper>
                </Grid>

                {/* Dossier médical */}
                <Grid item xs={12} md={4}>
                    <Paper sx={{ p: 2, height: '100%' }}>
                        <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <FolderIcon color="primary" sx={{ mr: 1 }} />
                            <Typography variant="h6">
                                Votre dossier médical
                            </Typography>
                        </Box>
                        <Divider sx={{ mb: 2 }} />
                        
                        {dossierInfo.exists ? (
                            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                                <Card variant="outlined">
                                    <CardContent>
                                        <Typography variant="body2" color="text.secondary">
                                            Observations
                                        </Typography>
                                        <Typography variant="h5">
                                            {dossierInfo.nombreObservations}
                                        </Typography>
                                    </CardContent>
                                </Card>
                                <Card variant="outlined">
                                    <CardContent>
                                        <Typography variant="body2" color="text.secondary">
                                            Images médicales
                                        </Typography>
                                        <Typography variant="h5">
                                            {dossierInfo.nombreImages}
                                        </Typography>
                                    </CardContent>
                                </Card>
                                {dossierInfo.derniereMiseAJour && (
                                    <Typography variant="body2" color="text.secondary">
                                        Dernière mise à jour: {format(new Date(dossierInfo.derniereMiseAJour), 'dd/MM/yyyy')}
                                    </Typography>
                                )}
                                <Button 
                                    variant="contained" 
                                    fullWidth
                                    onClick={navigateToDossier}
                                >
                                    Consulter mon dossier
                                </Button>
                            </Box>
                        ) : (
                            <Typography variant="body1">
                                Vous n'avez pas encore de dossier médical.
                            </Typography>
                        )}
                    </Paper>
                </Grid>

                {/* Accès rapides */}
                <Grid item xs={12}>
                    <Paper sx={{ p: 2 }}>
                        <Typography variant="h6" gutterBottom>
                            Actions rapides
                        </Typography>
                        <Box sx={{ display: 'flex', gap: 2, mt: 2 }}>
                            <Button 
                                variant="contained" 
                                startIcon={<TodayIcon />}
                                onClick={navigateToRendezVous}
                            >
                                Mes rendez-vous
                            </Button>
                            <Button 
                                variant="contained" 
                                startIcon={<FolderIcon />}
                                onClick={navigateToDossier}
                                disabled={!dossierInfo.exists}
                            >
                                Mon dossier médical
                            </Button>
                            <Button 
                                variant="contained" 
                                startIcon={<CloudUploadIcon />}
                                onClick={navigateToUpload}
                            >
                                Téléverser une image DICOM
                            </Button>
                        </Box>
                    </Paper>
                </Grid>
            </Grid>
        </Container>
    );
};

export default PatientDashboard;
Tableau de bord Secrétaire
jsx
// src/pages/secretaire/SecretaireDashboard.jsx
import React, { useState, useEffect } from 'react';
import {
    Container,
    Grid,
    Paper,
    Typography,
    Box,
    Divider,
    List,
    ListItem,
    ListItemText,
    CircularProgress,
    Button,
    TextField,
    InputAdornment
} from '@mui/material';
import {
    Today as TodayIcon,
    Search as SearchIcon,
    Add as AddIcon,
    Schedule as ScheduleIcon
} from '@mui/icons-material';
import { format } from 'date-fns';
import { fr } from 'date-fns/locale';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext';
import { getRendezVousAujourdhui, getStats } from '../../services/secretaireService';

const SecretaireDashboard = () => {
    const [rendezVousAujourdhui, setRendezVousAujourdhui] = useState([



Continuer

Modifier
Poursuivons avec le tableau de bord du secrétaire :

jsx
// src/pages/secretaire/SecretaireDashboard.jsx (suite)
const SecretaireDashboard = () => {
    const [rendezVousAujourdhui, setRendezVousAujourdhui] = useState([]);
    const [stats, setStats] = useState({
        totalRendezVous: 0,
        rendezVousEnAttente: 0,
        rendezVousValides: 0,
        rendezVousRejetes: 0
    });
    const [searchQuery, setSearchQuery] = useState('');
    const [loading, setLoading] = useState(true);
    const { currentUser } = useAuth();
    const navigate = useNavigate();

    useEffect(() => {
        const fetchData = async () => {
            try {
                setLoading(true);
                const [rdvResponse, statsResponse] = await Promise.all([
                    getRendezVousAujourdhui(),
                    getStats()
                ]);
                
                setRendezVousAujourdhui(rdvResponse.data);
                setStats(statsResponse.data);
            } catch (error) {
                console.error('Erreur lors du chargement des données:', error);
            } finally {
                setLoading(false);
            }
        };

        fetchData();
    }, []);

    const navigateToRendezVous = () => {
        navigate('/secretaire/rendez-vous');
    };

    const navigateToNouveauRendezVous = () => {
        navigate('/secretaire/rendez-vous/nouveau');
    };

    const navigateToRecherchePatient = () => {
        navigate('/secretaire/patients', { state: { searchQuery } });
    };

    const handleSearchChange = (e) => {
        setSearchQuery(e.target.value);
    };

    const handleSearchSubmit = (e) => {
        e.preventDefault();
        if (searchQuery.trim()) {
            navigateToRecherchePatient();
        }
    };

    if (loading) {
        return (
            <Container maxWidth="lg" sx={{ mt: 4, mb: 4, textAlign: 'center' }}>
                <CircularProgress />
            </Container>
        );
    }

    return (
        <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
            <Typography variant="h4" gutterBottom>
                Bienvenue, {currentUser.prenom} {currentUser.nom}
            </Typography>

            <Grid container spacing={3}>
                {/* Recherche rapide */}
                <Grid item xs={12}>
                    <Paper sx={{ p: 2 }}>
                        <form onSubmit={handleSearchSubmit}>
                            <TextField
                                fullWidth
                                placeholder="Rechercher un patient par nom, prénom ou email..."
                                value={searchQuery}
                                onChange={handleSearchChange}
                                InputProps={{
                                    startAdornment: (
                                        <InputAdornment position="start">
                                            <SearchIcon />
                                        </InputAdornment>
                                    ),
                                    endAdornment: (
                                        <InputAdornment position="end">
                                            <Button 
                                                variant="contained"
                                                type="submit"
                                                disabled={!searchQuery.trim()}
                                            >
                                                Rechercher
                                            </Button>
                                        </InputAdornment>
                                    )
                                }}
                            />
                        </form>
                    </Paper>
                </Grid>

                {/* Statistiques */}
                <Grid item xs={12} md={4}>
                    <Paper sx={{ p: 2, height: '100%' }}>
                        <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <ScheduleIcon color="primary" sx={{ mr: 1 }} />
                            <Typography variant="h6">
                                État des rendez-vous
                            </Typography>
                        </Box>
                        <Divider sx={{ mb: 2 }} />
                        <List>
                            <ListItem>
                                <ListItemText
                                    primary="Total des rendez-vous"
                                    secondary={stats.totalRendezVous}
                                />
                            </ListItem>
                            <Divider />
                            <ListItem>
                                <ListItemText
                                    primary="En attente de validation"
                                    secondary={stats.rendezVousEnAttente}
                                />
                            </ListItem>
                            <Divider />
                            <ListItem>
                                <ListItemText
                                    primary="Validés"
                                    secondary={stats.rendezVousValides}
                                />
                            </ListItem>
                            <Divider />
                            <ListItem>
                                <ListItemText
                                    primary="Rejetés"
                                    secondary={stats.rendezVousRejetes}
                                />
                            </ListItem>
                        </List>
                        <Box sx={{ mt: 2 }}>
                            <Button 
                                variant="contained" 
                                fullWidth 
                                startIcon={<AddIcon />}
                                onClick={navigateToNouveauRendezVous}
                            >
                                Nouveau rendez-vous
                            </Button>
                        </Box>
                    </Paper>
                </Grid>

                {/* Rendez-vous du jour */}
                <Grid item xs={12} md={8}>
                    <Paper sx={{ p: 2, height: '100%' }}>
                        <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 2 }}>
                            <Box sx={{ display: 'flex', alignItems: 'center' }}>
                                <TodayIcon color="primary" sx={{ mr: 1 }} />
                                <Typography variant="h6">
                                    Rendez-vous d'aujourd'hui
                                </Typography>
                            </Box>
                            <Button variant="outlined" size="small" onClick={navigateToRendezVous}>
                                Gérer tous les rendez-vous
                            </Button>
                        </Box>
                        <Divider sx={{ mb: 2 }} />
                        
                        {rendezVousAujourdhui.length > 0 ? (
                            <List>
                                {rendezVousAujourdhui.map((rdv, index) => (
                                    <React.Fragment key={rdv.id}>
                                        <ListItem>
                                            <ListItemText
                                                primary={
                                                    <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                                                        <Typography variant="body1">
                                                            {rdv.patient.nom} {rdv.patient.prenom}
                                                        </Typography>
                                                        <Typography variant="body2" color="text.secondary">
                                                            {format(new Date(rdv.dateHeure), 'HH:mm')}
                                                        </Typography>
                                                    </Box>
                                                }
                                                secondary={
                                                    <Box>
                                                        <Typography variant="body2">
                                                            Dr. {rdv.medecin.nom} {rdv.medecin.prenom} ({rdv.medecin.specialite})
                                                        </Typography>
                                                        <Typography variant="body2" color="text.secondary">
                                                            {rdv.motif}
                                                        </Typography>
                                                    </Box>
                                                }
                                            />
                                        </ListItem>
                                        {index < rendezVousAujourdhui.length - 1 && <Divider />}
                                    </React.Fragment>
                                ))}
                            </List>
                        ) : (
                            <Typography variant="body1">
                                Aucun rendez-vous prévu aujourd'hui.
                            </Typography>
                        )}
                    </Paper>
                </Grid>

                {/* Accès rapides */}
                <Grid item xs={12}>
                    <Paper sx={{ p: 2 }}>
                        <Typography variant="h6" gutterBottom>
                            Accès rapides
                        </Typography>
                        <Box sx={{ display: 'flex', gap: 2, mt: 2 }}>
                            <Button 
                                variant="contained" 
                                startIcon={<AddIcon />}
                                onClick={navigateToNouveauRendezVous}
                            >
                                Nouveau rendez-vous
                            </Button>
                            <Button 
                                variant="contained" 
                                startIcon={<TodayIcon />}
                                onClick={navigateToRendezVous}
                            >
                                Gérer les rendez-vous
                            </Button>
                        </Box>
                    </Paper>
                </Grid>
            </Grid>
        </Container>
    );
};

export default SecretaireDashboard;
Services pour les tableaux de bord
Maintenant, créons les services nécessaires pour les tableaux de bord.

1. Service Médecin
javascript
// src/services/medecinService.js
import axios from 'axios';
import { API_URL } from '../config';

// Obtenir les prochains rendez-vous du médecin
export const getProchainRendezVous = (medecinId) => {
    return axios.get(`${API_URL}/medecin/${medecinId}/rendez-vous/prochains`);
};

// Obtenir les statistiques du médecin
export const getStatistiques = (medecinId) => {
    return axios.get(`${API_URL}/medecin/${medecinId}/statistiques`);
};

// Obtenir tous les rendez-vous du médecin
export const getAllRendezVous = (medecinId) => {
    return axios.get(`${API_URL}/medecin/${medecinId}/rendez-vous`);
};

// Valider un rendez-vous
export const validerRendezVous = (rendezVousId) => {
    return axios.put(`${API_URL}/rendez-vous/${rendezVousId}/valider`);
};

// Rejeter un rendez-vous
export const rejeterRendezVous = (rendezVousId) => {
    return axios.put(`${API_URL}/rendez-vous/${rendezVousId}/rejeter`);
};

// Obtenir les dossiers médicaux des patients du médecin
export const getDossiersMedicaux = (medecinId) => {
    return axios.get(`${API_URL}/medecin/${medecinId}/dossiers`);
};

// Obtenir un dossier médical spécifique
export const getDossierMedical = (dossierId) => {
    return axios.get(`${API_URL}/dossiers/${dossierId}`);
};

// Ajouter une observation à un dossier médical
export const ajouterObservation = (dossierId, observation) => {
    return axios.post(`${API_URL}/dossiers/${dossierId}/observations`, observation);
};
2. Service Patient
javascript
// src/services/patientService.js
import axios from 'axios';
import { API_URL } from '../config';

// Obtenir les prochains rendez-vous du patient
export const getProchainRendezVous = (patientId) => {
    return axios.get(`${API_URL}/patient/${patientId}/rendez-vous/prochains`);
};

// Obtenir les informations du dossier médical
export const getDossierInfo = (patientId) => {
    return axios.get(`${API_URL}/patient/${patientId}/dossier/info`);
};

// Obtenir le dossier médical complet
export const getDossierMedical = (patientId) => {
    return axios.get(`${API_URL}/patient/${patientId}/dossier`);
};

// Obtenir tous les rendez-vous du patient
export const getAllRendezVous = (patientId) => {
    return axios.get(`${API_URL}/patient/${patientId}/rendez-vous`);
};

// Téléverser une image DICOM
export const uploadDicomImage = (dossierId, formData) => {
    return axios.post(`${API_URL}/dicom/upload/${dossierId}`, formData, {
        headers: {
            'Content-Type': 'multipart/form-data'
        }
    });
};
3. Service Secrétaire
javascript
// src/services/secretaireService.js
import axios from 'axios';
import { API_URL } from '../config';

// Obtenir les rendez-vous du jour
export const getRendezVousAujourdhui = () => {
    return axios.get(`${API_URL}/secretaire/rendez-vous/aujourd-hui`);
};

// Obtenir les statistiques des rendez-vous
export const getStats = () => {
    return axios.get(`${API_URL}/secretaire/statistiques`);
};

// Obtenir tous les rendez-vous
export const getAllRendezVous = () => {
    return axios.get(`${API_URL}/secretaire/rendez-vous`);
};

// Créer un nouveau rendez-vous
export const createRendezVous = (rendezVousData) => {
    return axios.post(`${API_URL}/rendez-vous`, rendezVousData);
};

// Mettre à jour un rendez-vous
export const updateRendezVous = (rendezVousId, rendezVousData) => {
    return axios.put(`${API_URL}/rendez-vous/${rendezVousId}`, rendezVousData);
};

// Supprimer un rendez-vous
export const deleteRendezVous = (rendezVousId) => {
    return axios.delete(`${API_URL}/rendez-vous/${rendezVousId}`);
};

// Rechercher des patients
export const searchPatients = (query) => {
    return axios.get(`${API_URL}/secretaire/patients/search?q=${query}`);
};

// Rechercher des médecins
export const searchMedecins = (query) => {
    return axios.get(`${API_URL}/secretaire/medecins/search?q=${query}`);
};
Intégration dans les layouts
Maintenant, nous devons mettre à jour les layouts de chaque type d'utilisateur pour inclure ces tableaux de bord :

1. MedecinLayout.jsx
jsx
import React from 'react';
import { Routes, Route } from 'react-router-dom';
import { Box, CssBaseline } from '@mui/material';
import MedecinDashboard from '../../pages/medecin/MedecinDashboard';
import NotFound from '../../pages/NotFound';

// Importez ici les autres pages du médecin lorsqu'elles seront créées

const MedecinLayout = () => {
    return (
        <Box sx={{ display: 'flex' }}>
            <CssBaseline />
            {/* Ici nous ajouterons l'en-tête et la barre latérale du médecin dans la prochaine phase */}
            <Box
                component="main"
                sx={{
                    flexGrow: 1,
                    height: '100vh',
                    overflow: 'auto',
                    padding: (theme) => theme.spacing(3),
                    paddingTop: '64px', // Hauteur de l'en-tête
                }}
            >
                <Routes>
                    <Route path="dashboard" element={<MedecinDashboard />} />
                    {/* Ajoutez ici les autres routes du médecin */}
                    <Route path="*" element={<NotFound />} />
                </Routes>
            </Box>
        </Box>
    );
};

export default MedecinLayout;
2. PatientLayout.jsx
jsx
import React from 'react';
import { Routes, Route } from 'react-router-dom';
import { Box, CssBaseline } from '@mui/material';
import PatientDashboard from '../../pages/patient/PatientDashboard';
import NotFound from '../../pages/NotFound';

// Importez ici les autres pages du patient lorsqu'elles seront créées

const PatientLayout = () => {
    return (
        <Box sx={{ display: 'flex' }}>
            <CssBaseline />
            {/* Ici nous ajouterons l'en-tête et la barre latérale du patient dans la prochaine phase */}
            <Box
                component="main"
                sx={{
                    flexGrow: 1,
                    height: '100vh',
                    overflow: 'auto',
                    padding: (theme) => theme.spacing(3),
                    paddingTop: '64px', // Hauteur de l'en-tête
                }}
            >
                <Routes>
                    <Route path="dashboard" element={<PatientDashboard />} />
                    {/* Ajoutez ici les autres routes du patient */}
                    <Route path="*" element={<NotFound />} />
                </Routes>
            </Box>
        </Box>
    );
};

export default PatientLayout;
3. SecretaireLayout.jsx
jsx
import React from 'react';
import { Routes, Route } from 'react-router-dom';
import { Box, CssBaseline } from '@mui/material';
import SecretaireDashboard from '../../pages/secretaire/SecretaireDashboard';
import NotFound from '../../pages/NotFound';

// Importez ici les autres pages du secrétaire lorsqu'elles seront créées

const SecretaireLayout = () => {
    return (
        <Box sx={{ display: 'flex' }}>
            <CssBaseline />
            {/* Ici nous ajouterons l'en-tête et la barre latérale du secrétaire dans la prochaine phase */}
            <Box
                component="main"
                sx={{
                    flexGrow: 1,
                    height: '100vh',
                    overflow: 'auto',
                    padding: (theme) => theme.spacing(3),
                    paddingTop: '64px', // Hauteur de l'en-tête
                }}
            >
                <Routes>
                    <Route path="dashboard" element={<SecretaireDashboard />} />
                    {/* Ajoutez ici les autres routes du secrétaire */}
                    <Route path="*" element={<NotFound />} />
                </Routes>
            </Box>
        </Box>
    );
};

export default SecretaireLayout;
Avec ces composants, nous avons maintenant un tableau de bord pour chaque type d'utilisateur, affichant des informations pertinentes et des actions rapides. Dans la Phase 4, nous développerons les fonctionnalités de gestion des rendez-vous et ajouterons les en-têtes et barres latérales pour chaque type d'utilisateur.




en me connectant sur le tableau de bord du medecin j'ai ça : 
AuthContext.js:20 AuthContext: Token au chargement: Présent
AuthContext.js:26 AuthContext: Token décodé: Object
AuthContext.js:32 AuthContext: Token valide, expiration: 09/05/2025 16:13:06
hook.js:377 AuthContext: Token au chargement: Présent
hook.js:377 AuthContext: Token décodé: Object
hook.js:377 AuthContext: Token valide, expiration: 09/05/2025 16:13:06
hook.js:608 MUI Grid: The item prop has been removed and is no longer necessary. You can safely remove it.
overrideMethod @ hook.js:608
Login.jsx:42 Login.jsx: Tentative de connexion avec: Object
AuthContext.js:70 AuthContext: Tentative de connexion avec: Object
AuthContext.js:73 AuthContext: Réponse brute de l'API: Object
AuthContext.js:77 AuthContext: Données extraites: Object
AuthContext.js:97 AuthContext: Utilisateur connecté: Object
AuthContext.js:98 AuthContext: Rôle défini: ROLE_MEDECIN
Login.jsx:45 Login.jsx: Résultat de la connexion: Object
Login.jsx:48 Login.jsx: Connexion réussie, redirection...
:8080/api/medecin/1/rendez-vous/prochains:1 

           Failed to load resource: the server responded with a status of 401 ()
hook.js:608 Erreur lors du chargement des données: AxiosError
overrideMethod @ hook.js:608
hook.js:608 MUI Grid: The xs prop has been removed. See https://mui.com/material-ui/migration/upgrade-to-grid-v2/ for migration instructions.
overrideMethod @ hook.js:608
hook.js:608 MUI Grid: The md prop has been removed. See https://mui.com/material-ui/migration/upgrade-to-grid-v2/ for migration instructions.
overrideMethod @ hook.js:608
:8080/api/medecin/1/statistiques:1 

           Failed to load resource: the server responded with a status of 401 ()
:8080/api/medecin/1/rendez-vous/prochains:1 

           Failed to load resource: the server responded with a status of 401 ()
hook.js:608 Erreur lors du chargement des données: AxiosError
overrideMethod @ hook.js:608
:8080/api/medecin/1/statistiques:1 

           Failed to load resource: the server responded with a status of 401 ()

Modifier
Il semble que vous rencontrez des erreurs 401 (Non autorisé) lorsque vous essayez d'accéder aux endpoints du médecin. Cette erreur indique que les requêtes API ne sont pas correctement authentifiées avec le token JWT.

Voici comment résoudre ce problème :

1. Vérifier le token JWT dans les requêtes
Assurez-vous que le token JWT est correctement envoyé dans l'en-tête Authorization de vos requêtes. Dans votre service medecinService.js, modifiez les fonctions comme suit :

javascript
// src/services/medecinService.js
import axios from 'axios';
import { API_URL } from '../config';

// Fonction d'aide pour inclure le token JWT dans toutes les requêtes
const getAuthHeader = () => {
  const token = localStorage.getItem('token');
  return {
    headers: {
      'Authorization': `Bearer ${token}`
    }
  };
};

// Obtenir les prochains rendez-vous du médecin
export const getProchainRendezVous = (medecinId) => {
  return axios.get(`${API_URL}/medecin/${medecinId}/rendez-vous/prochains`, getAuthHeader());
};

// Obtenir les statistiques du médecin
export const getStatistiques = (medecinId) => {
  return axios.get(`${API_URL}/medecin/${medecinId}/statistiques`, getAuthHeader());
};

// Autres fonctions...
2. Configurer l'intercepteur Axios
Une meilleure approche serait de configurer un intercepteur Axios qui ajoutera automatiquement le token à toutes les requêtes. Créez un fichier src/services/api.js :

javascript
// src/services/api.js
import axios from 'axios';
import { API_URL } from '../config';

const api = axios.create({
  baseURL: API_URL
});

// Intercepteur pour ajouter le token JWT à toutes les requêtes
api.interceptors.request.use(
  config => {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  error => {
    return Promise.reject(error);
  }
);

export default api;
Ensuite, modifiez tous vos services pour utiliser cette instance d'API :

javascript
// src/services/medecinService.js
import api from './api';

// Obtenir les prochains rendez-vous du médecin
export const getProchainRendezVous = (medecinId) => {
  return api.get(`/medecin/${medecinId}/rendez-vous/prochains`);
};

// Obtenir les statistiques du médecin
export const getStatistiques = (medecinId) => {
  return api.get(`/medecin/${medecinId}/statistiques`);
};

// Autres fonctions...
3. Vérifier le format du token et le contexte d'authentification
Assurez-vous que le token est correctement stocké dans localStorage après la connexion. Dans votre fonction handleLogin dans AuthContext.js :

javascript
const handleLogin = async (email, password) => {
  try {
    const response = await login(email, password);
    
    if (response && response.data) {
      const { token, id, email: userEmail, nom, prenom, roles } = response.data;
      
      // Débogage pour vérifier le token
      console.log("Token reçu:", token);
      
      // Stocker le token
      localStorage.setItem('token', token);
      
      // Mise à jour du contexte...
    }
  } catch (error) {
    // Gestion des erreurs...
  }
};
4. Vérifier le backend
Si le problème persiste, vérifiez côté backend :

Assurez-vous que les endpoints /medecin/{id}/... existent et sont correctement configurés
Vérifiez les configurations de Spring Security pour autoriser les accès authentifiés à ces endpoints
Vérifiez que votre filtre JWT fonctionne correctement et qu'il extrait bien les informations d'authentification du token
5. Vérifier les IDs utilisés
Il y a une autre possibilité : vous tentez d'accéder aux rendez-vous du médecin avec l'ID 1, mais il est possible que l'ID du médecin connecté soit différent. Vérifiez que vous utilisez le bon ID :

javascript
// Dans MedecinDashboard.jsx
useEffect(() => {
  const fetchData = async () => {
    try {
      setLoading(true);
      // Débogage pour vérifier l'ID
      console.log("ID du médecin:", currentUser.id);
      
      const [rdvResponse, statsResponse] = await Promise.all([
        getProchainRendezVous(currentUser.id),
        getStatistiques(currentUser.id)
      ]);
      
      // Suite du code...
    } catch (error) {
      // Gestion des erreurs...
    }
  };

  fetchData();
}, [currentUser.id]);
Si vous identifiez que le problème est lié à l'ID, vous pouvez ajuster la façon dont vous récupérez l'ID du médecin connecté.

Ces modifications devraient vous aider à résoudre les erreurs 401 que vous rencontrez. Si le problème persiste après ces changements, n'hésitez pas à fournir plus de détails sur la configuration de votre backend et le format des réponses d'authentification.




j'ai créé le fichier api.js et voici medecinService.js :
// src/services/medecinService.js
import axios from 'axios';
import { API_URL } from '../Config';

// Obtenir les prochains rendez-vous du médecin
export const getProchainRendezVous = (medecinId) => {
    return axios.get(${API_URL}/medecin/${medecinId}/rendez-vous/prochains);
};

// Obtenir les statistiques du médecin
export const getStatistiques = (medecinId) => {
    return axios.get(${API_URL}/medecin/${medecinId}/statistiques);
};

// Obtenir tous les rendez-vous du médecin
export const getAllRendezVous = (medecinId) => {
    return axios.get(${API_URL}/medecin/${medecinId}/rendez-vous);
};

// Valider un rendez-vous
export const validerRendezVous = (rendezVousId) => {
    return axios.put(${API_URL}/rendez-vous/${rendezVousId}/valider);
};

// Rejeter un rendez-vous
export const rejeterRendezVous = (rendezVousId) => {
    return axios.put(${API_URL}/rendez-vous/${rendezVousId}/rejeter);
};

// Obtenir les dossiers médicaux des patients du médecin
export const getDossiersMedicaux = (medecinId) => {
    return axios.get(${API_URL}/medecin/${medecinId}/dossiers);
};

// Obtenir un dossier médical spécifique
export const getDossierMedical = (dossierId) => {
    return axios.get(${API_URL}/dossiers/${dossierId});
};

// Ajouter une observation à un dossier médical
export const ajouterObservation = (dossierId, observation) => {
    return axios.post(${API_URL}/dossiers/${dossierId}/observations, observation);
};

Modifier
Il semble que votre fichier medecinService.js utilise toujours directement axios au lieu de l'instance api que vous avez créée. Vous devez modifier ce fichier pour utiliser l'instance api qui contient l'intercepteur d'authentification.

Voici comment vous devriez modifier votre fichier medecinService.js :

javascript
// src/services/medecinService.js
import api from './api';

// Obtenir les prochains rendez-vous du médecin
export const getProchainRendezVous = (medecinId) => {
    return api.get(`/medecin/${medecinId}/rendez-vous/prochains`);
};

// Obtenir les statistiques du médecin
export const getStatistiques = (medecinId) => {
    return api.get(`/medecin/${medecinId}/statistiques`);
};

// Obtenir tous les rendez-vous du médecin
export const getAllRendezVous = (medecinId) => {
    return api.get(`/medecin/${medecinId}/rendez-vous`);
};

// Valider un rendez-vous
export const validerRendezVous = (rendezVousId) => {
    return api.put(`/rendez-vous/${rendezVousId}/valider`);
};

// Rejeter un rendez-vous
export const rejeterRendezVous = (rendezVousId) => {
    return api.put(`/rendez-vous/${rendezVousId}/rejeter`);
};

// Obtenir les dossiers médicaux des patients du médecin
export const getDossiersMedicaux = (medecinId) => {
    return api.get(`/medecin/${medecinId}/dossiers`);
};

// Obtenir un dossier



comment vérifier que les endpoints existent et sont correctement configurés

Modifier
Pour vérifier que les endpoints existent et sont correctement configurés dans votre application Spring Boot, vous pouvez suivre plusieurs approches :

1. Vérification via l'API Actuator
Si vous avez inclus Spring Boot Actuator dans votre projet, vous pouvez utiliser l'endpoint /actuator/mappings pour voir tous les mappings d'URL disponibles :

Ajoutez la dépendance Actuator si ce n'est pas déjà fait :
xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
Configurez Actuator pour exposer les mappings dans application.properties :
properties
management.endpoints.web.exposure.include=mappings
Accédez à http://localhost:8080/actuator/mappings dans votre navigateur ou via Postman.
2. Listez les contrôleurs et leurs méthodes
Examinez vos contrôleurs pour vous assurer que tous les endpoints nécessaires sont définis :

java
@RestController
@RequestMapping("/api/medecin")
public class MedecinController {
    
    @GetMapping("/{medecinId}/rendez-vous/prochains")
    public ResponseEntity<List<RendezVous>> getProchainRendezVous(@PathVariable Long medecinId) {
        // Implémentation...
    }
    
    @GetMapping("/{medecinId}/statistiques")
    public ResponseEntity<Map<String, Object>> getStatistiques(@PathVariable Long medecinId) {
        // Implémentation...
    }
    
    // Autres méthodes...
}
3. Tester directement avec Postman ou curl
Vous pouvez tester manuellement vos endpoints avec Postman ou curl pour vérifier qu'ils fonctionnent comme prévu :

bash
# Exemple avec curl (inclure le token JWT)
curl -X GET "http://localhost:8080/api/medecin/1/rendez-vous/prochains" \
     -H "Authorization: Bearer votre_token_jwt"
4. Débogage du côté serveur
Ajoutez des points de débogage ou des logs dans vos contrôleurs et filtres pour voir ce qui se passe lorsqu'une requête arrive :

java
@GetMapping("/{medecinId}/rendez-vous/prochains")
public ResponseEntity<List<RendezVous>> getProchainRendezVous(@PathVariable Long medecinId) {
    logger.info("Requête reçue pour les prochains rendez-vous du médecin {}", medecinId);
    // Reste du code...
}
5. Vérifier la configuration de sécurité
Assurez-vous que votre configuration Spring Security autorise les accès authentifiés à ces endpoints :

java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .cors().and().csrf().disable()
        .authorizeHttpRequests()
            .requestMatchers("/api/auth/**").permitAll()
            .requestMatchers("/api/medecin/**").hasRole("MEDECIN") // Vérifiez que cette ligne existe
            .anyRequest().authenticated()
        .and()
        // Autres configurations...
    
    return http.build();
}
6. Vérifier le filtre JWT
Assurez-vous que votre filtre JWT extrait correctement les informations d'authentification :

java
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
            throws ServletException, IOException {
        
        String token = getJwtFromRequest(request);
        
        // Pour le débogage
        if (token != null) {
            logger.info("Token trouvé dans la requête: {}", token);
            // Vérifier si le token est valide
            if (jwtTokenProvider.validateToken(token)) {
                logger.info("Token valide");
                // Reste du code...
            } else {
                logger.error("Token invalide");
            }
        } else {
            logger.warn("Aucun token trouvé dans la requête");
        }
        
        // Reste du code...
        chain.doFilter(request, response);
    }
    
    // Reste de la classe...
}
7. Implémenter des endpoints temporaires pour tester l'authentification
Vous pouvez créer des endpoints de test pour vérifier si l'authentification fonctionne correctement :

java
@RestController
@RequestMapping("/api/test")
public class TestController {
    
    @GetMapping("/public")
    public ResponseEntity<String> publicEndpoint() {
        return ResponseEntity.ok("Endpoint public accessible");
    }
    
    @GetMapping("/medecin")
    @PreAuthorize("hasRole('MEDECIN')")
    public ResponseEntity<String> medecinEndpoint() {
        return ResponseEntity.ok("Endpoint médecin accessible");
    }
    
    @GetMapping("/admin")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<String> adminEndpoint() {
        return ResponseEntity.ok("Endpoint admin accessible");
    }
}
8. Vérifier les logs Spring Security
Augmentez le niveau de log pour Spring Security afin de voir ce qui se passe lors de l'authentification :

properties
# Dans application.properties
logging.level.org.springframework.security=DEBUG
Ces méthodes vous aideront à identifier et résoudre les problèmes liés à vos endpoints et à l'authentification. Une fois que vous avez confirmé que les endpoints fonctionnent correctement avec Postman ou curl, vous pourrez revenir à votre frontend et résoudre les problèmes d'authentification.




ces endpoints n'existent pas encore dans mon backend

Modifier
Ah, c'est la source du problème ! Si les endpoints n'existent pas encore dans votre backend, les requêtes échoueront avec une erreur 401 (Non autorisé) ou 404 (Non trouvé).

Voyons comment implémenter les endpoints nécessaires pour le tableau de bord du médecin :

1. Créez les services et les contrôleurs nécessaires
MedecinService.java
java
package com.teleconsultation.api.service;

import com.teleconsultation.api.models.Medecin;
import com.teleconsultation.api.models.RendezVous;
import com.teleconsultation.api.models.StatutRendezVous;
import com.teleconsultation.api.repository.DossierMedicalRepository;
import com.teleconsultation.api.repository.MedecinRepository;
import com.teleconsultation.api.repository.RendezVousRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Service
public class MedecinService {

    @Autowired
    private MedecinRepository medecinRepository;
    
    @Autowired
    private RendezVousRepository rendezVousRepository;
    
    @Autowired
    private DossierMedicalRepository dossierMedicalRepository;
    
    public Medecin findById(Long id) {
        return medecinRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Médecin non trouvé avec l'ID: " + id));
    }
    
    public List<RendezVous> findProchainRendezVous(Long medecinId) {
        Medecin medecin = findById(medecinId);
        LocalDateTime now = LocalDateTime.now();
        
        // Récupérer les 5 prochains rendez-vous validés
        return rendezVousRepository.findTop5ByMedecinAndDateHeureAfterAndStatutOrderByDateHeureAsc(
                medecin, now, StatutRendezVous.VALIDE);
    }
    
    public Map<String, Object> getStatistiques(Long medecinId) {
        Medecin medecin = findById(medecinId);
        Map<String, Object> stats = new HashMap<>();
        
        // Nombre total de patients suivis
        long totalPatients = dossierMedicalRepository.countDistinctPatientsByMedecin(medecin);
        stats.put("totalPatients", totalPatients);
        
        // Nombre total de consultations (rendez-vous terminés)
        long totalConsultations = rendezVousRepository.countByMedecinAndStatut(medecin, StatutRendezVous.TERMINE);
        stats.put("totalConsultations", totalConsultations);
        
        // Nombre de rendez-vous aujourd'hui
        LocalDateTime startOfDay = LocalDateTime.now().withHour(0).withMinute(0).withSecond(0).withNano(0);
        LocalDateTime endOfDay = startOfDay.plusDays(1);
        
        long rendezVousAujourdhui = rendezVousRepository.countByMedecinAndDateHeureBetweenAndStatut(
                medecin, startOfDay, endOfDay, StatutRendezVous.VALIDE);
        stats.put("rendezVousAujourdhui", rendezVousAujourdhui);
        
        return stats;
    }
    
    public List<RendezVous> findAllRendezVous(Long medecinId) {
        Medecin medecin = findById(medecinId);
        return rendezVousRepository.findByMedecinOrderByDateHeureDesc(medecin);
    }
}
MedecinController.java
java
package com.teleconsultation.api.controllers;

import com.teleconsultation.api.models.RendezVous;
import com.teleconsultation.api.service.MedecinService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/medecin")
public class MedecinController {
    
    @Autowired
    private MedecinService medecinService;
    
    @GetMapping("/{medecinId}/rendez-vous/prochains")
    @PreAuthorize("hasRole('MEDECIN') and #medecinId == authentication.principal.id")
    public ResponseEntity<List<RendezVous>> getProchainRendezVous(@PathVariable Long medecinId) {
        List<RendezVous> rendezVous = medecinService.findProchainRendezVous(medecinId);
        return ResponseEntity.ok(rendezVous);
    }
    
    @GetMapping("/{medecinId}/statistiques")
    @PreAuthorize("hasRole('MEDECIN') and #medecinId == authentication.principal.id")
    public ResponseEntity<Map<String, Object>> getStatistiques(@PathVariable Long medecinId) {
        Map<String, Object> stats = medecinService.getStatistiques(medecinId);
        return ResponseEntity.ok(stats);
    }
    
    @GetMapping("/{medecinId}/rendez-vous")
    @PreAuthorize("hasRole('MEDECIN') and #medecinId == authentication.principal.id")
    public ResponseEntity<List<RendezVous>> getAllRendezVous(@PathVariable Long medecinId) {
        List<RendezVous> rendezVous = medecinService.findAllRendezVous(medecinId);
        return ResponseEntity.ok(rendezVous);
    }
}
2. Ajoutez les méthodes nécessaires dans les repositories
RendezVousRepository.java
java
package com.teleconsultation.api.repository;

import com.teleconsultation.api.models.Medecin;
import com.teleconsultation.api.models.RendezVous;
import com.teleconsultation.api.models.StatutRendezVous;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface RendezVousRepository extends JpaRepository<RendezVous, Long> {
    
    // Trouver les prochains rendez-vous d'un médecin
    List<RendezVous> findTop5ByMedecinAndDateHeureAfterAndStatutOrderByDateHeureAsc(
            Medecin medecin, LocalDateTime dateHeure, StatutRendezVous statut);
    
    // Compter les rendez-vous d'un médecin avec un statut donné
    long countByMedecinAndStatut(Medecin medecin, StatutRendezVous statut);
    
    // Compter les rendez-vous d'un médecin pour aujourd'hui
    long countByMedecinAndDateHeureBetweenAndStatut(
            Medecin medecin, LocalDateTime debut, LocalDateTime fin, StatutRendezVous statut);
    
    // Trouver tous les rendez-vous d'un médecin
    List<RendezVous> findByMedecinOrderByDateHeureDesc(Medecin medecin);
    
    // Compter les rendez-vous entre deux dates
    long countByDateHeureBetween(LocalDateTime debut, LocalDateTime fin);
}
DossierMedicalRepository.java
java
package com.teleconsultation.api.repository;

import com.teleconsultation.api.models.DossierMedical;
import com.teleconsultation.api.models.Medecin;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

@Repository
public interface DossierMedicalRepository extends JpaRepository<DossierMedical, Long> {
    
    // Compter le nombre distinct de patients pour un médecin
    @Query("SELECT COUNT(DISTINCT d.patient) FROM DossierMedical d WHERE d.medecin = ?1")
    long countDistinctPatientsByMedecin(Medecin medecin);
}
3. Créez des données de test temporaires
En attendant d'avoir des données réelles, vous pouvez créer des méthodes pour simuler les données dans votre service :

java
// Dans MedecinService.java, ajoutez ces méthodes pour les données simulées

public List<RendezVous> findProchainRendezVous(Long medecinId) {
    // Pour le moment, retournez une liste vide ou des données simulées
    return new ArrayList<>(); // Liste vide temporaire
}

public Map<String, Object> getStatistiques(Long medecinId) {
    // Données simulées pour le tableau de bord
    Map<String, Object> stats = new HashMap<>();
    stats.put("totalPatients", 0);
    stats.put("totalConsultations", 0);
    stats.put("rendezVousAujourdhui", 0);
    return stats;
}
4. Modifiez votre tableau de bord médecin pour gérer les cas où il n'y a pas de données
jsx
// Dans MedecinDashboard.jsx

const MedecinDashboard = () => {
    const [prochainRendezVous, setProchainRendezVous] = useState([]);
    const [statistiques, setStatistiques] = useState({
        totalPatients: 0,
        totalConsultations: 0,
        rendezVousAujourdhui: 0
    });
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const { currentUser } = useAuth();
    const navigate = useNavigate();

    useEffect(() => {
        const fetchData = async () => {
            try {
                setLoading(true);
                setError(null);
                
                // Pour le débogage
                console.log("ID du médecin:", currentUser?.id);
                
                // Si les endpoints n'existent pas encore, utilisez des données simulées
                // Sinon, utilisez vos services API
                
                // Exemple avec des données simulées
                setProchainRendezVous([]);
                setStatistiques({
                    totalPatients: 0,
                    totalConsultations: 0,
                    rendezVousAujourdhui: 0
                });
                
                /* Décommentez ce code lorsque les endpoints seront prêts
                const [rdvResponse, statsResponse] = await Promise.all([
                    getProchainRendezVous(currentUser.id),
                    getStatistiques(currentUser.id)
                ]);
                
                setProchainRendezVous(rdvResponse.data);
                setStatistiques(statsResponse.data);
                */
                
            } catch (error) {
                console.error('Erreur lors du chargement des données:', error);
                setError("Impossible de charger les données. Veuillez réessayer plus tard.");
            } finally {
                setLoading(false);
            }
        };

        fetchData();
    }, [currentUser?.id]);

    // Reste du code...
}
5. Vous pouvez aussi créer un contrôleur de test pour vérifier l'authentification
java
package com.teleconsultation.api.controllers;

import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/test")
public class TestController {
    
    @GetMapping("/public")
    public ResponseEntity<String> publicEndpoint() {
        return ResponseEntity.ok("Endpoint public accessible");
    }
    
    @GetMapping("/medecin")
    @PreAuthorize("hasRole('MEDECIN')")
    public ResponseEntity<String> medecinEndpoint() {
        return ResponseEntity.ok("Endpoint médecin accessible");
    }
    
    @GetMapping("/admin")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<String> adminEndpoint() {
        return ResponseEntity.ok("Endpoint admin accessible");
    }
}
Avec ces modifications, vous pourrez continuer à développer votre frontend tout en travaillant progressivement sur les endpoints du backend. Lorsque les endpoints seront prêts, vous pourrez simplement décommenter le code qui les utilise dans votre frontend.




allons d'abord dans la phase 4, nous y reviendrons après ça ne pose pas de problème bien sûr

Modifier
Parfait, nous pouvons passer à la Phase 4 et revenir plus tard à la Phase 3 lorsque le backend sera prêt. La Phase 4 concerne la gestion des rendez-vous.

Phase 4: Gestion des rendez-vous
Dans cette phase, nous allons développer les fonctionnalités de gestion des rendez-vous pour les différents types d'utilisateurs :

Le secrétaire médical peut planifier, modifier et supprimer des rendez-vous
Le médecin peut consulter, valider ou rejeter des rendez-vous
Le patient peut consulter ses rendez-vous validés
Commençons par développer les interfaces frontend nécessaires, puis nous créerons les services et contrôleurs backend correspondants.

1. Interface pour le secrétaire médical
src/pages/secretaire/GestionRendezVous.jsx
jsx
import React, { useState, useEffect } from 'react';
import {
    Container,
    Typography,
    Paper,
    Button,
    Dialog,
    DialogTitle,
    DialogContent,
    DialogActions,
    TextField,
    FormControl,
    InputLabel,
    Select,
    MenuItem,
    Grid,
    Snackbar,
    Alert,
    IconButton,
    Box,
    Tabs,
    Tab,
    Chip
} from '@mui/material';
import { DataGrid } from '@mui/x-data-grid';
import { DateTimePicker } from '@mui/x-date-pickers/DateTimePicker';
import { Add as AddIcon, Edit as EditIcon, Delete as DeleteIcon, Visibility as VisibilityIcon } from '@mui/icons-material';
import { format } from 'date-fns';
import { fr } from 'date-fns/locale';
import { 
    getAllRendezVous, 
    createRendezVous, 
    updateRendezVous, 
    deleteRendezVous 
} from '../../services/secretaireService';
import { searchMedecins } from '../../services/secretaireService';
import { searchPatients } from '../../services/secretaireService';

function TabPanel(props) {
    const { children, value, index, ...other } = props;
    return (
        <div
            role="tabpanel"
            hidden={value !== index}
            id={`rendez-vous-tabpanel-${index}`}
            aria-labelledby={`rendez-vous-tab-${index}`}
            {...other}
        >
            {value === index && <Box sx={{ p: 3 }}>{children}</Box>}
        </div>
    );
}

const GestionRendezVous = () => {
    const [rendezVous, setRendezVous] = useState([]);
    const [tabValue, setTabValue] = useState(0);
    const [medecins, setMedecins] = useState([]);
    const [patients, setPatients] = useState([]);
    const [dialogOpen, setDialogOpen] = useState(false);
    const [detailsDialogOpen, setDetailsDialogOpen] = useState(false);
    const [editMode, setEditMode] = useState(false);
    const [selectedRendezVous, setSelectedRendezVous] = useState(null);
    const [formData, setFormData] = useState({
        patientId: '',
        medecinId: '',
        dateHeure: null,
        duree: 30,
        motif: ''
    });
    const [searchQuery, setSearchQuery] = useState({
        medecin: '',
        patient: ''
    });
    const [loadingMedecins, setLoadingMedecins] = useState(false);
    const [loadingPatients, setLoadingPatients] = useState(false);
    const [loading, setLoading] = useState(true);
    const [snackbar, setSnackbar] = useState({
        open: false,
        message: '',
        severity: 'success'
    });

    useEffect(() => {
        fetchRendezVous();
    }, []);

    const fetchRendezVous = async () => {
        try {
            setLoading(true);
            const response = await getAllRendezVous();
            setRendezVous(response.data);
        } catch (error) {
            console.error('Erreur lors du chargement des rendez-vous:', error);
            showSnackbar('Erreur lors du chargement des données', 'error');
        } finally {
            setLoading(false);
        }
    };

    const handleTabChange = (event, newValue) => {
        setTabValue(newValue);
    };

    const handleOpenDialog = (mode, rendezVous = null) => {
        setEditMode(mode === 'edit');
        
        if (mode === 'edit' && rendezVous) {
            setSelectedRendezVous(rendezVous);
            setFormData({
                patientId: rendezVous.patient?.id || '',
                medecinId: rendezVous.medecin?.id || '',
                dateHeure: rendezVous.dateHeure ? new Date(rendezVous.dateHeure) : null,
                duree: rendezVous.duree || 30,
                motif: rendezVous.motif || ''
            });
            
            // Ajouter les informations du médecin et du patient aux listes
            if (rendezVous.medecin) {
                setMedecins([rendezVous.medecin]);
            }
            if (rendezVous.patient) {
                setPatients([rendezVous.patient]);
            }
        } else {
            // Mode création
            setSelectedRendezVous(null);
            setFormData({
                patientId: '',
                medecinId: '',
                dateHeure: new Date(),
                duree: 30,
                motif: ''
            });
        }
        
        setDialogOpen(true);
    };

    const handleCloseDialog = () => {
        setDialogOpen(false);
    };

    const handleOpenDetailsDialog = (rendezVous) => {
        setSelectedRendezVous(rendezVous);
        setDetailsDialogOpen(true);
    };

    const handleCloseDetailsDialog = () => {
        setDetailsDialogOpen(false);
    };

    const handleChange = (e) => {
        const { name, value } = e.target;
        setFormData({
            ...formData,
            [name]: value
        });
    };

    const handleDateChange = (newDate) => {
        setFormData({
            ...formData,
            dateHeure: newDate
        });
    };

    const handleSearchMedecin = async (e) => {
        const query = e.target.value;
        setSearchQuery({
            ...searchQuery,
            medecin: query
        });
        
        if (query.length >= 2) {
            try {
                setLoadingMedecins(true);
                const response = await searchMedecins(query);
                setMedecins(response.data);
            } catch (error) {
                console.error('Erreur lors de la recherche de médecins:', error);
            } finally {
                setLoadingMedecins(false);
            }
        }
    };

    const handleSearchPatient = async (e) => {
        const query = e.target.value;
        setSearchQuery({
            ...searchQuery,
            patient: query
        });
        
        if (query.length >= 2) {
            try {
                setLoadingPatients(true);
                const response = await searchPatients(query);
                setPatients(response.data);
            } catch (error) {
                console.error('Erreur lors de la recherche de patients:', error);
            } finally {
                setLoadingPatients(false);
            }
        }
    };

    const handleSubmit = async () => {
        // Validation du formulaire
        if (!formData.patientId || !formData.medecinId || !formData.dateHeure || !formData.motif) {
            showSnackbar('Veuillez remplir tous les champs obligatoires', 'error');
            return;
        }
        
        try {
            if (editMode && selectedRendezVous) {
                await updateRendezVous(selectedRendezVous.id, formData);
                showSnackbar('Rendez-vous modifié avec succès');
            } else {
                await createRendezVous(formData);
                showSnackbar('Rendez-vous créé avec succès');
            }
            
            handleCloseDialog();
            fetchRendezVous();
        } catch (error) {
            console.error('Erreur lors de la sauvegarde du rendez-vous:', error);
            showSnackbar('Erreur lors de la sauvegarde', 'error');
        }
    };

    const handleDelete = async (id) => {
        if (window.confirm('Êtes-vous sûr de vouloir supprimer ce rendez-vous ?')) {
            try {
                await deleteRendezVous(id);
                showSnackbar('Rendez-vous supprimé avec succès');
                fetchRendezVous();
            } catch (error) {
                console.error('Erreur lors de la suppression:', error);
                showSnackbar('Erreur lors de la suppression', 'error');
            }
        }
    };

    const showSnackbar = (message, severity = 'success') => {
        setSnackbar({
            open: true,
            message,
            severity
        });
    };

    const handleCloseSnackbar = () => {
        setSnackbar({ ...snackbar, open: false });
    };

    // Filtrer les rendez-vous par statut pour les onglets
    const rendezVousEnAttente = rendezVous.filter(rdv => rdv.statut === 'PLANIFIE');
    const rendezVousValides = rendezVous.filter(rdv => rdv.statut === 'VALIDE');
    const rendezVousRejetes = rendezVous.filter(rdv => rdv.statut === 'REJETE');

    // Colonnes du tableau
    const columns = [
        {
            field: 'patient',
            headerName: 'Patient',
            width: 200,
            renderCell: (params) => (
                <span>{params.row.patient?.nom} {params.row.patient?.prenom}</span>
            )
        },
        {
            field: 'medecin',
            headerName: 'Médecin',
            width: 200,
            renderCell: (params) => (
                <span>Dr. {params.row.medecin?.nom} {params.row.medecin?.prenom}</span>
            )
        },
        {
            field: 'dateHeure',
            headerName: 'Date et heure',
            width: 180,
            renderCell: (params) => (
                <span>
                    {params.row.dateHeure ? 
                        format(new Date(params.row.dateHeure), 'dd/MM/yyyy HH:mm', { locale: fr }) : 
                        '-'
                    }
                </span>
            )
        },
        {
            field: 'duree',
            headerName: 'Durée (min)',
            width: 120
        },
        {
            field: 'statut',
            headerName: 'Statut',
            width: 150,
            renderCell: (params) => {
                let color, label;
                switch (params.row.statut) {
                    case 'PLANIFIE':
                        color = 'warning';
                        label = 'En attente';
                        break;
                    case 'VALIDE':
                        color = 'success';
                        label = 'Validé';
                        break;
                    case 'REJETE':
                        color = 'error';
                        label = 'Rejeté';
                        break;
                    default:
                        color = 'default';
                        label = params.row.statut;
                }
                return <Chip label={label} color={color} size="small" />;
            }
        },
        {
            field: 'actions',
            headerName: 'Actions',
            width: 200,
            renderCell: (params) => (
                <Box>
                    <IconButton 
                        color="info" 
                        size="small" 
                        onClick={() => handleOpenDetailsDialog(params.row)}
                    >
                        <VisibilityIcon />
                    </IconButton>
                    <IconButton 
                        color="primary" 
                        size="small" 
                        onClick={() => handleOpenDialog('edit', params.row)}
                    >
                        <EditIcon />
                    </IconButton>
                    <IconButton 
                        color="error" 
                        size="small" 
                        onClick={() => handleDelete(params.row.id)}
                    >
                        <DeleteIcon />
                    </IconButton>
                </Box>
            )
        }
    ];

    return (
        <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
            <Paper sx={{ p: 2, mb: 2 }}>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                    <Typography variant="h5">
                        Gestion des rendez-vous
                    </Typography>
                    <Button 
                        variant="contained" 
                        startIcon={<AddIcon />}
                        onClick={() => handleOpenDialog('create')}
                    >
                        Nouveau rendez-vous
                    </Button>
                </Box>

                <Box sx={{ borderBottom: 1, borderColor: 'divider' }}>
                    <Tabs value={tabValue} onChange={handleTabChange}>
                        <Tab label={`Tous (${rendezVous.length})`} />
                        <Tab label={`En attente (${rendezVousEnAttente.length})`} />
                        <Tab label={`Validés (${rendezVousValides.length})`} />
                        <Tab label={`Rejetés (${rendezVousRejetes.length})`} />
                    </Tabs>
                </Box>

                <TabPanel value={tabValue} index={0}>
                    <DataGrid
                        rows={rendezVous}
                        columns={columns}
                        pageSize={10}
                        rowsPerPageOptions={[10, 25, 50]}
                        autoHeight
                        loading={loading}
                        disableSelectionOnClick
                    />
                </TabPanel>

                <TabPanel value={tabValue} index={1}>
                    <DataGrid
                        rows={rendezVousEnAttente}
                        columns={columns}
                        pageSize={10}
                        rowsPerPageOptions={[10, 25, 50]}
                        autoHeight
                        loading={loading}
                        disableSelectionOnClick
                    />
                </TabPanel>

                <TabPanel value={tabValue} index={2}>
                    <DataGrid
                        rows={rendezVousValides}
                        columns={columns}
                        pageSize={10}
                        rowsPerPageOptions={[10, 25, 50]}
                        autoHeight
                        loading={loading}
                        disableSelectionOnClick
                    />
                </TabPanel>

                <TabPanel value={tabValue} index={3}>
                    <DataGrid
                        rows={rendezVousRejetes}
                        columns={columns}
                        pageSize={10}
                        rowsPerPageOptions={[10, 25, 50]}
                        autoHeight
                        loading={loading}
                        disableSelectionOnClick
                    />
                </TabPanel>
            </Paper>

            {/* Dialog pour créer/modifier un rendez-vous */}
            <Dialog 
                open={dialogOpen} 
                onClose={handleCloseDialog}
                maxWidth="md"
                fullWidth
            >
                <DialogTitle>
                    {editMode ? 'Modifier le rendez-vous' : 'Nouveau rendez-vous'}
                </DialogTitle>
                <DialogContent>
                    <Grid container spacing={2} sx={{ mt: 1 }}>
                        <Grid item xs={12} md={6}>
                            <TextField
                                fullWidth
                                label="Rechercher un patient"
                                variant="outlined"
                                value={searchQuery.patient}
                                onChange={handleSearchPatient}
                                helperText="Entrez au moins 2 caractères pour rechercher"
                            />
                        </Grid>
                        <Grid item xs={12} md={6}>
                            <FormControl fullWidth>
                                <InputLabel id="patient-label">Patient</InputLabel>
                                <Select
                                    labelId="patient-label"
                                    id="patientId"
                                    name="patientId"
                                    value={formData.patientId}
                                    label="Patient"
                                    onChange={handleChange}
                                    disabled={loadingPatients}
                                >
                                    <MenuItem value="">
                                        <em>Sélectionnez un patient</em>
                                    </MenuItem>
                                    {patients.map((patient) => (
                                        <MenuItem key={patient.id} value={patient.id}>
                                            {patient.nom} {patient.prenom}
                                        </MenuItem>
                                    ))}
                                </Select>
                            </FormControl>
                        </Grid>

                        <Grid item xs={12} md={6}>
                            <TextField
                                fullWidth
                                label="Rechercher un médecin"
                                variant="outlined"
                                value={searchQuery.medecin}
                                onChange={handleSearchMedecin}
                                helperText="Entrez au moins 2 caractères pour rechercher"
                            />
                        </Grid>
                        <Grid item xs={12} md={6}>
                            <FormControl fullWidth>
                                <InputLabel id="medecin-label">Médecin</InputLabel>
                                <Select
                                    labelId="medecin-label"
                                    id="medecinId"
                                    name="medecinId"
                                    value={formData.medecinId}
                                    label="Médecin"
                                    onChange={handleChange}
                                    disabled={loadingMedecins}
                                >
                                    <MenuItem value="">
                                        <em>Sélectionnez un médecin</em>
                                    </MenuItem>
                                    {medecins.map((medecin) => (
                                        <MenuItem key={medecin.id} value={medecin.id}>
                                            Dr. {medecin.nom} {medecin.prenom} {medecin.specialite ? `(${medecin.specialite})` : ''}
                                        </MenuItem>
                                    ))}
                                </Select>
                            </FormControl>
                        </Grid>

                        <Grid item xs={12} md={6}>
                            <DateTimePicker
                                label="Date et heure"
                                value={formData.dateHeure}
                                onChange={handleDateChange}
                                slotProps={{ textField: { fullWidth: true } }}
                            />
                        </Grid>

                        <Grid item xs={12} md={6}>
                            <TextField
                                fullWidth
                                label="Durée (minutes)"
                                name="duree"
                                type="number"
                                value={formData.duree}
                                onChange={handleChange}
                                InputProps={{ inputProps: { min: 15, step: 5 } }}
                            />
                        </Grid>

                        <Grid item xs={12}>
                            <TextField
                                fullWidth
                                label="Motif"
                                name="motif"
                                value={formData.motif}
                                onChange={handleChange}
                                multiline
                                rows={3}
                            />
                        </Grid>
                    </Grid>
                </DialogContent>
                <DialogActions>
                    <Button onClick={handleCloseDialog}>Annuler</Button>
                    <Button 
                        variant="contained" 
                        color="primary" 
                        onClick={handleSubmit}
                    >
                        {editMode ? 'Modifier' : 'Créer'}
                    </Button>
                </DialogActions>
            </Dialog>

            {/* Dialog pour voir les détails d'un rendez-vous */}
            <Dialog
                open={detailsDialogOpen}
                onClose={handleCloseDetailsDialog}
                maxWidth="sm"
                fullWidth
            >
                <DialogTitle>
                    Détails du rendez-vous
                </DialogTitle>
                <DialogContent>
                    {selectedRendezVous && (
                        <Grid container spacing={2} sx={{ mt: 1 }}>
                            <Grid item xs={12}>
                                <Typography variant="subtitle1">Patient</Typography>
                                <Typography variant="body1">
                                    {selectedRendezVous.patient?.nom} {selectedRendezVous.patient?.prenom}
                                </Typography>
                            </Grid>
                            <Grid item xs={12}>
                                <Typography variant="subtitle1">Médecin</Typography>
                                <Typography variant="body1">
                                    Dr. {selectedRendezVous.medecin?.nom} {selectedRendezVous.medecin?.prenom}
                                </Typography>
                            </Grid>
                            <Grid item xs={12} sm={6}>
                                <Typography variant="subtitle1">Date et heure</Typography>
                                <Typography variant="body1">
                                    {selectedRendezVous.dateHeure ? 
                                        format(new Date(selectedRendezVous.dateHeure), 'dd/MM/yyyy HH:mm', { locale: fr }) : 
                                        '-'
                                    }
                                </Typography>
                            </Grid>
                            <Grid item xs={12} sm={6}>
                                <Typography variant="subtitle1">Durée</Typography>
                                <Typography variant="body1">
                                    {selectedRendezVous.duree} minutes
                                </Typography>
                            </Grid>
                            <Grid item xs={12}>
                                <Typography variant="subtitle1">Motif</Typography>
                                <Typography variant="body1">
                                    {selectedRendezVous.motif}
                                </Typography>
                            </Grid>
                            <Grid item xs={12}>
                                <Typography variant="subtitle1">Statut</Typography>
                                <Typography variant="body1">
                                    {selectedRendezVous.statut === 'PLANIFIE' ? 'En attente' : 
                                     selectedRendezVous.statut === 'VALIDE' ? 'Validé' : 
                                     selectedRendezVous.statut === 'REJETE' ? 'Rejeté' : 
                                     selectedRendezVous.statut}
                                </Typography>
                            </Grid>
                        </Grid>
                    )}
                </DialogContent>
                <DialogActions>
                    <Button onClick={handleCloseDetailsDialog}>Fermer</Button>
                </DialogActions>
            </Dialog>

            <Snackbar
                open={snackbar.open}
                autoHideDuration={6000}
                onClose={handleCloseSnackbar}
                anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
            >
                <Alert
                    onClose={handleCloseSnackbar}
                    severity={snackbar.severity}
                    sx={{ width: '100%' }}
                >
                    {snackbar.message}
                </Alert>
            </Snackbar>
        </Container>
    );
};

export default GestionRendezVous;
2. Interface pour le médecin
src/pages/medecin/RendezVousMedecin.jsx
jsx
import React, { useState, useEffect } from 'react';
import {
    Container,
    Typography,
    Paper,
    Button,
    Box,
    Tabs,
    Tab,
    Dialog,
    DialogTitle,
    DialogContent,
    DialogActions,
    TextField,
    Chip,
    Snackbar,
    Alert,
    Grid
} from '@mui/material';
import { DataGrid } from '@mui/x-data-grid';
import {
    CheckCircle as CheckCircleIcon,
    Cancel as CancelIcon,
    Info as InfoIcon
} from '@mui/icons-material';
import { format } from 'date-fns';
import { fr } from 'date-fns/locale';
import { useAuth } from '../../context/AuthContext';
import {
    getAllRendezVous,
    validerRendezVous,
    rejeterRendezVous
} from '../../services/medecinService';

function TabPanel(props) {
    const { children, value, index, ...other } = props;
    return (
        <div
            role="tabpanel"
            hidden={value !== index}
            id={`rendez-vous-tabpanel-${index}`}
            aria-labelledby={`rendez-vous-tab-${index}`}
            {...other}
        >
            {value === index && <Box sx={{ p: 3 }}>{children}</Box>}
        </div>
    );
}

const RendezVousMedecin = () => {
    const [rendezVous, setRendezVous] = useState([]);
    const [tabValue, setTabValue] = useState(0);
    const [selectedRendezVous, setSelectedRendezVous] = useState(null);
    const [detailsDialogOpen, setDetailsDialogOpen] = useState(false);
    const [confirmDialogOpen, setConfirmDialogOpen] = useState(false);
    const [confirmAction, setConfirmAction] = useState('');
    const [rejetMotif, setRejetMotif] = useState('');
    const [loading, setLoading] = useState(true);
    const [snackbar, setSnackbar] = useState({
        open: false,
        message: '',
        severity: 'success'
    });

    const { currentUser } = useAuth();

    useEffect(() => {
        fetchRendezVous();
    }, []);

    const fetchRendezVous = async () => {
        try {
            setLoading(true);
            if (currentUser?.id) {
                const response = await getAllRendezVous(currentUser.id);
                setRendezVous(response.data);
            }
        } catch (error) {
            console.error('Erreur lors du chargement des rendez-vous:', error);
            showSnackbar('Erreur lors du chargement des données', 'error');
        } finally {
            setLoading(false);
        }
    };

    const handleTabChange = (event, newValue) => {
        setTabValue(newValue);
    };

    const handleOpenDetailsDialog = (rendezVous) => {
        setSelectedRendezVous(rendezVous);
        setDetailsDialogOpen(true);
    };

    const handleCloseDetailsDialog = () => {
        setDetailsDialogOpen(false);
    };

    const handleOpenConfirmDialog = (action, rendezVous) => {
        setSelectedRendezVous(rendezVous);
        setConfirmAction(action);
        setRejetMotif('');
        setConfirmDialogOpen(true);
    };

    const handleCloseConfirmDialog = () => {
        setConfirmDialogOpen(false);
    };

    const handleRejetMotifChange = (e) => {
        setRejetMotif(e.target.value);
    };

    const handleConfirmAction = async () => {
        try {
            if (confirmAction === 'valider') {
                await validerRendezVous(selectedRendezVous.id);
                showSnackbar('Rendez-vous validé avec succès');
            } else if (confirmAction === 'rejeter') {
                // Si nous voulons envoyer le motif de rejet, nous pouvons le faire ici
                await rejeterRendezVous(selectedRendezVous.id, { motif: rejetMotif });
                showSnackbar('Rendez-vous rejeté');
            }
            
            fetchRendezVous();
            handleCloseConfirmDialog();
        } catch (error) {
            console.error('Erreur lors de l\'action:', error);
            showSnackbar(`Erreur lors de l'action: ${error.message}`, 'error');
        }
    };

    const showSnackbar = (message, severity = 'success') => {
        setSnackbar({
            open: true,
            message,
            severity
        });
    };

    const handleCloseSnackbar = () => {
        setSnackbar({ ...snackbar, open: false });
    };

    // Filtrer les rendez-vous par statut pour les onglets
    const rendezVousEnAttente = rendezVous.filter(rdv => rdv.statut === 'PLANIFIE');
    const rendezVousValides = rendezVous.filter(rdv => rdv.statut === 'VALIDE');
    const rendezVousRejetes = rendezVous.filter(rdv => rdv.statut === 'REJETE');

    // Colonnes du tableau
    const columns = [
        {
            field: 'patient',
            headerName: 'Patient',
            width: 200,
            renderCell: (params) => (
                <span>{params.row.patient?.nom} {params.row.patient?.prenom}</span>
            )
        },
        {
            field: 'dateHeure',
            headerName: 'Date et heure',
            width: 180,
            renderCell: (params) => (
                <span>
                    {params.row.dateHeure ? 
                        format(new Date(params.row.dateHeure), 'dd/MM/yyyy HH:mm', { locale: fr }) : 
                        '-'
                    }
                </span>
            )
        },
        {
            field: 'duree',
            headerName: 'Durée (min)',
            width: 120
        },
        {
            field: 'motif',
            headerName: 'Motif',
            width: 250
        },
        {
            field: 'statut',
            headerName: 'Statut',
            width: 150,
            renderCell: (params) => {
                let color, label;
                switch (params.row.statut) {
                    case 'PLANIFIE':
                        color = 'warning';
                        label = 'En attente';
                        break;
                    case 'VALIDE':
                        color = 'success';
                        label = 'Validé';
                        break;
                    case 'REJETE':
                        color = 'error';
                        label = 'Rejeté';
                        break;
                    default:
                        color = 'default';
                        label = params.row.statut;
                }
                return <Chip label={label} color={color} size="small" />;
            }
        },
        {
            field: 'actions',
            headerName: 'Actions',
            width: 300,
            renderCell: (params) => (
                <Box>
                    <Button
                        variant="outlined"
                        size="small"
                        startIcon={<InfoIcon />}
                        onClick={() => handleOpenDetailsDialog(params.row)}
                        sx={{ mr: 1 }}
                    >
                        Détails
                    </Button>
                    {params.row.statut === 'PLANIFIE' && (
                        <>
                            <Button
                                variant="contained"
                                color="success"
                                size="small"
                                startIcon={<CheckCircleIcon />}
                                onClick



Continuer

Modifier
Continuons avec l'interface pour le médecin.

src/pages/medecin/RendezVousMedecin.jsx (suite)
jsx
                        <>
                            <Button
                                variant="contained"
                                color="success"
                                size="small"
                                startIcon={<CheckCircleIcon />}
                                onClick={() => handleOpenConfirmDialog('valider', params.row)}
                                sx={{ mr: 1 }}
                            >
                                Valider
                            </Button>
                            <Button
                                variant="contained"
                                color="error"
                                size="small"
                                startIcon={<CancelIcon />}
                                onClick={() => handleOpenConfirmDialog('rejeter', params.row)}
                            >
                                Rejeter
                            </Button>
                        </>
                    )}
                </Box>
            )
        }
    ];

    return (
        <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
            <Paper sx={{ p: 2, mb: 2 }}>
                <Typography variant="h5" gutterBottom>
                    Mes rendez-vous
                </Typography>

                <Box sx={{ borderBottom: 1, borderColor: 'divider' }}>
                    <Tabs value={tabValue} onChange={handleTabChange}>
                        <Tab label={`Tous (${rendezVous.length})`} />
                        <Tab label={`En attente (${rendezVousEnAttente.length})`} />
                        <Tab label={`Validés (${rendezVousValides.length})`} />
                        <Tab label={`Rejetés (${rendezVousRejetes.length})`} />
                    </Tabs>
                </Box>

                <TabPanel value={tabValue} index={0}>
                    <DataGrid
                        rows={rendezVous}
                        columns={columns}
                        pageSize={10}
                        rowsPerPageOptions={[10, 25, 50]}
                        autoHeight
                        loading={loading}
                        disableSelectionOnClick
                    />
                </TabPanel>

                <TabPanel value={tabValue} index={1}>
                    <DataGrid
                        rows={rendezVousEnAttente}
                        columns={columns}
                        pageSize={10}
                        rowsPerPageOptions={[10, 25, 50]}
                        autoHeight
                        loading={loading}
                        disableSelectionOnClick
                    />
                </TabPanel>

                <TabPanel value={tabValue} index={2}>
                    <DataGrid
                        rows={rendezVousValides}
                        columns={columns.filter(col => col.field !== 'actions' || col.field === 'actions')}
                        pageSize={10}
                        rowsPerPageOptions={[10, 25, 50]}
                        autoHeight
                        loading={loading}
                        disableSelectionOnClick
                    />
                </TabPanel>

                <TabPanel value={tabValue} index={3}>
                    <DataGrid
                        rows={rendezVousRejetes}
                        columns={columns.filter(col => col.field !== 'actions' || col.field === 'actions')}
                        pageSize={10}
                        rowsPerPageOptions={[10, 25, 50]}
                        autoHeight
                        loading={loading}
                        disableSelectionOnClick
                    />
                </TabPanel>
            </Paper>

            {/* Dialog pour voir les détails d'un rendez-vous */}
            <Dialog
                open={detailsDialogOpen}
                onClose={handleCloseDetailsDialog}
                maxWidth="sm"
                fullWidth
            >
                <DialogTitle>Détails du rendez-vous</DialogTitle>
                <DialogContent>
                    {selectedRendezVous && (
                        <Grid container spacing={2} sx={{ mt: 1 }}>
                            <Grid item xs={12}>
                                <Typography variant="subtitle1">Patient</Typography>
                                <Typography variant="body1">
                                    {selectedRendezVous.patient?.nom} {selectedRendezVous.patient?.prenom}
                                </Typography>
                            </Grid>
                            <Grid item xs={12} sm={6}>
                                <Typography variant="subtitle1">Date et heure</Typography>
                                <Typography variant="body1">
                                    {selectedRendezVous.dateHeure ? 
                                        format(new Date(selectedRendezVous.dateHeure), 'dd/MM/yyyy HH:mm', { locale: fr }) : 
                                        '-'
                                    }
                                </Typography>
                            </Grid>
                            <Grid item xs={12} sm={6}>
                                <Typography variant="subtitle1">Durée</Typography>
                                <Typography variant="body1">
                                    {selectedRendezVous.duree} minutes
                                </Typography>
                            </Grid>
                            <Grid item xs={12}>
                                <Typography variant="subtitle1">Motif</Typography>
                                <Typography variant="body1">
                                    {selectedRendezVous.motif}
                                </Typography>
                            </Grid>
                            <Grid item xs={12}>
                                <Typography variant="subtitle1">Statut</Typography>
                                <Typography variant="body1">
                                    {selectedRendezVous.statut === 'PLANIFIE' ? 'En attente' : 
                                     selectedRendezVous.statut === 'VALIDE' ? 'Validé' : 
                                     selectedRendezVous.statut === 'REJETE' ? 'Rejeté' : 
                                     selectedRendezVous.statut}
                                </Typography>
                            </Grid>
                        </Grid>
                    )}
                </DialogContent>
                <DialogActions>
                    <Button onClick={handleCloseDetailsDialog}>Fermer</Button>
                </DialogActions>
            </Dialog>

            {/* Dialog pour confirmer une action */}
            <Dialog
                open={confirmDialogOpen}
                onClose={handleCloseConfirmDialog}
                maxWidth="sm"
                fullWidth
            >
                <DialogTitle>
                    {confirmAction === 'valider' ? 'Valider ce rendez-vous' : 'Rejeter ce rendez-vous'}
                </DialogTitle>
                <DialogContent>
                    <Typography variant="body1" gutterBottom>
                        {confirmAction === 'valider' 
                            ? 'Êtes-vous sûr de vouloir valider ce rendez-vous ? Le patient en sera informé.' 
                            : 'Êtes-vous sûr de vouloir rejeter ce rendez-vous ? Le patient en sera informé.'}
                    </Typography>
                    {selectedRendezVous && (
                        <Box sx={{ mt: 2 }}>
                            <Typography variant="body2">
                                Patient: {selectedRendezVous.patient?.nom} {selectedRendezVous.patient?.prenom}
                            </Typography>
                            <Typography variant="body2">
                                Date et heure: {selectedRendezVous.dateHeure ? 
                                    format(new Date(selectedRendezVous.dateHeure), 'dd/MM/yyyy HH:mm', { locale: fr }) : 
                                    '-'
                                }
                            </Typography>
                        </Box>
                    )}
                    {confirmAction === 'rejeter' && (
                        <TextField
                            margin="normal"
                            fullWidth
                            label="Motif du rejet (optionnel)"
                            value={rejetMotif}
                            onChange={handleRejetMotifChange}
                            multiline
                            rows={3}
                        />
                    )}
                </DialogContent>
                <DialogActions>
                    <Button onClick={handleCloseConfirmDialog}>Annuler</Button>
                    <Button 
                        variant="contained" 
                        color={confirmAction === 'valider' ? 'success' : 'error'}
                        onClick={handleConfirmAction}
                    >
                        Confirmer
                    </Button>
                </DialogActions>
            </Dialog>

            <Snackbar
                open={snackbar.open}
                autoHideDuration={6000}
                onClose={handleCloseSnackbar}
                anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
            >
                <Alert
                    onClose={handleCloseSnackbar}
                    severity={snackbar.severity}
                    sx={{ width: '100%' }}
                >
                    {snackbar.message}
                </Alert>
            </Snackbar>
        </Container>
    );
};

export default RendezVousMedecin;
3. Interface pour le patient
src/pages/patient/RendezVousPatient.jsx
jsx
import React, { useState, useEffect } from 'react';
import {
    Container,
    Typography,
    Paper,
    Box,
    Tabs,
    Tab,
    Dialog,
    DialogTitle,
    DialogContent,
    DialogActions,
    Button,
    Chip,
    Snackbar,
    Alert,
    Grid,
    Card,
    CardContent,
    Divider
} from '@mui/material';
import {
    Today as TodayIcon,
    History as HistoryIcon,
    Info as InfoIcon,
    CheckCircle as CheckCircleIcon,
    Cancel as CancelIcon,
    Schedule as ScheduleIcon
} from '@mui/icons-material';
import { format } from 'date-fns';
import { fr } from 'date-fns/locale';
import { useAuth } from '../../context/AuthContext';
import { getAllRendezVous } from '../../services/patientService';

function TabPanel(props) {
    const { children, value, index, ...other } = props;
    return (
        <div
            role="tabpanel"
            hidden={value !== index}
            id={`rendez-vous-tabpanel-${index}`}
            aria-labelledby={`rendez-vous-tab-${index}`}
            {...other}
        >
            {value === index && <Box sx={{ p: 3 }}>{children}</Box>}
        </div>
    );
}

const RendezVousPatient = () => {
    const [rendezVous, setRendezVous] = useState([]);
    const [tabValue, setTabValue] = useState(0);
    const [selectedRendezVous, setSelectedRendezVous] = useState(null);
    const [detailsDialogOpen, setDetailsDialogOpen] = useState(false);
    const [loading, setLoading] = useState(true);
    const [snackbar, setSnackbar] = useState({
        open: false,
        message: '',
        severity: 'success'
    });

    const { currentUser } = useAuth();

    useEffect(() => {
        fetchRendezVous();
    }, []);

    const fetchRendezVous = async () => {
        try {
            setLoading(true);
            if (currentUser?.id) {
                const response = await getAllRendezVous(currentUser.id);
                setRendezVous(response.data);
            }
        } catch (error) {
            console.error('Erreur lors du chargement des rendez-vous:', error);
            showSnackbar('Erreur lors du chargement des données', 'error');
        } finally {
            setLoading(false);
        }
    };

    const handleTabChange = (event, newValue) => {
        setTabValue(newValue);
    };

    const handleOpenDetailsDialog = (rendezVous) => {
        setSelectedRendezVous(rendezVous);
        setDetailsDialogOpen(true);
    };

    const handleCloseDetailsDialog = () => {
        setDetailsDialogOpen(false);
    };

    const showSnackbar = (message, severity = 'success') => {
        setSnackbar({
            open: true,
            message,
            severity
        });
    };

    const handleCloseSnackbar = () => {
        setSnackbar({ ...snackbar, open: false });
    };

    // Séparer les rendez-vous à venir et passés
    const today = new Date();
    const rendezVousAvenir = rendezVous
        .filter(rdv => new Date(rdv.dateHeure) >= today && rdv.statut === 'VALIDE')
        .sort((a, b) => new Date(a.dateHeure) - new Date(b.dateHeure));
    
    const rendezVousPasses = rendezVous
        .filter(rdv => new Date(rdv.dateHeure) < today || rdv.statut === 'TERMINE')
        .sort((a, b) => new Date(b.dateHeure) - new Date(a.dateHeure));

    const getChipByStatus = (status) => {
        switch (status) {
            case 'PLANIFIE':
                return <Chip icon={<ScheduleIcon />} label="En attente" color="warning" size="small" />;
            case 'VALIDE':
                return <Chip icon={<CheckCircleIcon />} label="Validé" color="success" size="small" />;
            case 'REJETE':
                return <Chip icon={<CancelIcon />} label="Rejeté" color="error" size="small" />;
            case 'TERMINE':
                return <Chip icon={<CheckCircleIcon />} label="Terminé" color="success" size="small" />;
            default:
                return <Chip label={status} size="small" />;
        }
    };

    return (
        <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
            <Paper sx={{ p: 2, mb: 2 }}>
                <Typography variant="h5" gutterBottom>
                    Mes rendez-vous
                </Typography>

                <Box sx={{ borderBottom: 1, borderColor: 'divider' }}>
                    <Tabs value={tabValue} onChange={handleTabChange}>
                        <Tab icon={<TodayIcon />} label={`À venir (${rendezVousAvenir.length})`} />
                        <Tab icon={<HistoryIcon />} label={`Passés (${rendezVousPasses.length})`} />
                    </Tabs>
                </Box>

                <TabPanel value={tabValue} index={0}>
                    {loading ? (
                        <Typography>Chargement...</Typography>
                    ) : rendezVousAvenir.length === 0 ? (
                        <Typography>Vous n'avez pas de rendez-vous à venir.</Typography>
                    ) : (
                        <Grid container spacing={2}>
                            {rendezVousAvenir.map((rdv) => (
                                <Grid item xs={12} sm={6} md={4} key={rdv.id}>
                                    <Card variant="outlined">
                                        <CardContent>
                                            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 1 }}>
                                                <Typography variant="h6" component="div">
                                                    Dr. {rdv.medecin?.nom} {rdv.medecin?.prenom}
                                                </Typography>
                                                {getChipByStatus(rdv.statut)}
                                            </Box>
                                            <Typography color="text.secondary" gutterBottom>
                                                {rdv.medecin?.specialite}
                                            </Typography>
                                            <Typography variant="body2" sx={{ mb: 1 }}>
                                                {format(new Date(rdv.dateHeure), 'EEEE d MMMM yyyy', { locale: fr })}
                                            </Typography>
                                            <Typography variant="body2" sx={{ mb: 1 }}>
                                                {format(new Date(rdv.dateHeure), 'HH:mm')} - {rdv.duree} min
                                            </Typography>
                                            <Divider sx={{ my: 1 }} />
                                            <Typography variant="body2" color="text.secondary">
                                                Motif: {rdv.motif}
                                            </Typography>
                                            <Button
                                                variant="outlined"
                                                size="small"
                                                startIcon={<InfoIcon />}
                                                onClick={() => handleOpenDetailsDialog(rdv)}
                                                sx={{ mt: 2 }}
                                                fullWidth
                                            >
                                                Détails
                                            </Button>
                                        </CardContent>
                                    </Card>
                                </Grid>
                            ))}
                        </Grid>
                    )}
                </TabPanel>

                <TabPanel value={tabValue} index={1}>
                    {loading ? (
                        <Typography>Chargement...</Typography>
                    ) : rendezVousPasses.length === 0 ? (
                        <Typography>Vous n'avez pas d'historique de rendez-vous.</Typography>
                    ) : (
                        <Grid container spacing={2}>
                            {rendezVousPasses.map((rdv) => (
                                <Grid item xs={12} sm={6} md={4} key={rdv.id}>
                                    <Card variant="outlined">
                                        <CardContent>
                                            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 1 }}>
                                                <Typography variant="h6" component="div">
                                                    Dr. {rdv.medecin?.nom} {rdv.medecin?.prenom}
                                                </Typography>
                                                {getChipByStatus(rdv.statut)}
                                            </Box>
                                            <Typography color="text.secondary" gutterBottom>
                                                {rdv.medecin?.specialite}
                                            </Typography>
                                            <Typography variant="body2" sx={{ mb: 1 }}>
                                                {format(new Date(rdv.dateHeure), 'EEEE d MMMM yyyy', { locale: fr })}
                                            </Typography>
                                            <Typography variant="body2" sx={{ mb: 1 }}>
                                                {format(new Date(rdv.dateHeure), 'HH:mm')} - {rdv.duree} min
                                            </Typography>
                                            <Divider sx={{ my: 1 }} />
                                            <Typography variant="body2" color="text.secondary">
                                                Motif: {rdv.motif}
                                            </Typography>
                                            <Button
                                                variant="outlined"
                                                size="small"
                                                startIcon={<InfoIcon />}
                                                onClick={() => handleOpenDetailsDialog(rdv)}
                                                sx={{ mt: 2 }}
                                                fullWidth
                                            >
                                                Détails
                                            </Button>
                                        </CardContent>
                                    </Card>
                                </Grid>
                            ))}
                        </Grid>
                    )}
                </TabPanel>
            </Paper>

            {/* Dialog pour voir les détails d'un rendez-vous */}
            <Dialog
                open={detailsDialogOpen}
                onClose={handleCloseDetailsDialog}
                maxWidth="sm"
                fullWidth
            >
                <DialogTitle>Détails du rendez-vous</DialogTitle>
                <DialogContent>
                    {selectedRendezVous && (
                        <Grid container spacing={2} sx={{ mt: 1 }}>
                            <Grid item xs={12}>
                                <Typography variant="subtitle1">Médecin</Typography>
                                <Typography variant="body1">
                                    Dr. {selectedRendezVous.medecin?.nom} {selectedRendezVous.medecin?.prenom}
                                </Typography>
                                <Typography variant="body2" color="text.secondary">
                                    {selectedRendezVous.medecin?.specialite}
                                </Typography>
                            </Grid>
                            <Grid item xs={12} sm={6}>
                                <Typography variant="subtitle1">Date et heure</Typography>
                                <Typography variant="body1">
                                    {selectedRendezVous.dateHeure ? 
                                        format(new Date(selectedRendezVous.dateHeure), 'dd/MM/yyyy HH:mm', { locale: fr }) : 
                                        '-'
                                    }
                                </Typography>
                            </Grid>
                            <Grid item xs={12} sm={6}>
                                <Typography variant="subtitle1">Durée</Typography>
                                <Typography variant="body1">
                                    {selectedRendezVous.duree} minutes
                                </Typography>
                            </Grid>
                            <Grid item xs={12}>
                                <Typography variant="subtitle1">Motif</Typography>
                                <Typography variant="body1">
                                    {selectedRendezVous.motif}
                                </Typography>
                            </Grid>
                            <Grid item xs={12}>
                                <Typography variant="subtitle1">Statut</Typography>
                                <Box>
                                    {getChipByStatus(selectedRendezVous.statut)}
                                </Box>
                            </Grid>
                        </Grid>
                    )}
                </DialogContent>
                <DialogActions>
                    <Button onClick={handleCloseDetailsDialog}>Fermer</Button>
                </DialogActions>
            </Dialog>

            <Snackbar
                open={snackbar.open}
                autoHideDuration={6000}
                onClose={handleCloseSnackbar}
                anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
            >
                <Alert
                    onClose={handleCloseSnackbar}
                    severity={snackbar.severity}
                    sx={{ width: '100%' }}
                >
                    {snackbar.message}
                </Alert>
            </Snackbar>
        </Container>
    );
};

export default RendezVousPatient;
4. Mise à jour des layouts pour inclure les routes de rendez-vous
src/components/layouts/MedecinLayout.jsx
jsx
import React from 'react';
import { Routes, Route } from 'react-router-dom';
import { Box, CssBaseline } from '@mui/material';
import MedecinDashboard from '../../pages/medecin/MedecinDashboard';
import RendezVousMedecin from '../../pages/medecin/RendezVousMedecin';
import NotFound from '../../pages/NotFound';

const MedecinLayout = () => {
    return (
        <Box sx={{ display: 'flex' }}>
            <CssBaseline />
            {/* Ici nous ajouterons l'en-tête et la barre latérale du médecin dans la prochaine étape */}
            <Box
                component="main"
                sx={{
                    flexGrow: 1,
                    height: '100vh',
                    overflow: 'auto',
                    padding: (theme) => theme.spacing(3),
                    paddingTop: '64px', // Hauteur de l'en-tête
                }}
            >
                <Routes>
                    <Route path="dashboard" element={<MedecinDashboard />} />
                    <Route path="rendez-vous" element={<RendezVousMedecin />} />
                    <Route path="*" element={<NotFound />} />
                </Routes>
            </Box>
        </Box>
    );
};

export default MedecinLayout;
src/components/layouts/PatientLayout.jsx
jsx
import React from 'react';
import { Routes, Route } from 'react-router-dom';
import { Box, CssBaseline } from '@mui/material';
import PatientDashboard from '../../pages/patient/PatientDashboard';
import RendezVousPatient from '../../pages/patient/RendezVousPatient';
import NotFound from '../../pages/NotFound';

const PatientLayout = () => {
    return (
        <Box sx={{ display: 'flex' }}>
            <CssBaseline />
            {/* Ici nous ajouterons l'en-tête et la barre latérale du patient dans la prochaine étape */}
            <Box
                component="main"
                sx={{
                    flexGrow: 1,
                    height: '100vh',
                    overflow: 'auto',
                    padding: (theme) => theme.spacing(3),
                    paddingTop: '64px', // Hauteur de l'en-tête
                }}
            >
                <Routes>
                    <Route path="dashboard" element={<PatientDashboard />} />
                    <Route path="rendez-vous" element={<RendezVousPatient />} />
                    <Route path="*" element={<NotFound />} />
                </Routes>
            </Box>
        </Box>
    );
};

export default PatientLayout;
src/components/layouts/SecretaireLayout.jsx
jsx
import React from 'react';
import { Routes, Route } from 'react-router-dom';
import { Box, CssBaseline } from '@mui/material';
import SecretaireDashboard from '../../pages/secretaire/SecretaireDashboard';
import GestionRendezVous from '../../pages/secretaire/GestionRendezVous';
import NotFound from '../../pages/NotFound';

const SecretaireLayout = () => {
    return (
        <Box sx={{ display: 'flex' }}>
            <CssBaseline />
            {/* Ici nous ajouterons l'en-tête et la barre latérale du secrétaire dans la prochaine étape */}
            <Box
                component="main"
                sx={{
                    flexGrow: 1,
                    height: '100vh',
                    overflow: 'auto',
                    padding: (theme) => theme.spacing(3),
                    paddingTop: '64px', // Hauteur de l'en-tête
                }}
            >
                <Routes>
                    <Route path="dashboard" element={<SecretaireDashboard />} />
                    <Route path="rendez-vous" element={<GestionRendezVous />} />
                    <Route path="*" element={<NotFound />} />
                </Routes>
            </Box>
        </Box>
    );
};

export default SecretaireLayout;
5. Ajout des en-têtes et barres latérales pour chaque type d'utilisateur
Pour compléter cette phase, nous allons ajouter des en-têtes et des barres latérales à chaque type d'utilisateur. Je vais vous montrer un exemple pour le layout du médecin, que vous pourrez adapter aux autres types d'utilisateurs.

src/components/medecin/MedecinHeader.jsx
jsx
import React, { useState } from 'react';
import {
    AppBar,
    Toolbar,
    IconButton,
    Typography,
    Menu,
    MenuItem,
    Badge,
    Box,
    Avatar
} from '@mui/material';
import {
    Menu as MenuIcon,
    Notifications as NotificationsIcon,
    AccountCircle,
    MoreVert as MoreIcon
} from '@mui/icons-material';
import { useAuth } from '../../context/AuthContext';
import { useNavigate } from 'react-router-dom';

const MedecinHeader = ({ open, toggleDrawer }) => {
    const [anchorEl, setAnchorEl] = useState(null);
    const [mobileMoreAnchorEl, setMobileMoreAnchorEl] = useState(null);

    const isMenuOpen = Boolean(anchorEl);
    const isMobileMenuOpen = Boolean(mobileMoreAnchorEl);

    const { currentUser, logout } = useAuth();
    const navigate = useNavigate();

    const handleProfileMenuOpen = (event) => {
        setAnchorEl(event.currentTarget);
    };

    const handleMobileMenuClose = () => {
        setMobileMoreAnchorEl(null);
    };

    const handleMenuClose = () => {
        setAnchorEl(null);
        handleMobileMenuClose();
    };

    const handleMobileMenuOpen = (event) => {
        setMobileMoreAnchorEl(event.currentTarget);
    };

    const handleLogout = () => {
        logout();
        navigate('/login');
    };

    const handleProfile = () => {
        handleMenuClose();
        navigate('/medecin/profile');
    };

    const menuId = 'primary-search-account-menu';
    const renderMenu = (
        <Menu
            anchorEl={anchorEl}
            anchorOrigin={{ vertical: 'top', horizontal: 'right' }}
            id={menuId}
            keepMounted
            transformOrigin={{ vertical: 'top', horizontal: 'right' }}
            open={isMenuOpen}
            onClose={handleMenuClose}
        >
            <MenuItem onClick={handleProfile}>Mon Profil</MenuItem>
            <MenuItem onClick={handleLogout}>Déconnexion</MenuItem>
        </Menu>
    );

    const mobileMenuId = 'primary-search-account-menu-mobile';
    const renderMobileMenu = (
        <Menu
            anchorEl={mobileMoreAnchorEl}
            anchorOrigin={{ vertical: 'top', horizontal: 'right' }}
            id={mobileMenuId}
            keepMounted
            transformOrigin={{ vertical: 'top', horizontal: 'right' }}
            open={isMobileMenuOpen}
            onClose={handleMobileMenuClose}
        >
            <MenuItem>
                <IconButton
                    size="large"
                    aria-label="show 17 new notifications"
                    color="inherit"
                >
                    <Badge badgeContent={0} color="error">
                        <NotificationsIcon />
                    </Badge>
                </IconButton>
                <p>Notifications</p>
            </MenuItem>
            <MenuItem onClick={handleProfileMenuOpen}>
                <IconButton
                    size="large"
                    aria-label="account of current user"
                    aria-controls="primary-search-account-menu"
                    aria-haspopup="true"
                    color="inherit"
                >
                    <AccountCircle />
                </IconButton>
                <p>Profil</p>
            </MenuItem>
        </Menu>
    );

    return (
        <>
            <AppBar position="fixed" sx={{ zIndex: (theme) => theme.zIndex.drawer + 1 }}>
                <Toolbar>
                    <IconButton
                        edge="start"
                        color="inherit"
                        aria-label="open drawer"
                        onClick={toggleDrawer}
                        sx={{
                            marginRight: '36px',
                        }}
                    >
                        <MenuIcon />
                    </IconButton>
                    <Typography
                        variant="h6"
                        noWrap
                        component="div"
                        sx={{ display: { xs: 'none', sm: 'block' } }}
                    >
                        Téléconsultation - Espace Médecin
                    </Typography>
                    <Box sx={{ flexGrow: 1 }} />
                    <Box sx={{ display: { xs: 'none', md: 'flex' }, alignItems: 'center' }}>
                        <IconButton
                            size="large"
                            aria-label="show new notifications"
                            color="inherit"
                        >
                            <Badge badgeContent={0} color="error">
                                <NotificationsIcon />
                            </Badge>
                        </IconButton>
                        <Box sx={{ ml: 2, display: 'flex', alignItems: 'center' }}>
                            <Typography variant="body1" sx={{ mr: 1 }}>



Continuer

Modifier
Continuons avec le code du header du médecin et ensuite les autres composants de navigation.

src/components/medecin/MedecinHeader.jsx (suite)
jsx
                        <Box sx={{ ml: 2, display: 'flex', alignItems: 'center' }}>
                            <Typography variant="body1" sx={{ mr: 1 }}>
                                Dr. {currentUser?.prenom} {currentUser?.nom}
                            </Typography>
                            <IconButton
                                size="large"
                                edge="end"
                                aria-label="account of current user"
                                aria-controls={menuId}
                                aria-haspopup="true"
                                onClick={handleProfileMenuOpen}
                                color="inherit"
                            >
                                <Avatar sx={{ width: 32, height: 32, bgcolor: 'secondary.main' }}>
                                    {currentUser?.prenom?.charAt(0)}{currentUser?.nom?.charAt(0)}
                                </Avatar>
                            </IconButton>
                        </Box>
                    </Box>
                    <Box sx={{ display: { xs: 'flex', md: 'none' } }}>
                        <IconButton
                            size="large"
                            aria-label="show more"
                            aria-controls={mobileMenuId}
                            aria-haspopup="true"
                            onClick={handleMobileMenuOpen}
                            color="inherit"
                        >
                            <MoreIcon />
                        </IconButton>
                    </Box>
                </Toolbar>
            </AppBar>
            {renderMobileMenu}
            {renderMenu}
        </>
    );
};

export default MedecinHeader;
src/components/medecin/MedecinSidebar.jsx
jsx
import React from 'react';
import {
    Box,
    Drawer,
    List,
    ListItem,
    ListItemButton,
    ListItemIcon,
    ListItemText,
    Toolbar,
    Divider
} from '@mui/material';
import {
    Dashboard as DashboardIcon,
    Today as TodayIcon,
    Folder as FolderIcon,
    Person as PersonIcon,
    Settings as SettingsIcon
} from '@mui/icons-material';
import { useNavigate, useLocation } from 'react-router-dom';

const drawerWidth = 240;

const MedecinSidebar = ({ open, toggleDrawer }) => {
    const navigate = useNavigate();
    const location = useLocation();

    const menuItems = [
        {
            text: 'Tableau de bord',
            icon: <DashboardIcon />,
            path: '/medecin/dashboard'
        },
        {
            text: 'Mes rendez-vous',
            icon: <TodayIcon />,
            path: '/medecin/rendez-vous'
        },
        {
            text: 'Dossiers médicaux',
            icon: <FolderIcon />,
            path: '/medecin/dossiers'
        },
        { divider: true },
        {
            text: 'Mon profil',
            icon: <PersonIcon />,
            path: '/medecin/profile'
        },
        {
            text: 'Paramètres',
            icon: <SettingsIcon />,
            path: '/medecin/parametres'
        }
    ];

    return (
        <Drawer
            variant="permanent"
            sx={{
                width: drawerWidth,
                flexShrink: 0,
                [`& .MuiDrawer-paper`]: {
                    width: drawerWidth,
                    boxSizing: 'border-box',
                    whiteSpace: 'nowrap',
                    overflowX: 'hidden',
                    transition: (theme) => theme.transitions.create('width', {
                        easing: theme.transitions.easing.sharp,
                        duration: theme.transitions.duration.enteringScreen,
                    }),
                    ...(!open && {
                        width: theme => theme.spacing(7),
                        transition: (theme) => theme.transitions.create('width', {
                            easing: theme.transitions.easing.sharp,
                            duration: theme.transitions.duration.leavingScreen,
                        }),
                    }),
                },
            }}
            open={open}
        >
            <Toolbar />
            <Box sx={{ overflow: 'auto' }}>
                <List>
                    {menuItems.map((item, index) => (
                        item.divider ? (
                            <Divider key={`divider-${index}`} sx={{ my: 1 }} />
                        ) : (
                            <ListItem
                                key={item.text}
                                disablePadding
                                sx={{
                                    display: 'block',
                                    backgroundColor: location.pathname === item.path ? 'rgba(0, 0, 0, 0.04)' : 'transparent'
                                }}
                            >
                                <ListItemButton
                                    sx={{
                                        minHeight: 48,
                                        justifyContent: open ? 'initial' : 'center',
                                        px: 2.5,
                                    }}
                                    onClick={() => navigate(item.path)}
                                >
                                    <ListItemIcon
                                        sx={{
                                            minWidth: 0,
                                            mr: open ? 3 : 'auto',
                                            justifyContent: 'center',
                                        }}
                                    >
                                        {item.icon}
                                    </ListItemIcon>
                                    <ListItemText primary={item.text} sx={{ opacity: open ? 1 : 0 }} />
                                </ListItemButton>
                            </ListItem>
                        )
                    ))}
                </List>
            </Box>
        </Drawer>
    );
};

export default MedecinSidebar;
Maintenant, mettons à jour le layout du médecin pour inclure ces composants
jsx
import React, { useState } from 'react';
import { Routes, Route } from 'react-router-dom';
import { Box, CssBaseline } from '@mui/material';
import MedecinDashboard from '../../pages/medecin/MedecinDashboard';
import RendezVousMedecin from '../../pages/medecin/RendezVousMedecin';
import MedecinHeader from '../medecin/MedecinHeader';
import MedecinSidebar from '../medecin/MedecinSidebar';
import NotFound from '../../pages/NotFound';

const MedecinLayout = () => {
    const [drawerOpen, setDrawerOpen] = useState(true);

    const toggleDrawer = () => {
        setDrawerOpen(!drawerOpen);
    };

    return (
        <Box sx={{ display: 'flex' }}>
            <CssBaseline />
            <MedecinHeader open={drawerOpen} toggleDrawer={toggleDrawer} />
            <MedecinSidebar open={drawerOpen} toggleDrawer={toggleDrawer} />
            <Box
                component="main"
                sx={{
                    flexGrow: 1,
                    height: '100vh',
                    overflow: 'auto',
                    padding: (theme) => theme.spacing(3),
                    paddingTop: '64px', // Hauteur de l'en-tête
                }}
            >
                <Routes>
                    <Route path="dashboard" element={<MedecinDashboard />} />
                    <Route path="rendez-vous" element={<RendezVousMedecin />} />
                    <Route path="*" element={<NotFound />} />
                </Routes>
            </Box>
        </Box>
    );
};

export default MedecinLayout;
Vous pouvez créer des composants similaires pour le patient et le secrétaire en adaptant les menus et les titres. Par exemple:

src/components/patient/PatientHeader.jsx et PatientSidebar.jsx
Structure similaire au médecin, mais avec des menus adaptés:

Tableau de bord
Mes rendez-vous
Mon dossier médical
Uploader une image
Mon profil
Paramètres
src/components/secretaire/SecretaireHeader.jsx et SecretaireSidebar.jsx
Structure similaire, avec des menus adaptés:

Tableau de bord
Gestion des rendez-vous
Recherche de patients
Recherche de médecins
Mon profil
Paramètres
6. Services et contrôleurs backend pour la gestion des rendez-vous
Maintenant, créons les services et contrôleurs backend nécessaires pour gérer les rendez-vous. Voici les éléments principaux:

RendezVousService.java
java
package com.teleconsultation.api.service;

import com.teleconsultation.api.models.*;
import com.teleconsultation.api.repository.MedecinRepository;
import com.teleconsultation.api.repository.PatientRepository;
import com.teleconsultation.api.repository.RendezVousRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;

@Service
public class RendezVousService {
    
    @Autowired
    private RendezVousRepository rendezVousRepository;
    
    @Autowired
    private MedecinRepository medecinRepository;
    
    @Autowired
    private PatientRepository patientRepository;
    
    @Autowired
    private EmailService emailService;
    
    public List<RendezVous> findAll() {
        return rendezVousRepository.findAll();
    }
    
    public RendezVous findById(Long id) {
        return rendezVousRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Rendez-vous non trouvé avec l'ID: " + id));
    }
    
    public List<RendezVous> findByMedecinId(Long medecinId) {
        Medecin medecin = medecinRepository.findById(medecinId)
                .orElseThrow(() -> new RuntimeException("Médecin non trouvé avec l'ID: " + medecinId));
        return rendezVousRepository.findByMedecinOrderByDateHeureDesc(medecin);
    }
    
    public List<RendezVous> findByPatientId(Long patientId) {
        Patient patient = patientRepository.findById(patientId)
                .orElseThrow(() -> new RuntimeException("Patient non trouvé avec l'ID: " + patientId));
        return rendezVousRepository.findByPatientOrderByDateHeureDesc(patient);
    }
    
    public List<RendezVous> findByPatientIdAndStatut(Long patientId, StatutRendezVous statut) {
        Patient patient = patientRepository.findById(patientId)
                .orElseThrow(() -> new RuntimeException("Patient non trouvé avec l'ID: " + patientId));
        return rendezVousRepository.findByPatientAndStatutOrderByDateHeureDesc(patient, statut);
    }
    
    public List<RendezVous> findValidatedByPatientId(Long patientId) {
        Patient patient = patientRepository.findById(patientId)
                .orElseThrow(() -> new RuntimeException("Patient non trouvé avec l'ID: " + patientId));
        return rendezVousRepository.findByPatientAndStatutOrderByDateHeureDesc(patient, StatutRendezVous.VALIDE);
    }
    
    public List<RendezVous> findTodayRendezVous() {
        LocalDateTime startOfDay = LocalDate.now().atStartOfDay();
        LocalDateTime endOfDay = startOfDay.plusDays(1);
        return rendezVousRepository.findByDateHeureBetweenOrderByDateHeureAsc(startOfDay, endOfDay);
    }
    
    @Transactional
    public RendezVous save(RendezVousRequest rendezVousRequest) {
        Patient patient = patientRepository.findById(rendezVousRequest.getPatientId())
                .orElseThrow(() -> new RuntimeException("Patient non trouvé avec l'ID: " + rendezVousRequest.getPatientId()));
        
        Medecin medecin = medecinRepository.findById(rendezVousRequest.getMedecinId())
                .orElseThrow(() -> new RuntimeException("Médecin non trouvé avec l'ID: " + rendezVousRequest.getMedecinId()));
        
        RendezVous rendezVous = new RendezVous();
        rendezVous.setPatient(patient);
        rendezVous.setMedecin(medecin);
        rendezVous.setDateHeure(rendezVousRequest.getDateHeure());
        rendezVous.setDuree(rendezVousRequest.getDuree());
        rendezVous.setMotif(rendezVousRequest.getMotif());
        rendezVous.setStatut(StatutRendezVous.PLANIFIE);
        
        RendezVous savedRendezVous = rendezVousRepository.save(rendezVous);
        
        // Envoyer une notification au médecin
        emailService.envoyerNotificationNouveauRendezVous(savedRendezVous);
        
        return savedRendezVous;
    }
    
    @Transactional
    public RendezVous update(Long id, RendezVousRequest rendezVousRequest) {
        RendezVous rendezVous = findById(id);
        
        Patient patient = patientRepository.findById(rendezVousRequest.getPatientId())
                .orElseThrow(() -> new RuntimeException("Patient non trouvé avec l'ID: " + rendezVousRequest.getPatientId()));
        
        Medecin medecin = medecinRepository.findById(rendezVousRequest.getMedecinId())
                .orElseThrow(() -> new RuntimeException("Médecin non trouvé avec l'ID: " + rendezVousRequest.getMedecinId()));
        
        rendezVous.setPatient(patient);
        rendezVous.setMedecin(medecin);
        rendezVous.setDateHeure(rendezVousRequest.getDateHeure());
        rendezVous.setDuree(rendezVousRequest.getDuree());
        rendezVous.setMotif(rendezVousRequest.getMotif());
        
        return rendezVousRepository.save(rendezVous);
    }
    
    @Transactional
    public RendezVous valider(Long id) {
        RendezVous rendezVous = findById(id);
        rendezVous.setStatut(StatutRendezVous.VALIDE);
        
        RendezVous updatedRendezVous = rendezVousRepository.save(rendezVous);
        
        // Envoyer une notification au patient
        emailService.envoyerNotificationRendezVousValide(updatedRendezVous);
        
        return updatedRendezVous;
    }
    
    @Transactional
    public RendezVous rejeter(Long id, String motif) {
        RendezVous rendezVous = findById(id);
        rendezVous.setStatut(StatutRendezVous.REJETE);
        // Si un motif de rejet est fourni, on pourrait l'enregistrer dans un champ commentaire
        
        RendezVous updatedRendezVous = rendezVousRepository.save(rendezVous);
        
        // Envoyer une notification au patient avec le motif du rejet
        emailService.envoyerNotificationRendezVousRejete(updatedRendezVous, motif);
        
        return updatedRendezVous;
    }
    
    @Transactional
    public void delete(Long id) {
        rendezVousRepository.deleteById(id);
    }
}
RendezVousController.java
java
package com.teleconsultation.api.controllers;

import com.teleconsultation.api.models.RendezVous;
import com.teleconsultation.api.payload.request.RendezVousRequest;
import com.teleconsultation.api.payload.request.RejetRequest;
import com.teleconsultation.api.payload.response.MessageResponse;
import com.teleconsultation.api.service.RendezVousService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;
import java.util.List;

@RestController
@RequestMapping("/api/rendez-vous")
public class RendezVousController {
    
    @Autowired
    private RendezVousService rendezVousService;
    
    @GetMapping
    @PreAuthorize("hasRole('SECRETAIRE')")
    public ResponseEntity<List<RendezVous>> getAllRendezVous() {
        List<RendezVous> rendezVous = rendezVousService.findAll();
        return ResponseEntity.ok(rendezVous);
    }
    
    @GetMapping("/{id}")
    @PreAuthorize("hasAnyRole('SECRETAIRE', 'MEDECIN', 'PATIENT')")
    public ResponseEntity<RendezVous> getRendezVousById(@PathVariable Long id) {
        RendezVous rendezVous = rendezVousService.findById(id);
        return ResponseEntity.ok(rendezVous);
    }
    
    @PostMapping
    @PreAuthorize("hasRole('SECRETAIRE')")
    public ResponseEntity<RendezVous> createRendezVous(@Valid @RequestBody RendezVousRequest rendezVousRequest) {
        RendezVous rendezVous = rendezVousService.save(rendezVousRequest);
        return ResponseEntity.status(HttpStatus.CREATED).body(rendezVous);
    }
    
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('SECRETAIRE')")
    public ResponseEntity<RendezVous> updateRendezVous(@PathVariable Long id, @Valid @RequestBody RendezVousRequest rendezVousRequest) {
        RendezVous rendezVous = rendezVousService.update(id, rendezVousRequest);
        return ResponseEntity.ok(rendezVous);
    }
    
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('SECRETAIRE')")
    public ResponseEntity<?> deleteRendezVous(@PathVariable Long id) {
        rendezVousService.delete(id);
        return ResponseEntity.ok(new MessageResponse("Rendez-vous supprimé avec succès"));
    }
    
    @PutMapping("/{id}/valider")
    @PreAuthorize("hasRole('MEDECIN')")
    public ResponseEntity<RendezVous> validerRendezVous(@PathVariable Long id) {
        RendezVous rendezVous = rendezVousService.valider(id);
        return ResponseEntity.ok(rendezVous);
    }
    
    @PutMapping("/{id}/rejeter")
    @PreAuthorize("hasRole('MEDECIN')")
    public ResponseEntity<RendezVous> rejeterRendezVous(@PathVariable Long id, @RequestBody(required = false) RejetRequest rejetRequest) {
        String motif = rejetRequest != null ? rejetRequest.getMotif() : null;
        RendezVous rendezVous = rendezVousService.rejeter(id, motif);
        return ResponseEntity.ok(rendezVous);
    }
}
RendezVousRequest.java et RejetRequest.java
java
package com.teleconsultation.api.payload.request;

import lombok.Data;

import javax.validation.constraints.NotNull;
import java.time.LocalDateTime;

@Data
public class RendezVousRequest {
    @NotNull
    private Long patientId;
    
    @NotNull
    private Long medecinId;
    
    @NotNull
    private LocalDateTime dateHeure;
    
    @NotNull
    private Integer duree;
    
    private String motif;
}
java
package com.teleconsultation.api.payload.request;

import lombok.Data;

@Data
public class RejetRequest {
    private String motif;
}
RendezVousRepository.java
java
package com.teleconsultation.api.repository;

import com.teleconsultation.api.models.Medecin;
import com.teleconsultation.api.models.Patient;
import com.teleconsultation.api.models.RendezVous;
import com.teleconsultation.api.models.StatutRendezVous;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface RendezVousRepository extends JpaRepository<RendezVous, Long> {
    
    List<RendezVous> findByMedecinOrderByDateHeureDesc(Medecin medecin);
    
    List<RendezVous> findByPatientOrderByDateHeureDesc(Patient patient);
    
    List<RendezVous> findByPatientAndStatutOrderByDateHeureDesc(Patient patient, StatutRendezVous statut);
    
    List<RendezVous> findByDateHeureBetweenOrderByDateHeureAsc(LocalDateTime debut, LocalDateTime fin);
    
    List<RendezVous> findTop5ByMedecinAndDateHeureAfterAndStatutOrderByDateHeureAsc(
            Medecin medecin, LocalDateTime dateHeure, StatutRendezVous statut);
}
Ces composants forment la base de la gestion des rendez-vous dans notre application. Ils permettent:

Au secrétaire médical de créer, modifier et supprimer des rendez-vous
Au médecin de consulter, valider ou rejeter des rendez-vous
Au patient de consulter ses rendez-vous validés
Dans la prochaine phase, nous développerons les fonctionnalités de gestion des dossiers médicaux et d'upload d'images DICOM.




ajoute moi les en-têtes et barres latérales pour le patient et le sécrétaire

Modifier
Bien sûr, voici les en-têtes et barres latérales pour le patient et le secrétaire:

En-tête et barre latérale pour le patient
src/components/patient/PatientHeader.jsx
jsx
import React, { useState } from 'react';
import {
    AppBar,
    Toolbar,
    IconButton,
    Typography,
    Menu,
    MenuItem,
    Badge,
    Box,
    Avatar
} from '@mui/material';
import {
    Menu as MenuIcon,
    Notifications as NotificationsIcon,
    AccountCircle,
    MoreVert as MoreIcon
} from '@mui/icons-material';
import { useAuth } from '../../context/AuthContext';
import { useNavigate } from 'react-router-dom';

const PatientHeader = ({ open, toggleDrawer }) => {
    const [anchorEl, setAnchorEl] = useState(null);
    const [mobileMoreAnchorEl, setMobileMoreAnchorEl] = useState(null);

    const isMenuOpen = Boolean(anchorEl);
    const isMobileMenuOpen = Boolean(mobileMoreAnchorEl);

    const { currentUser, logout } = useAuth();
    const navigate = useNavigate();

    const handleProfileMenuOpen = (event) => {
        setAnchorEl(event.currentTarget);
    };

    const handleMobileMenuClose = () => {
        setMobileMoreAnchorEl(null);
    };

    const handleMenuClose = () => {
        setAnchorEl(null);
        handleMobileMenuClose();
    };

    const handleMobileMenuOpen = (event) => {
        setMobileMoreAnchorEl(event.currentTarget);
    };

    const handleLogout = () => {
        logout();
        navigate('/login');
    };

    const handleProfile = () => {
        handleMenuClose();
        navigate('/patient/profile');
    };

    const menuId = 'primary-search-account-menu';
    const renderMenu = (
        <Menu
            anchorEl={anchorEl}
            anchorOrigin={{ vertical: 'top', horizontal: 'right' }}
            id={menuId}
            keepMounted
            transformOrigin={{ vertical: 'top', horizontal: 'right' }}
            open={isMenuOpen}
            onClose={handleMenuClose}
        >
            <MenuItem onClick={handleProfile}>Mon Profil</MenuItem>
            <MenuItem onClick={handleLogout}>Déconnexion</MenuItem>
        </Menu>
    );

    const mobileMenuId = 'primary-search-account-menu-mobile';
    const renderMobileMenu = (
        <Menu
            anchorEl={mobileMoreAnchorEl}
            anchorOrigin={{ vertical: 'top', horizontal: 'right' }}
            id={mobileMenuId}
            keepMounted
            transformOrigin={{ vertical: 'top', horizontal: 'right' }}
            open={isMobileMenuOpen}
            onClose={handleMobileMenuClose}
        >
            <MenuItem>
                <IconButton
                    size="large"
                    aria-label="show new notifications"
                    color="inherit"
                >
                    <Badge badgeContent={0} color="error">
                        <NotificationsIcon />
                    </Badge>
                </IconButton>
                <p>Notifications</p>
            </MenuItem>
            <MenuItem onClick={handleProfileMenuOpen}>
                <IconButton
                    size="large"
                    aria-label="account of current user"
                    aria-controls="primary-search-account-menu"
                    aria-haspopup="true"
                    color="inherit"
                >
                    <AccountCircle />
                </IconButton>
                <p>Profil</p>
            </MenuItem>
        </Menu>
    );

    return (
        <>
            <AppBar position="fixed" sx={{ zIndex: (theme) => theme.zIndex.drawer + 1 }}>
                <Toolbar>
                    <IconButton
                        edge="start"
                        color="inherit"
                        aria-label="open drawer"
                        onClick={toggleDrawer}
                        sx={{
                            marginRight: '36px',
                        }}
                    >
                        <MenuIcon />
                    </IconButton>
                    <Typography
                        variant="h6"
                        noWrap
                        component="div"
                        sx={{ display: { xs: 'none', sm: 'block' } }}
                    >
                        Téléconsultation - Espace Patient
                    </Typography>
                    <Box sx={{ flexGrow: 1 }} />
                    <Box sx={{ display: { xs: 'none', md: 'flex' }, alignItems: 'center' }}>
                        <IconButton
                            size="large"
                            aria-label="show new notifications"
                            color="inherit"
                        >
                            <Badge badgeContent={0} color="error">
                                <NotificationsIcon />
                            </Badge>
                        </IconButton>
                        <Box sx={{ ml: 2, display: 'flex', alignItems: 'center' }}>
                            <Typography variant="body1" sx={{ mr: 1 }}>
                                {currentUser?.prenom} {currentUser?.nom}
                            </Typography>
                            <IconButton
                                size="large"
                                edge="end"
                                aria-label="account of current user"
                                aria-controls={menuId}
                                aria-haspopup="true"
                                onClick={handleProfileMenuOpen}
                                color="inherit"
                            >
                                <Avatar sx={{ width: 32, height: 32, bgcolor: 'primary.main' }}>
                                    {currentUser?.prenom?.charAt(0)}{currentUser?.nom?.charAt(0)}
                                </Avatar>
                            </IconButton>
                        </Box>
                    </Box>
                    <Box sx={{ display: { xs: 'flex', md: 'none' } }}>
                        <IconButton
                            size="large"
                            aria-label="show more"
                            aria-controls={mobileMenuId}
                            aria-haspopup="true"
                            onClick={handleMobileMenuOpen}
                            color="inherit"
                        >
                            <MoreIcon />
                        </IconButton>
                    </Box>
                </Toolbar>
            </AppBar>
            {renderMobileMenu}
            {renderMenu}
        </>
    );
};

export default PatientHeader;
src/components/patient/PatientSidebar.jsx
jsx
import React from 'react';
import {
    Box,
    Drawer,
    List,
    ListItem,
    ListItemButton,
    ListItemIcon,
    ListItemText,
    Toolbar,
    Divider
} from '@mui/material';
import {
    Dashboard as DashboardIcon,
    Today as TodayIcon,
    Folder as FolderIcon,
    CloudUpload as CloudUploadIcon,
    Person as PersonIcon,
    Settings as SettingsIcon
} from '@mui/icons-material';
import { useNavigate, useLocation } from 'react-router-dom';

const drawerWidth = 240;

const PatientSidebar = ({ open, toggleDrawer }) => {
    const navigate = useNavigate();
    const location = useLocation();

    const menuItems = [
        {
            text: 'Tableau de bord',
            icon: <DashboardIcon />,
            path: '/patient/dashboard'
        },
        {
            text: 'Mes rendez-vous',
            icon: <TodayIcon />,
            path: '/patient/rendez-vous'
        },
        {
            text: 'Mon dossier médical',
            icon: <FolderIcon />,
            path: '/patient/dossier'
        },
        {
            text: 'Télécharger image',
            icon: <CloudUploadIcon />,
            path: '/patient/upload'
        },
        { divider: true },
        {
            text: 'Mon profil',
            icon: <PersonIcon />,
            path: '/patient/profile'
        },
        {
            text: 'Paramètres',
            icon: <SettingsIcon />,
            path: '/patient/parametres'
        }
    ];

    return (
        <Drawer
            variant="permanent"
            sx={{
                width: drawerWidth,
                flexShrink: 0,
                [`& .MuiDrawer-paper`]: {
                    width: drawerWidth,
                    boxSizing: 'border-box',
                    whiteSpace: 'nowrap',
                    overflowX: 'hidden',
                    transition: (theme) => theme.transitions.create('width', {
                        easing: theme.transitions.easing.sharp,
                        duration: theme.transitions.duration.enteringScreen,
                    }),
                    ...(!open && {
                        width: theme => theme.spacing(7),
                        transition: (theme) => theme.transitions.create('width', {
                            easing: theme.transitions.easing.sharp,
                            duration: theme.transitions.duration.leavingScreen,
                        }),
                    }),
                },
            }}
            open={open}
        >
            <Toolbar />
            <Box sx={{ overflow: 'auto' }}>
                <List>
                    {menuItems.map((item, index) => (
                        item.divider ? (
                            <Divider key={`divider-${index}`} sx={{ my: 1 }} />
                        ) : (
                            <ListItem
                                key={item.text}
                                disablePadding
                                sx={{
                                    display: 'block',
                                    backgroundColor: location.pathname === item.path ? 'rgba(0, 0, 0, 0.04)' : 'transparent'
                                }}
                            >
                                <ListItemButton
                                    sx={{
                                        minHeight: 48,
                                        justifyContent: open ? 'initial' : 'center',
                                        px: 2.5,
                                    }}
                                    onClick={() => navigate(item.path)}
                                >
                                    <ListItemIcon
                                        sx={{
                                            minWidth: 0,
                                            mr: open ? 3 : 'auto',
                                            justifyContent: 'center',
                                        }}
                                    >
                                        {item.icon}
                                    </ListItemIcon>
                                    <ListItemText primary={item.text} sx={{ opacity: open ? 1 : 0 }} />
                                </ListItemButton>
                            </ListItem>
                        )
                    ))}
                </List>
            </Box>
        </Drawer>
    );
};

export default PatientSidebar;
src/components/layouts/PatientLayout.jsx (mise à jour)
jsx
import React, { useState } from 'react';
import { Routes, Route } from 'react-router-dom';
import { Box, CssBaseline } from '@mui/material';
import PatientDashboard from '../../pages/patient/PatientDashboard';
import RendezVousPatient from '../../pages/patient/RendezVousPatient';
import PatientHeader from '../patient/PatientHeader';
import PatientSidebar from '../patient/PatientSidebar';
import NotFound from '../../pages/NotFound';

const PatientLayout = () => {
    const [drawerOpen, setDrawerOpen] = useState(true);

    const toggleDrawer = () => {
        setDrawerOpen(!drawerOpen);
    };

    return (
        <Box sx={{ display: 'flex' }}>
            <CssBaseline />
            <PatientHeader open={drawerOpen} toggleDrawer={toggleDrawer} />
            <PatientSidebar open={drawerOpen} toggleDrawer={toggleDrawer} />
            <Box
                component="main"
                sx={{
                    flexGrow: 1,
                    height: '100vh',
                    overflow: 'auto',
                    padding: (theme) => theme.spacing(3),
                    paddingTop: '64px', // Hauteur de l'en-tête
                }}
            >
                <Routes>
                    <Route path="dashboard" element={<PatientDashboard />} />
                    <Route path="rendez-vous" element={<RendezVousPatient />} />
                    <Route path="*" element={<NotFound />} />
                </Routes>
            </Box>
        </Box>
    );
};

export default PatientLayout;
En-tête et barre latérale pour le secrétaire
src/components/secretaire/SecretaireHeader.jsx
jsx
import React, { useState } from 'react';
import {
    AppBar,
    Toolbar,
    IconButton,
    Typography,
    Menu,
    MenuItem,
    Badge,
    Box,
    Avatar
} from '@mui/material';
import {
    Menu as MenuIcon,
    Notifications as NotificationsIcon,
    AccountCircle,
    MoreVert as MoreIcon
} from '@mui/icons-material';
import { useAuth } from '../../context/AuthContext';
import { useNavigate } from 'react-router-dom';

const SecretaireHeader = ({ open, toggleDrawer }) => {
    const [anchorEl, setAnchorEl] = useState(null);
    const [mobileMoreAnchorEl, setMobileMoreAnchorEl] = useState(null);

    const isMenuOpen = Boolean(anchorEl);
    const isMobileMenuOpen = Boolean(mobileMoreAnchorEl);

    const { currentUser, logout } = useAuth();
    const navigate = useNavigate();

    const handleProfileMenuOpen = (event) => {
        setAnchorEl(event.currentTarget);
    };

    const handleMobileMenuClose = () => {
        setMobileMoreAnchorEl(null);
    };

    const handleMenuClose = () => {
        setAnchorEl(null);
        handleMobileMenuClose();
    };

    const handleMobileMenuOpen = (event) => {
        setMobileMoreAnchorEl(event.currentTarget);
    };

    const handleLogout = () => {
        logout();
        navigate('/login');
    };

    const handleProfile = () => {
        handleMenuClose();
        navigate('/secretaire/profile');
    };

    const menuId = 'primary-search-account-menu';
    const renderMenu = (
        <Menu
            anchorEl={anchorEl}
            anchorOrigin={{ vertical: 'top', horizontal: 'right' }}
            id={menuId}
            keepMounted
            transformOrigin={{ vertical: 'top', horizontal: 'right' }}
            open={isMenuOpen}
            onClose={handleMenuClose}
        >
            <MenuItem onClick={handleProfile}>Mon Profil</MenuItem>
            <MenuItem onClick={handleLogout}>Déconnexion</MenuItem>
        </Menu>
    );

    const mobileMenuId = 'primary-search-account-menu-mobile';
    const renderMobileMenu = (
        <Menu
            anchorEl={mobileMoreAnchorEl}
            anchorOrigin={{ vertical: 'top', horizontal: 'right' }}
            id={mobileMenuId}
            keepMounted
            transformOrigin={{ vertical: 'top', horizontal: 'right' }}
            open={isMobileMenuOpen}
            onClose={handleMobileMenuClose}
        >
            <MenuItem>
                <IconButton
                    size="large"
                    aria-label="show new notifications"
                    color="inherit"
                >
                    <Badge badgeContent={0} color="error">
                        <NotificationsIcon />
                    </Badge>
                </IconButton>
                <p>Notifications</p>
            </MenuItem>
            <MenuItem onClick={handleProfileMenuOpen}>
                <IconButton
                    size="large"
                    aria-label="account of current user"
                    aria-controls="primary-search-account-menu"
                    aria-haspopup="true"
                    color="inherit"
                >
                    <AccountCircle />
                </IconButton>
                <p>Profil</p>
            </MenuItem>
        </Menu>
    );

    return (
        <>
            <AppBar position="fixed" sx={{ zIndex: (theme) => theme.zIndex.drawer + 1 }}>
                <Toolbar>
                    <IconButton
                        edge="start"
                        color="inherit"
                        aria-label="open drawer"
                        onClick={toggleDrawer}
                        sx={{
                            marginRight: '36px',
                        }}
                    >
                        <MenuIcon />
                    </IconButton>
                    <Typography
                        variant="h6"
                        noWrap
                        component="div"
                        sx={{ display: { xs: 'none', sm: 'block' } }}
                    >
                        Téléconsultation - Espace Secrétaire
                    </Typography>
                    <Box sx={{ flexGrow: 1 }} />
                    <Box sx={{ display: { xs: 'none', md: 'flex' }, alignItems: 'center' }}>
                        <IconButton
                            size="large"
                            aria-label="show new notifications"
                            color="inherit"
                        >
                            <Badge badgeContent={0} color="error">
                                <NotificationsIcon />
                            </Badge>
                        </IconButton>
                        <Box sx={{ ml: 2, display: 'flex', alignItems: 'center' }}>
                            <Typography variant="body1" sx={{ mr: 1 }}>
                                {currentUser?.prenom} {currentUser?.nom}
                            </Typography>
                            <IconButton
                                size="large"
                                edge="end"
                                aria-label="account of current user"
                                aria-controls={menuId}
                                aria-haspopup="true"
                                onClick={handleProfileMenuOpen}
                                color="inherit"
                            >
                                <Avatar sx={{ width: 32, height: 32, bgcolor: 'warning.main' }}>
                                    {currentUser?.prenom?.charAt(0)}{currentUser?.nom?.charAt(0)}
                                </Avatar>
                            </IconButton>
                        </Box>
                    </Box>
                    <Box sx={{ display: { xs: 'flex', md: 'none' } }}>
                        <IconButton
                            size="large"
                            aria-label="show more"
                            aria-controls={mobileMenuId}
                            aria-haspopup="true"
                            onClick={handleMobileMenuOpen}
                            color="inherit"
                        >
                            <MoreIcon />
                        </IconButton>
                    </Box>
                </Toolbar>
            </AppBar>
            {renderMobileMenu}
            {renderMenu}
        </>
    );
};

export default SecretaireHeader;
src/components/secretaire/SecretaireSidebar.jsx
jsx
import React from 'react';
import {
    Box,
    Drawer,
    List,
    ListItem,
    ListItemButton,
    ListItemIcon,
    ListItemText,
    Toolbar,
    Divider
} from '@mui/material';
import {
    Dashboard as DashboardIcon,
    Event as EventIcon,
    PersonSearch as PersonSearchIcon,
    CalendarToday as CalendarTodayIcon,
    Person as PersonIcon,
    Settings as SettingsIcon,
    MedicalServices as MedicalServicesIcon
} from '@mui/icons-material';
import { useNavigate, useLocation } from 'react-router-dom';

const drawerWidth = 240;

const SecretaireSidebar = ({ open, toggleDrawer }) => {
    const navigate = useNavigate();
    const location = useLocation();

    const menuItems = [
        {
            text: 'Tableau de bord',
            icon: <DashboardIcon />,
            path: '/secretaire/dashboard'
        },
        {
            text: 'Rendez-vous',
            icon: <EventIcon />,
            path: '/secretaire/rendez-vous'
        },
        {
            text: 'Planning',
            icon: <CalendarTodayIcon />,
            path: '/secretaire/planning'
        },
        {
            text: 'Patients',
            icon: <PersonSearchIcon />,
            path: '/secretaire/patients'
        },
        {
            text: 'Médecins',
            icon: <MedicalServicesIcon />,
            path: '/secretaire/medecins'
        },
        { divider: true },
        {
            text: 'Mon profil',
            icon: <PersonIcon />,
            path: '/secretaire/profile'
        },
        {
            text: 'Paramètres',
            icon: <SettingsIcon />,
            path: '/secretaire/parametres'
        }
    ];

    return (
        <Drawer
            variant="permanent"
            sx={{
                width: drawerWidth,
                flexShrink: 0,
                [`& .MuiDrawer-paper`]: {
                    width: drawerWidth,
                    boxSizing: 'border-box',
                    whiteSpace: 'nowrap',
                    overflowX: 'hidden',
                    transition: (theme) => theme.transitions.create('width', {
                        easing: theme.transitions.easing.sharp,
                        duration: theme.transitions.duration.enteringScreen,
                    }),
                    ...(!open && {
                        width: theme => theme.spacing(7),
                        transition: (theme) => theme.transitions.create('width', {
                            easing: theme.transitions.easing.sharp,
                            duration: theme.transitions.duration.leavingScreen,
                        }),
                    }),
                },
            }}
            open={open}
        >
            <Toolbar />
            <Box sx={{ overflow: 'auto' }}>
                <List>
                    {menuItems.map((item, index) => (
                        item.divider ? (
                            <Divider key={`divider-${index}`} sx={{ my: 1 }} />
                        ) : (
                            <ListItem
                                key={item.text}
                                disablePadding
                                sx={{
                                    display: 'block',
                                    backgroundColor: location.pathname === item.path ? 'rgba(0, 0, 0, 0.04)' : 'transparent'
                                }}
                            >
                                <ListItemButton
                                    sx={{
                                        minHeight: 48,
                                        justifyContent: open ? 'initial' : 'center',
                                        px: 2.5,
                                    }}
                                    onClick={() => navigate(item.path)}
                                >
                                    <ListItemIcon
                                        sx={{
                                            minWidth: 0,
                                            mr: open ? 3 : 'auto',
                                            justifyContent: 'center',
                                        }}
                                    >
                                        {item.icon}
                                    </ListItemIcon>
                                    <ListItemText primary={item.text} sx={{ opacity: open ? 1 : 0 }} />
                                </ListItemButton>
                            </ListItem>
                        )
                    ))}
                </List>
            </Box>
        </Drawer>
    );
};

export default SecretaireSidebar;
src/components/layouts/SecretaireLayout.jsx (mise à jour)
jsx
import React, { useState } from 'react';
import { Routes, Route } from 'react-router-dom';
import { Box, CssBaseline } from '@mui/material';
import SecretaireDashboard from '../../pages/secretaire/SecretaireDashboard';
import GestionRendezVous from '../../pages/secretaire/GestionRendezVous';
import SecretaireHeader from '../secretaire/SecretaireHeader';
import SecretaireSidebar from '../secretaire/SecretaireSidebar';
import NotFound from '../../pages/NotFound';

const SecretaireLayout = () => {
    const [drawerOpen, setDrawerOpen] = useState(true);

    const toggleDrawer = () => {
        setDrawerOpen(!drawerOpen);
    };

    return (
        <Box sx={{ display: 'flex' }}>
            <CssBaseline />
            <SecretaireHeader open={drawerOpen} toggleDrawer={toggleDrawer} />
            <SecretaireSidebar open={drawerOpen} toggleDrawer={toggleDrawer} />
            <Box
                component="main"
                sx={{
                    flexGrow: 1,
                    height: '100vh',
                    overflow: 'auto',
                    padding: (theme) => theme.spacing(3),
                    paddingTop: '64px', // Hauteur de l'en-tête
                }}
            >
                <Routes>
                    <Route path="dashboard" element={<SecretaireDashboard />} />
                    <Route path="rendez-vous" element={<GestionRendezVous />} />
                    <Route path="*" element={<NotFound />} />
                </Routes>
            </Box>
        </Box>
    );
};

export default SecretaireLayout;
Ces composants complètent les interfaces utilisateur pour les rôles de patient et de secrétaire, leur permettant de naviguer facilement entre les différentes fonctionnalités de l'application. Chaque rôle a sa propre barre latérale avec des options pertinentes et un en-tête adapté qui affiche les informations de l'utilisateur connecté.

Les layouts intègrent maintenant ces composants, créant ainsi une expérience utilisateur cohérente et intuitive pour chaque type d'utilisateur.




nous pouvons continuer

Modifier
Parfait ! Continuons avec la suite du développement. Nous avons maintenant une base solide avec l'authentification, la gestion des utilisateurs, et les interfaces de rendez-vous.

Phase 5: Gestion des dossiers médicaux et intégration DICOM
Dans cette phase, nous allons développer :

Gestion des dossiers médicaux pour les médecins et patients
Upload et visualisation d'images DICOM via Orthanc
Observations médicales par les médecins
1. Backend - Services et contrôleurs pour les dossiers médicaux
DossierMedicalService.java
java
package com.teleconsultation.api.service;

import com.teleconsultation.api.models.*;
import com.teleconsultation.api.repository.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

@Service
public class DossierMedicalService {

    @Autowired
    private DossierMedicalRepository dossierMedicalRepository;
    
    @Autowired
    private PatientRepository patientRepository;
    
    @Autowired
    private MedecinRepository medecinRepository;
    
    @Autowired
    private ObservationRepository observationRepository;
    
    @Autowired
    private ImageDICOMRepository imageDICOMRepository;

    public List<DossierMedical> findByMedecinId(Long medecinId) {
        Medecin medecin = medecinRepository.findById(medecinId)
                .orElseThrow(() -> new RuntimeException("Médecin non trouvé avec l'ID: " + medecinId));
        return dossierMedicalRepository.findByMedecinOrderByDateCreationDesc(medecin);
    }

    public DossierMedical findById(Long id) {
        return dossierMedicalRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Dossier médical non trouvé avec l'ID: " + id));
    }

    public Optional<DossierMedical> findByPatientId(Long patientId) {
        Patient patient = patientRepository.findById(patientId)
                .orElseThrow(() -> new RuntimeException("Patient non trouvé avec l'ID: " + patientId));
        return dossierMedicalRepository.findByPatient(patient);
    }

    public Map<String, Object> getDossierInfo(Long patientId) {
        Map<String, Object> info = new HashMap<>();
        
        Optional<DossierMedical> dossierOpt = findByPatientId(patientId);
        
        if (dossierOpt.isPresent()) {
            DossierMedical dossier = dossierOpt.get();
            info.put("exists", true);
            info.put("nombreObservations", dossier.getObservations().size());
            info.put("nombreImages", dossier.getImagesDICOM().size());
            info.put("derniereMiseAJour", dossier.getDateCreation());
            
            // Dernière observation
            if (!dossier.getObservations().isEmpty()) {
                Observation derniere = dossier.getObservations().get(dossier.getObservations().size() - 1);
                info.put("derniereMiseAJour", derniere.getDateCreation());
            }
        } else {
            info.put("exists", false);
            info.put("nombreObservations", 0);
            info.put("nombreImages", 0);
            info.put("derniereMiseAJour", null);
        }
        
        return info;
    }

    @Transactional
    public DossierMedical createOrGetDossier(Long patientId, Long medecinId) {
        Patient patient = patientRepository.findById(patientId)
                .orElseThrow(() -> new RuntimeException("Patient non trouvé avec l'ID: " + patientId));
        
        Medecin medecin = medecinRepository.findById(medecinId)
                .orElseThrow(() -> new RuntimeException("Médecin non trouvé avec l'ID: " + medecinId));

        Optional<DossierMedical> existingDossier = dossierMedicalRepository.findByPatient(patient);
        
        if (existingDossier.isPresent()) {
            return existingDossier.get();
        } else {
            DossierMedical dossier = new DossierMedical();
            dossier.setPatient(patient);
            dossier.setMedecin(medecin);
            return dossierMedicalRepository.save(dossier);
        }
    }

    @Transactional
    public Observation ajouterObservation(Long dossierId, String contenu, Long medecinId) {
        DossierMedical dossier = findById(dossierId);
        Medecin medecin = medecinRepository.findById(medecinId)
                .orElseThrow(() -> new RuntimeException("Médecin non trouvé avec l'ID: " + medecinId));

        Observation observation = new Observation();
        observation.setDossierMedical(dossier);
        observation.setMedecin(medecin);
        observation.setContenu(contenu);

        return observationRepository.save(observation);
    }

    @Transactional
    public ImageDICOM ajouterImageDICOM(Long dossierId, String orthancId, String description) {
        DossierMedical dossier = findById(dossierId);

        ImageDICOM image = new ImageDICOM();
        image.setDossierMedical(dossier);
        image.setOrthancId(orthancId);
        image.setDescription(description);

        return imageDICOMRepository.save(image);
    }

    public List<Observation> getObservationsByDossier(Long dossierId) {
        DossierMedical dossier = findById(dossierId);
        return observationRepository.findByDossierMedicalOrderByDateCreationDesc(dossier);
    }

    public List<ImageDICOM> getImagesByDossier(Long dossierId) {
        DossierMedical dossier = findById(dossierId);
        return imageDICOMRepository.findByDossierMedicalOrderByDateUploadDesc(dossier);
    }
}
DossierMedicalController.java
java
package com.teleconsultation.api.controllers;

import com.teleconsultation.api.models.DossierMedical;
import com.teleconsultation.api.models.ImageDICOM;
import com.teleconsultation.api.models.Observation;
import com.teleconsultation.api.payload.request.ObservationRequest;
import com.teleconsultation.api.payload.response.MessageResponse;
import com.teleconsultation.api.service.DossierMedicalService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;
import java.util.List;
import java.util.Map;
import java.util.Optional;

@RestController
@RequestMapping("/api/dossiers")
public class DossierMedicalController {

    @Autowired
    private DossierMedicalService dossierMedicalService;

    @GetMapping("/medecin/{medecinId}")
    @PreAuthorize("hasRole('MEDECIN') and #medecinId == authentication.principal.id")
    public ResponseEntity<List<DossierMedical>> getDossiersByMedecin(@PathVariable Long medecinId) {
        List<DossierMedical> dossiers = dossierMedicalService.findByMedecinId(medecinId);
        return ResponseEntity.ok(dossiers);
    }

    @GetMapping("/patient/{patientId}")
    @PreAuthorize("hasRole('PATIENT') and #patientId == authentication.principal.id")
    public ResponseEntity<DossierMedical> getDossierByPatient(@PathVariable Long patientId) {
        Optional<DossierMedical> dossier = dossierMedicalService.findByPatientId(patientId);
        return dossier.map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @GetMapping("/patient/{patientId}/info")
    @PreAuthorize("hasRole('PATIENT') and #patientId == authentication.principal.id")
    public ResponseEntity<Map<String, Object>> getDossierInfo(@PathVariable Long patientId) {
        Map<String, Object> info = dossierMedicalService.getDossierInfo(patientId);
        return ResponseEntity.ok(info);
    }

    @GetMapping("/{id}")
    @PreAuthorize("hasAnyRole('MEDECIN', 'PATIENT')")
    public ResponseEntity<DossierMedical> getDossierById(@PathVariable Long id) {
        DossierMedical dossier = dossierMedicalService.findById(id);
        return ResponseEntity.ok(dossier);
    }

    @PostMapping("/{id}/observations")
    @PreAuthorize("hasRole('MEDECIN')")
    public ResponseEntity<Observation> ajouterObservation(
            @PathVariable Long id,
            @Valid @RequestBody ObservationRequest observationRequest) {
        
        Observation observation = dossierMedicalService.ajouterObservation(
                id, 
                observationRequest.getContenu(), 
                observationRequest.getMedecinId()
        );
        
        return ResponseEntity.ok(observation);
    }

    @GetMapping("/{id}/observations")
    @PreAuthorize("hasAnyRole('MEDECIN', 'PATIENT')")
    public ResponseEntity<List<Observation>> getObservations(@PathVariable Long id) {
        List<Observation> observations = dossierMedicalService.getObservationsByDossier(id);
        return ResponseEntity.ok(observations);
    }

    @GetMapping("/{id}/images")
    @PreAuthorize("hasAnyRole('MEDECIN', 'PATIENT')")
    public ResponseEntity<List<ImageDICOM>> getImages(@PathVariable Long id) {
        List<ImageDICOM> images = dossierMedicalService.getImagesByDossier(id);
        return ResponseEntity.ok(images);
    }
}
Repositories nécessaires
java
// ObservationRepository.java
package com.teleconsultation.api.repository;

import com.teleconsultation.api.models.DossierMedical;
import com.teleconsultation.api.models.Observation;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ObservationRepository extends JpaRepository<Observation, Long> {
    List<Observation> findByDossierMedicalOrderByDateCreationDesc(DossierMedical dossierMedical);
}
java
// ImageDICOMRepository.java
package com.teleconsultation.api.repository;

import com.teleconsultation.api.models.DossierMedical;
import com.teleconsultation.api.models.ImageDICOM;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ImageDICOMRepository extends JpaRepository<ImageDICOM, Long> {
    List<ImageDICOM> findByDossierMedicalOrderByDateUploadDesc(DossierMedical dossierMedical);
}
Mise à jour du DossierMedicalRepository
java
package com.teleconsultation.api.repository;

import com.teleconsultation.api.models.DossierMedical;
import com.teleconsultation.api.models.Medecin;
import com.teleconsultation.api.models.Patient;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface DossierMedicalRepository extends JpaRepository<DossierMedical, Long> {
    
    List<DossierMedical> findByMedecinOrderByDateCreationDesc(Medecin medecin);
    
    Optional<DossierMedical> findByPatient(Patient patient);
    
    @Query("SELECT COUNT(DISTINCT d.patient) FROM DossierMedical d WHERE d.medecin = ?1")
    long countDistinctPatientsByMedecin(Medecin medecin);
}
ObservationRequest.java
java
package com.teleconsultation.api.payload.request;

import lombok.Data;

import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;

@Data
public class ObservationRequest {
    @NotBlank
    private String contenu;
    
    @NotNull
    private Long medecinId;
}
2. Frontend - Interface de consultation des dossiers médicaux
src/pages/medecin/DossiersMedicaux.jsx
jsx
import React, { useState, useEffect } from 'react';
import {
    Container,
    Typography,
    Paper,
    Button,
    Grid,
    TextField,
    Dialog,
    DialogTitle,
    DialogContent,
    DialogActions,
    Card,
    CardContent,
    CardActions,
    Box,
    Snackbar,
    Alert,
    List,
    ListItem,
    ListItemText,
    Divider,
    Chip
} from '@mui/material';
import {
    Search as SearchIcon,
    Add as AddIcon,
    Visibility as VisibilityIcon,
    Person as PersonIcon
} from '@mui/icons-material';
import { format } from 'date-fns';
import { fr } from 'date-fns/locale';
import { useAuth } from '../../context/AuthContext';
import {
    getDossiersMedicaux,
    getDossierMedical,
    ajouterObservation
} from '../../services/medecinService';

const DossiersMedicaux = () => {
    const [dossiers, setDossiers] = useState([]);
    const [filteredDossiers, setFilteredDossiers] = useState([]);
    const [selectedDossier, setSelectedDossier] = useState(null);
    const [searchQuery, setSearchQuery] = useState('');
    const [openDossierDialog, setOpenDossierDialog] = useState(false);
    const [openObservationDialog, setOpenObservationDialog] = useState(false);
    const [nouvelleObservation, setNouvelleObservation] = useState('');
    const [loading, setLoading] = useState(true);
    const [snackbar, setSnackbar] = useState({
        open: false,
        message: '',
        severity: 'success'
    });

    const { currentUser } = useAuth();

    useEffect(() => {
        fetchDossiers();
    }, []);

    useEffect(() => {
        if (searchQuery) {
            const filtered = dossiers.filter(dossier =>
                `${dossier.patient.nom} ${dossier.patient.prenom}`
                    .toLowerCase()
                    .includes(searchQuery.toLowerCase())
            );
            setFilteredDossiers(filtered);
        } else {
            setFilteredDossiers(dossiers);
        }
    }, [searchQuery, dossiers]);

    const fetchDossiers = async () => {
        try {
            setLoading(true);
            if (currentUser?.id) {
                const response = await getDossiersMedicaux(currentUser.id);
                setDossiers(response.data);
                setFilteredDossiers(response.data);
            }
        } catch (error) {
            console.error('Erreur lors du chargement des dossiers:', error);
            showSnackbar('Erreur lors du chargement des dossiers', 'error');
        } finally {
            setLoading(false);
        }
    };

    const handleOpenDossier = async (dossier) => {
        try {
            const response = await getDossierMedical(dossier.id);
            setSelectedDossier(response.data);
            setOpenDossierDialog(true);
        } catch (error) {
            console.error('Erreur lors du chargement du dossier:', error);
            showSnackbar('Erreur lors du chargement du dossier', 'error');
        }
    };

    const handleCloseDossier = () => {
        setOpenDossierDialog(false);
        setSelectedDossier(null);
    };

    const handleOpenObservationDialog = () => {
        setNouvelleObservation('');
        setOpenObservationDialog(true);
    };

    const handleCloseObservationDialog = () => {
        setOpenObservationDialog(false);
    };

    const handleAjouterObservation = async () => {
        if (!nouvelleObservation.trim()) {
            showSnackbar('Veuillez saisir une observation', 'error');
            return;
        }

        try {
            await ajouterObservation(selectedDossier.id, {
                contenu: nouvelleObservation,
                medecinId: currentUser.id
            });

            showSnackbar('Observation ajoutée avec succès');
            handleCloseObservationDialog();
            
            // Recharger le dossier pour voir la nouvelle observation
            const response = await getDossierMedical(selectedDossier.id);
            setSelectedDossier(response.data);
            
        } catch (error) {
            console.error('Erreur lors de l\'ajout de l\'observation:', error);
            showSnackbar('Erreur lors de l\'ajout de l\'observation', 'error');
        }
    };

    const showSnackbar = (message, severity = 'success') => {
        setSnackbar({
            open: true,
            message,
            severity
        });
    };

    const handleCloseSnackbar = () => {
        setSnackbar({ ...snackbar, open: false });
    };

    return (
        <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
            <Paper sx={{ p: 2, mb: 2 }}>
                <Typography variant="h5" gutterBottom>
                    Dossiers médicaux de mes patients
                </Typography>

                <Grid container spacing={2} alignItems="center" sx={{ mb: 3 }}>
                    <Grid item xs={12} md={6}>
                        <TextField
                            fullWidth
                            label="Rechercher un patient"
                            variant="outlined"
                            value={searchQuery}
                            onChange={(e) => setSearchQuery(e.target.value)}
                            InputProps={{
                                endAdornment: <SearchIcon />
                            }}
                        />
                    </Grid>
                </Grid>

                {loading ? (
                    <Typography>Chargement...</Typography>
                ) : (
                    <Grid container spacing={2}>
                        {filteredDossiers.length === 0 ? (
                            <Grid item xs={12}>
                                <Typography variant="body1" align="center">
                                    {searchQuery ? 'Aucun dossier trouvé pour cette recherche.' : 'Vous n\'avez pas encore de dossiers médicaux.'}
                                </Typography>
                            </Grid>
                        ) : (
                            filteredDossiers.map((dossier) => (
                                <Grid item xs={12} sm={6} md={4} key={dossier.id}>
                                    <Card>
                                        <CardContent>
                                            <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                                                <PersonIcon sx={{ mr: 1 }} />
                                                <Typography variant="h6">
                                                    {dossier.patient.nom} {dossier.patient.prenom}
                                                </Typography>
                                            </Box>
                                            
                                            <Typography variant="body2" color="text.secondary" gutterBottom>
                                                Date de naissance: {format(new Date(dossier.patient.dateNaissance), 'dd/MM/yyyy', { locale: fr })}
                                            </Typography>
                                            
                                            <Typography variant="body2" color="text.secondary" gutterBottom>
                                                Dossier créé: {format(new Date(dossier.dateCreation), 'dd/MM/yyyy', { locale: fr })}
                                            </Typography>
                                            
                                            <Box sx={{ display: 'flex', gap: 1, mt: 2 }}>
                                                <Chip 
                                                    label={`${dossier.observations?.length || 0} observations`} 
                                                    size="small" 
                                                    color="primary" 
                                                />
                                                <Chip 
                                                    label={`${dossier.imagesDICOM?.length || 0} images`} 
                                                    size="small" 
                                                    color="secondary" 
                                                />
                                            </Box>
                                        </CardContent>
                                        <CardActions>
                                            <Button
                                                size="small"
                                                variant="contained"
                                                startIcon={<VisibilityIcon />}
                                                onClick={() => handleOpenDossier(dossier)}
                                            >
                                                Consulter
                                            </Button>
                                        </CardActions>
                                    </Card>
                                </Grid>
                            ))
                        )}
                    </Grid>
                )}
            </Paper>

            {/* Dialog pour consulter un dossier */}
            <Dialog
                open={openDossierDialog}
                onClose={handleCloseDossier}
                maxWidth="md"
                fullWidth
            >
                <DialogTitle>
                    Dossier médical de {selectedDossier?.patient.nom} {selectedDossier?.patient.prenom}
                </DialogTitle>
                <DialogContent dividers>
                    {selectedDossier && (
                        <Box>
                            {/* Informations du patient */}
                            <Box sx={{ mb: 3 }}>
                                <Typography variant="subtitle1" gutterBottom>
                                    Informations du patient
                                </Typography>
                                <Grid container spacing={2}>
                                    <Grid item xs={12} sm={6}>
                                        <Typography variant="body2">
                                            <strong>Date de naissance:</strong> {format(new Date(selectedDossier.patient.dateNaissance), 'dd/MM/yyyy', { locale: fr })}
                                        </Typography>
                                    </Grid>
                                    <Grid item xs={12} sm={6}>
                                        <Typography variant="body2">
                                            <strong>N° Sécurité Sociale:</strong> {selectedDossier.patient.numeroSecuriteSociale}
                                        </Typography>
                                    </Grid>
                                    <Grid item xs={12}>
                                        <Typography variant="body2">
                                            <strong>Adresse:</strong> {selectedDossier.patient.adresse}
                                        </Typography>
                                    </Grid>
                                </Grid>
                            </Box>

                            {/* Observations */}
                            <Box sx={{ mb: 3 }}>
                                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                                    <Typography variant="subtitle1">
                                        Observations médicales
                                    </Typography>
                                    <Button
                                        variant="outlined"
                                        size="small"
                                        startIcon={<AddIcon />}
                                        onClick={handleOpenObservationDialog}
                                    >
                                        Ajouter
                                    </Button>
                                </Box>

                                {selectedDossier.observations && selectedDossier.observations.length > 0 ? (
                                    <List>
                                        {selectedDossier.observations.map((observation, index) => (
                                            <React.Fragment key={observation.id}>
                                                <ListItem alignItems="flex-start">
                                                    <ListItemText
                                                        primary={
                                                            <Typography variant="body2" color="text.secondary">
                                                                {format(new Date(observation.dateCreation), 'dd/MM/yyyy HH:mm', { locale: fr })} - 
                                                                Dr. {observation.medecin.nom} {observation.medecin.prenom}
                                                            </Typography>
                                                        }
                                                        secondary={
                                                            <Typography variant="body1" sx={{ mt: 1 }}>
                                                                {observation.contenu}
                                                            </Typography>
                                                        }
                                                    />
                                                </ListItem>
                                                {index < selectedDossier.observations.length - 1 && <Divider />}
                                            </React.Fragment>
                                        ))}
                                    </List>
                                ) : (
                                    <Typography variant="body2" color="text.secondary">
                                        Aucune observation pour ce patient.
                                    </Typography>
                                )}
                            </Box>

                            {/* Images DICOM */}
                            <Box>
                                <Typography variant="subtitle1" gutterBottom>
                                    Images DICOM ({selectedDossier.imagesDICOM?.length || 0})
                                </Typography>
                                {selectedDossier.imagesDICOM && selectedDossier.imagesDICOM.length > 0 ? (
                                    <Grid container spacing={2}>
                                        {selectedDossier.imagesDICOM.map((image) => (
                                            <Grid item xs={6} sm={4} md={3} key={image.id}>
                                                <Card variant="outlined">
                                                    <CardContent sx={{ p: 1 }}>
                                                        <Typography variant="body2" noWrap>
                                                            {image.description || 'Sans titre'}
                                                        </Typography>
                                                        <Typography variant="caption" color="text.secondary">
                                                            {format(new Date(image.dateUpload), 'dd/MM/yyyy', { locale: fr })}
                                                        </Typography>
                                                    </CardContent>
                                                    <CardActions sx={{ p: 1 }}>
                                                        <Button size="small">Visualiser</Button>
                                                    </CardActions>
                                                </Card>
                                            </Grid>
                                        ))}
                                    </Grid>
                                ) : (
                                    <Typography variant="body2" color="text.secondary">
                                        Aucune image DICOM pour ce patient.
                                    </Typography>
                                )}
                            </Box>
                        </Box>
                    )}
                </DialogContent>
                <DialogActions>
                    <Button onClick={handleCloseDossier}>Fermer</Button>
                </DialogActions>
            </Dialog>

            {/* Dialog pour ajouter une observation */}
            <Dialog
                open={openObservationDialog}
                onClose={handleCloseObservationDialog}
                maxWidth="md"
                fullWidth
            >
                <DialogTitle>Ajouter une observation</DialogTitle>
                <DialogContent>
                    <TextField
                        autoFocus
                        margin="dense"
                        label="Observation médicale"
                        fullWidth
                        multiline
                        rows={6}
                        value={nouvelleObservation}
                        onChange={(e) => setNouvelleObservation(e.target.value)}
                        placeholder="Saisissez votre observation médicale..."
                    />
                </DialogContent>
                <DialogActions>
                    <Button onClick={handleCloseObservationDialog}>Annuler</Button>
                    <Button 
                        onClick={handleAjouterObservation} 
                        variant="contained"
                        disabled={!nouvelleObservation.trim()}
                    >
                        Enregistrer
                    </Button>
                </DialogActions>
            </Dialog>

            <Snackbar
                open={snackbar.open}
                autoHideDuration={6000}
                onClose={handleCloseSnackbar}
                anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
            >
                <Alert
                    onClose={handleCloseSnackbar}
                    severity={snackbar.severity}
                    sx={{ width: '100%' }}
                >
                    {snackbar.message}
                </Alert>
            </Snackbar>
        </Container>
    );
};

export default DossiersMedicaux;
3. Interface patient pour consulter son dossier médical
src/pages/patient/DossierMedical.jsx
jsx
import React, { useState, useEffect } from 'react';
import {
    Container,
    Typography,
    Paper,
    Grid,
    Card,
    CardContent,
    Box,
    List,
    ListItem,
    ListItemText,
    Divider,
    Chip,
    CircularProgress,
    Alert
} from '@mui/material';
import {
    Person as PersonIcon,
    Assignment as AssignmentIcon,
    Image as ImageIcon
} from '@mui/icons-material';
import { format } from 'date-fns';
import { fr } from 'date-fns/locale';
import { useAuth } from '../../context/AuthContext';
import { getDossierMedical } from '../../services/patientService';

const DossierMedical = () => {
    const [dossier, setDossier] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    const { currentUser } = useAuth();

    useEffect(() => {
        fetchDossier();
    }, []);

    const fetchDossier = async () => {
        try {
            setLoading(true);
            if (currentUser?.id) {
                const response = await getDossierMedical(currentUser.id);
                setDossier(response.data);
            }
        } catch (error) {
            console.error('Erreur lors du chargement du dossier:', error);
            if (error.response?.status === 404) {
                setError('Vous n\'avez pas encore de dossier médical.');
            } else {
                setError('Erreur lors du chargement de votre dossier médical.');
            }
        } finally {
            setLoading(false);
        }
    };

    if (loading) {
        return (
            <Container maxWidth="lg" sx={{ mt: 4, mb: 4, textAlign: 'center' }}>
                <CircularProgress />
                <Typography variant="body1" sx={{ mt: 2 }}>
                    Chargement de votre dossier médical...
                </Typography>
            </Container>
        );
    }

   // src/pages/patient/DossierMedical.jsx (suite)

    if (error) {
        return (
            <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
                <Alert severity="info" sx={{ mb: 2 }}>
                    {error}
                </Alert>
            </Container>
        );
    }

    if (!dossier) {
        return (
            <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
                <Alert severity="info">
                    Vous n'avez pas encore de dossier médical.
                </Alert>
            </Container>
        );
    }

    return (
        <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
            <Typography variant="h4" gutterBottom>
                Mon dossier médical
            </Typography>

            <Grid container spacing={3}>
                {/* Informations personnelles */}
                <Grid item xs={12} md={4}>
                    <Paper sx={{ p: 2, height: '100%' }}>
                        <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <PersonIcon color="primary" sx={{ mr: 1 }} />
                            <Typography variant="h6">
                                Mes informations
                            </Typography>
                        </Box>
                        <Divider sx={{ mb: 2 }} />
                        
                        <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1 }}>
                            <Typography variant="body2">
                                <strong>Nom:</strong> {currentUser?.nom} {currentUser?.prenom}
                            </Typography>
                            <Typography variant="body2">
                                <strong>Date de naissance:</strong> {
                                    dossier.patient?.dateNaissance ? 
                                    format(new Date(dossier.patient.dateNaissance), 'dd/MM/yyyy', { locale: fr }) : 
                                    '-'
                                }
                            </Typography>
                            <Typography variant="body2">
                                <strong>N° Sécurité Sociale:</strong> {dossier.patient?.numeroSecuriteSociale || '-'}
                            </Typography>
                            <Typography variant="body2">
                                <strong>Adresse:</strong> {dossier.patient?.adresse || '-'}
                            </Typography>
                        </Box>
                    </Paper>
                </Grid>

                {/* Statistiques du dossier */}
                <Grid item xs={12} md={8}>
                    <Paper sx={{ p: 2, height: '100%' }}>
                        <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <AssignmentIcon color="primary" sx={{ mr: 1 }} />
                            <Typography variant="h6">
                                Résumé de mon dossier
                            </Typography>
                        </Box>
                        <Divider sx={{ mb: 2 }} />
                        
                        <Grid container spacing={2}>
                            <Grid item xs={12} sm={4}>
                                <Card variant="outlined">
                                    <CardContent sx={{ textAlign: 'center' }}>
                                        <Typography variant="h4" color="primary">
                                            {dossier.observations?.length || 0}
                                        </Typography>
                                        <Typography variant="body2" color="text.secondary">
                                            Observations médicales
                                        </Typography>
                                    </CardContent>
                                </Card>
                            </Grid>
                            <Grid item xs={12} sm={4}>
                                <Card variant="outlined">
                                    <CardContent sx={{ textAlign: 'center' }}>
                                        <Typography variant="h4" color="secondary">
                                            {dossier.imagesDICOM?.length || 0}
                                        </Typography>
                                        <Typography variant="body2" color="text.secondary">
                                            Images médicales
                                        </Typography>
                                    </CardContent>
                                </Card>
                            </Grid>
                            <Grid item xs={12} sm={4}>
                                <Card variant="outlined">
                                    <CardContent sx={{ textAlign: 'center' }}>
                                        <Typography variant="h6" color="success.main">
                                            Dr. {dossier.medecin?.nom} {dossier.medecin?.prenom}
                                        </Typography>
                                        <Typography variant="body2" color="text.secondary">
                                            Médecin référent
                                        </Typography>
                                    </CardContent>
                                </Card>
                            </Grid>
                        </Grid>
                    </Paper>
                </Grid>

                {/* Observations médicales */}
                <Grid item xs={12} md={8}>
                    <Paper sx={{ p: 2 }}>
                        <Typography variant="h6" gutterBottom>
                            Observations médicales
                        </Typography>
                        <Divider sx={{ mb: 2 }} />
                        
                        {dossier.observations && dossier.observations.length > 0 ? (
                            <List>
                                {dossier.observations.map((observation, index) => (
                                    <React.Fragment key={observation.id}>
                                        <ListItem alignItems="flex-start">
                                            <ListItemText
                                                primary={
                                                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                        <Typography variant="body2" color="text.secondary">
                                                            Dr. {observation.medecin?.nom} {observation.medecin?.prenom}
                                                        </Typography>
                                                        <Chip 
                                                            label={format(new Date(observation.dateCreation), 'dd/MM/yyyy HH:mm', { locale: fr })}
                                                            size="small"
                                                            color="primary"
                                                        />
                                                    </Box>
                                                }
                                                secondary={
                                                    <Typography variant="body1" sx={{ mt: 1 }}>
                                                        {observation.contenu}
                                                    </Typography>
                                                }
                                            />
                                        </ListItem>
                                        {index < dossier.observations.length - 1 && <Divider />}
                                    </React.Fragment>
                                ))}
                            </List>
                        ) : (
                            <Typography variant="body2" color="text.secondary">
                                Aucune observation médicale pour le moment.
                            </Typography>
                        )}
                    </Paper>
                </Grid>

                {/* Images DICOM */}
                <Grid item xs={12} md={4}>
                    <Paper sx={{ p: 2 }}>
                        <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <ImageIcon color="primary" sx={{ mr: 1 }} />
                            <Typography variant="h6">
                                Mes images médicales
                            </Typography>
                        </Box>
                        <Divider sx={{ mb: 2 }} />
                        
                        {dossier.imagesDICOM && dossier.imagesDICOM.length > 0 ? (
                            <Grid container spacing={1}>
                                {dossier.imagesDICOM.map((image) => (
                                    <Grid item xs={12} key={image.id}>
                                        <Card variant="outlined" sx={{ p: 1 }}>
                                            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                <Box>
                                                    <Typography variant="body2" noWrap>
                                                        {image.description || 'Image médicale'}
                                                    </Typography>
                                                    <Typography variant="caption" color="text.secondary">
                                                        {format(new Date(image.dateUpload), 'dd/MM/yyyy', { locale: fr })}
                                                    </Typography>
                                                </Box>
                                                <Chip label="DICOM" size="small" color="secondary" />
                                            </Box>
                                        </Card>
                                    </Grid>
                                ))}
                            </Grid>
                        ) : (
                            <Typography variant="body2" color="text.secondary">
                                Aucune image médicale pour le moment.
                            </Typography>
                        )}
                    </Paper>
                </Grid>
            </Grid>
        </Container>
    );
};

export default DossierMedical;

Maintenant, ajoutons les services pour le patient pour gérer les dossiers médicaux :

// src/services/patientService.js - Mise à jour pour les dossiers médicaux

import api from './api';

// Obtenir les prochains rendez-vous du patient
export const getProchainRendezVous = (patientId) => {
    return api.get(`/patient/${patientId}/rendez-vous/prochains`);
};

// Obtenir tous les rendez-vous du patient
export const getAllRendezVous = (patientId) => {
    return api.get(`/patient/${patientId}/rendez-vous`);
};

// Obtenir les informations du dossier médical (résumé)
export const getDossierInfo = (patientId) => {
    return api.get(`/dossiers/patient/${patientId}/info`);
};

// Obtenir le dossier médical complet
export const getDossierMedical = (patientId) => {
    return api.get(`/dossiers/patient/${patientId}`);
};

// Téléverser une image DICOM
export const uploadDicomImage = (dossierId, formData) => {
    return api.post(`/dicom/upload/${dossierId}`, formData, {
        headers: {
            'Content-Type': 'multipart/form-data'
        }
    });
};

// Obtenir les observations d'un dossier
export const getObservations = (dossierId) => {
    return api.get(`/dossiers/${dossierId}/observations`);
};

// Obtenir les images d'un dossier
export const getImages = (dossierId) => {
    return api.get(`/dossiers/${dossierId}/images`);
};

Maintenant, créons l'interface d'upload d'images DICOM pour le patient :

// src/pages/patient/UploadDicom.jsx

import React, { useState, useEffect } from 'react';
import {
    Container,
    Typography,
    Paper,
    Button,
    TextField,
    Box,
    Alert,
    LinearProgress,
    Card,
    CardContent,
    Grid,
    List,
    ListItem,
    ListItemText,
    ListItemIcon,
    Snackbar,
    Divider
} from '@mui/material';
import {
    CloudUpload as CloudUploadIcon,
    CheckCircle as CheckCircleIcon,
    Error as ErrorIcon,
    Image as ImageIcon,
    Info as InfoIcon
} from '@mui/icons-material';
import { useAuth } from '../../context/AuthContext';
import { getDossierInfo, uploadDicomImage } from '../../services/patientService';

const UploadDicom = () => {
    const [dossierInfo, setDossierInfo] = useState(null);
    const [selectedFile, setSelectedFile] = useState(null);
    const [description, setDescription] = useState('');
    const [uploading, setUploading] = useState(false);
    const [uploadProgress, setUploadProgress] = useState(0);
    const [uploadHistory, setUploadHistory] = useState([]);
    const [snackbar, setSnackbar] = useState({
        open: false,
        message: '',
        severity: 'success'
    });

    const { currentUser } = useAuth();

    useEffect(() => {
        fetchDossierInfo();
    }, []);

    const fetchDossierInfo = async () => {
        try {
            if (currentUser?.id) {
                const response = await getDossierInfo(currentUser.id);
                setDossierInfo(response.data);
            }
        } catch (error) {
            console.error('Erreur lors du chargement des informations du dossier:', error);
        }
    };

    const handleFileSelect = (event) => {
        const file = event.target.files[0];
        if (file) {
            // Vérifier le type de fichier
            const validTypes = ['.dcm', 'application/dicom'];
            const fileName = file.name.toLowerCase();
            const isValidType = fileName.endsWith('.dcm') || validTypes.includes(file.type);
            
            if (!isValidType) {
                showSnackbar('Veuillez sélectionner un fichier DICOM (.dcm)', 'error');
                return;
            }
            
            // Vérifier la taille du fichier (max 50MB)
            const maxSize = 50 * 1024 * 1024; // 50MB
            if (file.size > maxSize) {
                showSnackbar('Le fichier est trop volumineux (maximum 50MB)', 'error');
                return;
            }
            
            setSelectedFile(file);
        }
    };

    const handleUpload = async () => {
        if (!selectedFile) {
            showSnackbar('Veuillez sélectionner un fichier', 'error');
            return;
        }

        if (!description.trim()) {
            showSnackbar('Veuillez saisir une description', 'error');
            return;
        }

        if (!dossierInfo?.exists) {
            showSnackbar('Vous devez avoir un dossier médical pour télécharger des images', 'error');
            return;
        }

        try {
            setUploading(true);
            setUploadProgress(0);

            const formData = new FormData();
            formData.append('file', selectedFile);
            formData.append('description', description);

            // Simuler le progrès d'upload
            const progressInterval = setInterval(() => {
                setUploadProgress(prev => {
                    if (prev >= 90) {
                        clearInterval(progressInterval);
                        return prev;
                    }
                    return prev + 10;
                });
            }, 200);

            // Supposons que nous avons l'ID du dossier depuis dossierInfo
            const dossierId = 1; // À remplacer par l'ID réel du dossier
            await uploadDicomImage(dossierId, formData);

            clearInterval(progressInterval);
            setUploadProgress(100);

            // Ajouter à l'historique
            const newUpload = {
                id: Date.now(),
                fileName: selectedFile.name,
                description: description,
                uploadDate: new Date(),
                status: 'success'
            };
            setUploadHistory(prev => [newUpload, ...prev]);

            showSnackbar('Image DICOM téléchargée avec succès');
            
            // Réinitialiser le formulaire
            setSelectedFile(null);
            setDescription('');
            document.getElementById('file-input').value = '';
            
            // Actualiser les informations du dossier
            fetchDossierInfo();

        } catch (error) {
            console.error('Erreur lors du téléchargement:', error);
            
            const errorUpload = {
                id: Date.now(),
                fileName: selectedFile.name,
                description: description,
                uploadDate: new Date(),
                status: 'error',
                error: error.response?.data?.message || 'Erreur lors du téléchargement'
            };
            setUploadHistory(prev => [errorUpload, ...prev]);
            
            showSnackbar(
                error.response?.data?.message || 'Erreur lors du téléchargement de l\'image', 
                'error'
            );
        } finally {
            setUploading(false);
            setUploadProgress(0);
        }
    };

    const showSnackbar = (message, severity = 'success') => {
        setSnackbar({
            open: true,
            message,
            severity
        });
    };

    const handleCloseSnackbar = () => {
        setSnackbar({ ...snackbar, open: false });
    };

    const formatFileSize = (bytes) => {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    };

    return (
        <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
            <Typography variant="h4" gutterBottom>
                Télécharger une image DICOM
            </Typography>

            <Grid container spacing={3}>
                {/* Zone d'upload */}
                <Grid item xs={12} md={8}>
                    <Paper sx={{ p: 3 }}>
                        <Typography variant="h6" gutterBottom>
                            Ajouter une nouvelle image
                        </Typography>

                        {!dossierInfo?.exists && (
                            <Alert severity="warning" sx={{ mb: 2 }}>
                                Vous devez avoir un dossier médical créé par un médecin avant de pouvoir télécharger des images.
                            </Alert>
                        )}

                        <Box sx={{ mb: 3 }}>
                            <input
                                id="file-input"
                                type="file"
                                accept=".dcm,application/dicom"
                                style={{ display: 'none' }}
                                onChange={handleFileSelect}
                            />
                            <label htmlFor="file-input">
                                <Button
                                    variant="outlined"
                                    component="span"
                                    startIcon={<CloudUploadIcon />}
                                    fullWidth
                                    sx={{ mb: 2, p: 2 }}
                                    disabled={!dossierInfo?.exists}
                                >
                                    Choisir un fichier DICOM
                                </Button>
                            </label>

                            {selectedFile && (
                                <Card variant="outlined" sx={{ mb: 2 }}>
                                    <CardContent>
                                        <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                                            <ImageIcon sx={{ mr: 1 }} />
                                            <Typography variant="body1">
                                                {selectedFile.name}
                                            </Typography>
                                        </Box>
                                        <Typography variant="body2" color="text.secondary">
                                            Taille: {formatFileSize(selectedFile.size)}
                                        </Typography>
                                    </CardContent>
                                </Card>
                            )}
                        </Box>

                        <TextField
                            fullWidth
                            label="Description de l'image"
                            variant="outlined"
                            value={description}
                            onChange={(e) => setDescription(e.target.value)}
                            multiline
                            rows={3}
                            placeholder="Décrivez brièvement cette image médicale (ex: Radio thorax du 15/05/2024)"
                            sx={{ mb: 3 }}
                            disabled={!dossierInfo?.exists}
                        />

                        {uploading && (
                            <Box sx={{ mb: 2 }}>
                                <Typography variant="body2" gutterBottom>
                                    Téléchargement en cours... {uploadProgress}%
                                </Typography>
                                <LinearProgress variant="determinate" value={uploadProgress} />
                            </Box>
                        )}

                        <Button
                            variant="contained"
                            onClick={handleUpload}
                            disabled={!selectedFile || !description.trim() || uploading || !dossierInfo?.exists}
                            startIcon={uploading ? <LinearProgress size={20} /> : <CloudUploadIcon />}
                            fullWidth
                        >
                            {uploading ? 'Téléchargement en cours...' : 'Télécharger l\'image'}
                        </Button>
                    </Paper>

                    {/* Instructions */}
                    <Paper sx={{ p: 2, mt: 2 }}>
                        <Typography variant="h6" gutterBottom>
                            <InfoIcon sx={{ mr: 1, verticalAlign: 'middle' }} />
                            Instructions importantes
                        </Typography>
                        <List dense>
                            <ListItem>
                                <ListItemText 
                                    primary="Format accepté"
                                    secondary="Seuls les fichiers DICOM (.dcm) sont acceptés"
                                />
                            </ListItem>
                            <ListItem>
                                <ListItemText 
                                    primary="Taille maximale"
                                    secondary="La taille maximale par fichier est de 50 MB"
                                />
                            </ListItem>
                            <ListItem>
                                <ListItemText 
                                    primary="Description"
                                    secondary="Ajoutez toujours une description claire pour faciliter l'identification"
                                />
                            </ListItem>
                            <ListItem>
                                <ListItemText 
                                    primary="Confidentialité"
                                    secondary="Vos images sont sécurisées et uniquement accessibles à vos médecins"
                                />
                            </ListItem>
                        </List>
                    </Paper>
                </Grid>

                {/* Informations et historique */}
                <Grid item xs={12} md={4}>
                    {/* Résumé du dossier */}
                    {dossierInfo && (
                        <Paper sx={{ p: 2, mb: 2 }}>
                            <Typography variant="h6" gutterBottom>
                                Mon dossier
                            </Typography>
                            <Divider sx={{ mb: 2 }} />
                            <Typography variant="body2">
                                <strong>Images actuelles:</strong> {dossierInfo.nombreImages}
                            </Typography>
                            <Typography variant="body2">
                                <strong>Observations:</strong> {dossierInfo.nombreObservations}
                            </Typography>
                        </Paper>
                    )}

                    {/* Historique des uploads */}
                    <Paper sx={{ p: 2 }}>
                        <Typography variant="h6" gutterBottom>
                            Historique des téléchargements
                        </Typography>
                        <Divider sx={{ mb: 2 }} />
                        
                        {uploadHistory.length > 0 ? (
                            <List dense>
                                {uploadHistory.slice(0, 5).map((upload) => (
                                    <ListItem key={upload.id}>
                                        <ListItemIcon>
                                            {upload.status === 'success' ? 
                                                <CheckCircleIcon color="success" /> : 
                                                <ErrorIcon color="error" />
                                            }
                                        </ListItemIcon>
                                        <ListItemText
                                            primary={upload.fileName}
                                            secondary={
                                                upload.status === 'success' 
                                                    ? `Téléchargé le ${upload.uploadDate.toLocaleString()}`
                                                    : upload.error
                                            }
                                        />
                                    </ListItem>
                                ))}
                            </List>
                        ) : (
                            <Typography variant="body2" color="text.secondary">
                                Aucun téléchargement récent
                            </Typography>
                        )}
                    </Paper>
                </Grid>
            </Grid>

            <Snackbar
                open={snackbar.open}
                autoHideDuration={6000}
                onClose={handleCloseSnackbar}
                anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
            >
                <Alert
                    onClose={handleCloseSnackbar}
                    severity={snackbar.severity}
                    sx={{ width: '100%' }}
                >
                    {snackbar.message}
                </Alert>
            </Snackbar>
        </Container>
    );
};

export default UploadDicom;

Maintenant, mettons à jour le layout du patient pour inclure les nouvelles routes :

// src/components/layouts/PatientLayout.jsx - Mise à jour complète

import React, { useState } from 'react';
import { Routes, Route } from 'react-router-dom';
import { Box, CssBaseline } from '@mui/material';
import PatientDashboard from '../../pages/patient/PatientDashboard';
import RendezVousPatient from '../../pages/patient/RendezVousPatient';
import DossierMedical from '../../pages/patient/DossierMedical';
import UploadDicom from '../../pages/patient/UploadDicom';
import PatientHeader from '../patient/PatientHeader';
import PatientSidebar from '../patient/PatientSidebar';
import NotFound from '../../pages/NotFound';

const PatientLayout = () => {
    const [drawerOpen, setDrawerOpen] = useState(true);

    const toggleDrawer = () => {
        setDrawerOpen(!drawerOpen);
    };

    return (
        <Box sx={{ display: 'flex' }}>
            <CssBaseline />
            <PatientHeader open={drawerOpen} toggleDrawer={toggleDrawer} />
            <PatientSidebar open={drawerOpen} toggleDrawer={toggleDrawer} />
            <Box
                component="main"
                sx={{
                    flexGrow: 1,
                    height: '100vh',
                    overflow: 'auto',
                    padding: (theme) => theme.spacing(3),
                    paddingTop: '64px', // Hauteur de l'en-tête
                }}
            >
                <Routes>
                    <Route path="dashboard" element={<PatientDashboard />} />
                    <Route path="rendez-vous" element={<RendezVousPatient />} />
                    <Route path="dossier" element={<DossierMedical />} />
                    <Route path="upload" element={<UploadDicom />} />
                    <Route path="*" element={<NotFound />} />
                </Routes>
            </Box>
        </Box>
    );
};

export default PatientLayout;

Maintenant, créons le service backend pour la gestion des images DICOM avec Orthanc :

// OrthancService.java - Service pour l'intégration avec Orthanc

package com.teleconsultation.api.service;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.Base64;
import java.util.Map;

@Service
public class OrthancService {
    
    @Value("${orthanc.server.url}")
    private String orthancUrl;
    
    @Value("${orthanc.server.username}")
    private String orthancUsername;
    
    @Value("${orthanc.server.password}")
    private String orthancPassword;
    
    private final RestTemplate restTemplate;
    
    public OrthancService() {
        this.restTemplate = new RestTemplate();
    }
    
    /**
     * Récupère une image DICOM depuis Orthanc
     * @param orthancId L'identifiant de l'image sur Orthanc
     * @return L'image au format binaire
     */
    public byte[] getImage(String orthancId) {
        String url = orthancUrl + "/instances/" + orthancId + "/file";
        
        HttpHeaders headers = createAuthHeaders();
        HttpEntity<String> entity = new HttpEntity<>(headers);
        
        ResponseEntity<byte[]> response = restTemplate.exchange(
            url,
            HttpMethod.GET,
            entity,
            byte[].class
        );
        
        return response.getBody();
    }
    
    /**
     * Récupère les métadonnées d'une image DICOM
     * @param orthancId L'identifiant de l'image sur Orthanc
     * @return Les métadonnées de l'image
     */
    public Map<String, Object> getImageMetadata(String orthancId) {
        String url = orthancUrl + "/instances/" + orthancId + "/tags";
        
        HttpHeaders headers = createAuthHeaders();
        HttpEntity<String> entity = new HttpEntity<>(headers);
        
        ResponseEntity<Map> response = restTemplate.exchange(
            url,
            HttpMethod.GET,
            entity,
            Map.class
        );
        
        return response.getBody();
    }
    
    /**
     * Téléverse une image DICOM sur Orthanc
     * @param dicomFile Le fichier DICOM
     * @return L'identifiant de l'image sur Orthanc
     */
    public String uploadDicomFile(MultipartFile dicomFile) throws IOException {
        String url = orthancUrl + "/instances";
        
        HttpHeaders headers = createAuthHeaders();
        headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);
        
        HttpEntity<byte[]> entity = new HttpEntity<>(dicomFile.getBytes(), headers);
        
        ResponseEntity<Map> response = restTemplate.exchange(
            url,
            HttpMethod.POST,
            entity,
            Map.class
        );
        
        Map<String, Object> responseBody = response.getBody();
        
        if (responseBody != null && responseBody.containsKey("ID")) {
            return (String) responseBody.get("ID");
        }
        
        throw new RuntimeException("Erreur lors du téléversement du fichier DICOM");
    }
    
    /**
     * Récupère un aperçu de l'image DICOM
     * @param orthancId L'identifiant de l'image sur Orthanc
     * @return L'image de prévisualisation en PNG
     */
    public byte[] getImagePreview(String orthancId) {
        String url = orthancUrl + "/instances/" + orthancId + "/preview";
        
        HttpHeaders headers = createAuthHeaders();
        HttpEntity<String> entity = new HttpEntity<>(headers);
        
        ResponseEntity<byte[]> response = restTemplate.exchange(
            url,
            HttpMethod.GET,
            entity,
            byte[].class
        );
        
        return response.getBody();
    }
    
    /**
     * Vérifie si Orthanc est accessible
     * @return true si Orthanc est accessible
     */
    public boolean isOrthancAvailable() {
        try {
            String url = orthancUrl + "/system";
            
            HttpHeaders headers = createAuthHeaders();
            HttpEntity<String> entity = new HttpEntity<>(headers);
            
            ResponseEntity<Map> response = restTemplate.exchange(
                url,
                HttpMethod.GET,
                entity,
                Map.class
            );
            
            return response.getStatusCode() == HttpStatus.OK;
        } catch (Exception e) {
            return false;
        }
    }
    
    /**
     * Crée les en-têtes d'authentification pour Orthanc
     * @return HttpHeaders avec l'authentification Basic
     */
    private HttpHeaders createAuthHeaders() {
        HttpHeaders headers = new HttpHeaders();
        String auth = orthancUsername + ":" + orthancPassword;
        byte[] encodedAuth = Base64.getEncoder().encode(auth.getBytes());
        String authHeader = "Basic " + new String(encodedAuth);
        headers.set("Authorization", authHeader);
        return headers;
    }
}

Maintenant, créons le contrôleur pour la gestion des images DICOM :

// DicomController.java - Contrôleur pour la gestion des images DICOM

package com.teleconsultation.api.controllers;

import com.teleconsultation.api.models.ImageDICOM;
import com.teleconsultation.api.payload.response.MessageResponse;
import com.teleconsultation.api.service.DossierMedicalService;
import com.teleconsultation.api.service.OrthancService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.Map;

@RestController
@RequestMapping("/api/dicom")
public class DicomController {
    
    @Autowired
    private OrthancService orthancService;
    
    @Autowired
    private DossierMedicalService dossierMedicalService;
    
    /**
     * Récupère une image DICOM depuis Orthanc
     */
    @GetMapping("/{orthancId}")
    @PreAuthorize("hasAnyRole('MEDECIN', 'PATIENT')")
    public ResponseEntity<byte[]> getImage(@PathVariable String orthancId) {
        try {
            byte[] imageData = orthancService.getImage(orthancId);
            return ResponseEntity.ok()
                .contentType(MediaType.APPLICATION_OCTET_STREAM)
                .body(imageData);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Récupère un aperçu de l'image DICOM
     */
    @GetMapping("/{orthancId}/preview")
    @PreAuthorize("hasAnyRole('MEDECIN', 'PATIENT')")
    public ResponseEntity<byte[]> getImagePreview(@PathVariable String orthancId) {
        try {
            byte[] previewData = orthancService.getImagePreview(orthancId);
            return ResponseEntity.ok()
                .contentType(MediaType.IMAGE_PNG)
                .body(previewData);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Récupère les métadonnées d'une image DICOM
     */
    @GetMapping("/{orthancId}/metadata")
    @PreAuthorize("hasAnyRole('MEDECIN', 'PATIENT')")
    public ResponseEntity<Map<String, Object>> getImageMetadata(@PathVariable String orthancId) {
        try {
            Map<String, Object> metadata = orthancService.getImageMetadata(orthancId);
            return ResponseEntity.ok(metadata);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Téléverse une image DICOM
     */
    @PostMapping("/upload/{dossierId}")
    @PreAuthorize("hasRole('PATIENT')")
    public ResponseEntity<?> uploadDicomImage(
            @PathVariable Long dossierId,
            @RequestParam("file") MultipartFile file,
            @RequestParam("description") String description) {
        
        try {
            // Vérifications de base
            if (file.isEmpty()) {
                return ResponseEntity.badRequest()
                    .body(new MessageResponse("Aucun fichier sélectionné"));
            }
            
            // Vérifier la taille du fichier (max 50MB)
            long maxSize = 50 * 1024 * 1024; // 50MB
            if (file.getSize() > maxSize) {
                return ResponseEntity.badRequest()
                    .body(new MessageResponse("Le fichier est trop volumineux (maximum 50MB)"));
            }
            
            // Vérifier le type de fichier
            String fileName = file.getOriginalFilename();
            if (fileName == null || !fileName.toLowerCase().endsWith(".dcm")) {
                return ResponseEntity.badRequest()
                    .body(new MessageResponse("Seuls les fichiers DICOM (.dcm) sont acceptés"));
            }
            
            // Vérifier que le serveur Orthanc est disponible
            if (!orthancService.isOrthancAvailable()) {
                return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE)
                    .body(new MessageResponse("Le serveur d'images médicales n'est pas disponible"));
            }
            
            // Téléverser le fichier sur Orthanc
            String orthancId = orthancService.uploadDicomFile(file);
            
            // Enregistrer l'image dans la base de données
            ImageDICOM imageDICOM = dossierMedicalService.ajouterImageDICOM(
                dossierId, 
                orthancId, 
                description
            );
            
            return ResponseEntity.status(HttpStatus.CREATED).body(imageDICOM);
            
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(new MessageResponse("Erreur lors du téléversement de l'image: " + e.getMessage()));
        }
    }
    
    /**
     * Vérifie le statut du serveur Orthanc
     */
    @GetMapping("/status")
    @PreAuthorize("hasAnyRole('MEDECIN', 'PATIENT', 'ADMIN')")
    public ResponseEntity<Map<String, Object>> getOrthancStatus() {
        boolean available = orthancService.isOrthancAvailable();
        
        Map<String, Object> status = Map.of(
            "available", available,
            "message", available ? "Serveur Orthanc opérationnel" : "Serveur Orthanc non disponible"
        );
        
        return ResponseEntity.ok(status);
    }
}

Maintenant, créons le composant de visualisation DICOM pour le frontend :

// src/components/DicomViewer.jsx - Composant de visualisation des images DICOM

import React, { useState, useEffect } from 'react';
import {
    Dialog,
    DialogTitle,
    DialogContent,
    DialogActions,
    Button,
    CircularProgress,
    Box,
    Typography,
    Slider,
    Grid,
    IconButton,
    Card,
    CardContent,
    Alert
} from '@mui/material';
import {
    ZoomIn,
    ZoomOut,
    Brightness4,
    Brightness7,
    Contrast,
    Flip,
    RotateLeft,
    RotateRight,
    Fullscreen,
    Download,
    Close
} from '@mui/icons-material';
import { getDicomImage, getDicomMetadata, getDicomPreview } from '../services/dicomService';

const DicomViewer = ({ open, onClose, image }) => {
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const [metadata, setMetadata] = useState(null);
    const [previewUrl, setPreviewUrl] = useState(null);
    const [viewportSettings, setViewportSettings] = useState({
        scale: 1,
        windowWidth: 255,
        windowCenter: 127,
        rotation: 0,
        hflip: false,
        vflip: false,
        brightness: 50,
        contrast: 50
    });

    useEffect(() => {
        if (open && image) {
            loadImageData();
        }
        
        // Cleanup
        return () => {
            if (previewUrl) {
                URL.revokeObjectURL(previewUrl);
            }
        };
    }, [open, image]);

    const loadImageData = async () => {
        if (!image) return;
        
        try {
            setLoading(true);
            setError(null);
            
            // Charger l'aperçu de l'image
            const previewResponse = await getDicomPreview(image.orthancId);
            const blob = new Blob([previewResponse.data], { type: 'image/png' });
            const url = URL.createObjectURL(blob);
            setPreviewUrl(url);
            
            // Charger les métadonnées
            try {
                const metadataResponse = await getDicomMetadata(image.orthancId);
                setMetadata(metadataResponse.data);
            } catch (metaError) {
                console.warn('Impossible de charger les métadonnées:', metaError);
                // Continue sans métadonnées
            }
            
        } catch (error) {
            console.error('Erreur lors du chargement de l\'image:', error);
            setError('Impossible de charger l\'image DICOM');
        } finally {
            setLoading(false);
        }
    };

    const handleZoomIn = () => {
        setViewportSettings(prev => ({
            ...prev,
            scale: Math.min(prev.scale * 1.2, 5)
        }));
    };

    const handleZoomOut = () => {
        setViewportSettings(prev => ({
            ...prev,
            scale: Math.max(prev.scale / 1.2, 0.1)
        }));
    };

    const handleRotateLeft = () => {
        setViewportSettings(prev => ({
            ...prev,
            rotation: (prev.rotation - 90) % 360
        }));
    };

    const handleRotateRight = () => {
        setViewportSettings(prev => ({
            ...prev,
            rotation: (prev.rotation + 90) % 360
        }));
    };

    const handleFlipHorizontal = () => {
        setViewportSettings(prev => ({
            ...prev,
            hflip: !prev.hflip
        }));
    };

    const handleFlipVertical = () => {
        setViewportSettings(prev => ({
            ...prev,
            vflip: !prev.vflip
        }));
    };

    const handleBrightnessChange = (event, newValue) => {
        setViewportSettings(prev => ({
            ...prev,
            brightness: newValue
        }));
    };

    const handleContrastChange = (event, newValue) => {
        setViewportSettings(prev => ({
            ...prev,
            contrast: newValue
        }));
    };

    const handleReset = () => {
        setViewportSettings({
            scale: 1,
            windowWidth: 255,
            windowCenter: 127,
            rotation: 0,
            hflip: false,
            vflip: false,
            brightness: 50,
            contrast: 50
        });
    };

    const handleDownload = async () => {
        try {
            const response = await getDicomImage(image.orthancId);
            const blob = new Blob([response.data], { type: 'application/dicom' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `${image.description || 'image_medicale'}.dcm`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            URL.revokeObjectURL(url);
        } catch (error) {
            console.error('Erreur lors du téléchargement:', error);
        }
    };

    const getImageStyle = () => {
        return {
            transform: `
                scale(${viewportSettings.scale}) 
                rotate(${viewportSettings.rotation}deg) 
                ${viewportSettings.hflip ? 'scaleX(-1)' : ''} 
                ${viewportSettings.vflip ? 'scaleY(-1)' : ''}
            `,
            filter: `
                brightness(${viewportSettings.brightness}%) 
                contrast(${viewportSettings.contrast}%)
            `,
            transition: 'transform 0.2s ease, filter 0.2s ease',
            maxWidth: '100%',
            maxHeight: '100%',
            objectFit: 'contain'
        };
    };

    const formatMetadataValue = (key, value) => {
        // Formatter certaines valeurs communes DICOM
        switch (key) {
            case 'StudyDate':
            case 'SeriesDate':
            case 'InstanceCreationDate':
                if (value && value.Value && value.Value[0]) {
                    const dateStr = value.Value[0];
                    return `${dateStr.substring(6, 8)}/${dateStr.substring(4, 6)}/${dateStr.substring(0, 4)}`;
                }
                break;
            case 'PatientName':
            case 'InstitutionName':
            case 'Modality':
                if (value && value.Value && value.Value[0]) {
                    return value.Value[0];
                }
                break;
            default:
                if (value && value.Value) {
                    return Array.isArray(value.Value) ? value.Value.join(', ') : value.Value;
                }
        }
        return 'Non spécifié';
    };

    return (
        <Dialog
            open={open}
            onClose={onClose}
            maxWidth="lg"
            fullWidth
            PaperProps={{
                sx: { height: '90vh' }
            }}
        >
            <DialogTitle>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                    <Typography variant="h6">
                        {image ? image.description || 'Image DICOM' : 'Image DICOM'}
                    </Typography>
                    <IconButton onClick={onClose}>
                        <Close />
                    </IconButton>
                </Box>
            </DialogTitle>
            
            <DialogContent dividers>
                {loading ? (
                    <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: 400 }}>
                        <CircularProgress />
                        <Typography sx={{ ml: 2 }}>Chargement de l'image...</Typography>
                    </Box>
                ) : error ? (
                    <Alert severity="error" sx={{ mt: 2 }}>
                        {error}
                    </Alert>
                ) : (
                    <Grid container spacing={2} sx={{ height: '100%' }}>
                        {/* Zone d'affichage de l'image */}
                        <Grid item xs={12} md={8}>
                            <Box 
                                sx={{ 
                                    border: '1px solid #ddd', 
                                    height: 420, 
                                    display: 'flex', 
                                    justifyContent: 'center', 
                                    alignItems: 'center',
                                    position: 'relative',
                                    backgroundColor: '#000',
                                    overflow: 'hidden'
                                }}
                            >
                                {previewUrl && (
                                    <img
                                        src={previewUrl}
                                        alt="Image DICOM"
                                        style={getImageStyle()}
                                    />
                                )}
                                
                                {/* Barre d'outils flottante */}
                                <Box sx={{ 
                                    position: 'absolute', 
                                    bottom: 16, 
                                    left: '50%', 
                                    transform: 'translateX(-50%)',
                                    display: 'flex', 
                                    gap: 1, 
                                    backgroundColor: 'rgba(0, 0, 0, 0.8)', 
                                    p: 1, 
                                    borderRadius: 2 
                                }}>
                                    <IconButton onClick={handleZoomIn} size="small" sx={{ color: 'white' }}>
                                        <ZoomIn />
                                    </IconButton>
                                    <IconButton onClick={handleZoomOut} size="small" sx={{ color: 'white' }}>
                                        <ZoomOut />
                                    </IconButton>
                                    <IconButton onClick={handleRotateLeft} size="small" sx={{ color: 'white' }}>
                                        <RotateLeft />
                                    </IconButton>
                                    <IconButton onClick={handleRotateRight} size="small" sx={{ color: 'white' }}>
                                        <RotateRight />
                                    </IconButton>
                                    <IconButton onClick={handleFlipHorizontal} size="small" sx={{ color: 'white' }}>
                                        <Flip />
                                    </IconButton>
                                    <IconButton onClick={handleFlipVertical} size="small" sx={{ color: 'white' }}>
                                        <Flip sx={{ transform: 'rotate(90deg)' }} />
                                    </IconButton>
                                    <IconButton onClick={handleReset} size="small" sx={{ color: 'white' }}>
                                        Reset
                                    </IconButton>
                                </Box>
                            </Box>
                        </Grid>
                        
                        {/* Panneau de contrôle */}
                        <Grid item xs={12} md={4}>
                            <Box sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
                                {/* Contrôles d'image */}
                                <Card sx={{ mb: 2 }}>
                                    <CardContent>
                                        <Typography variant="subtitle1" gutterBottom>
                                            <Brightness4 sx={{ mr: 1, verticalAlign: 'middle' }} />
                                            Contrôles d'affichage
                                        </Typography>
                                        
                                        <Box sx={{ mb: 2 }}>
                                            <Typography gutterBottom>Luminosité</Typography>
                                            <Slider
                                                value={viewportSettings.brightness}
                                                onChange={handleBrightnessChange}
                                                min={0}
                                                max={200}
                                                valueLabelDisplay="auto"
                                                size="small"
                                            />
                                        </Box>
                                        
                                        <Box sx={{ mb: 2 }}>
                                            <Typography gutterBottom>Contraste</Typography>
                                            <Slider
                                                value={viewportSettings.contrast}
                                                onChange={handleContrastChange}
                                                min={0}
                                                max={200}
                                                valueLabelDisplay="auto"
                                                size="small"
                                            />
                                        </Box>
                                        
                                        <Typography variant="body2" color="text.secondary">
                                            Zoom: {Math.round(viewportSettings.scale * 100)}%
                                        </Typography>
                                    </CardContent>
                                </Card>
                                
                                {/* Métadonnées */}
                                {metadata && (
                                    <Card sx={{ flexGrow: 1, overflow: 'auto' }}>
                                        <CardContent>
                                            <Typography variant="subtitle1" gutterBottom>
                                                Informations DICOM
                                            </Typography>
                                            
                                            <Box sx={{ maxHeight: 250, overflow: 'auto' }}>
                                                {Object.entries({
                                                    'PatientName': 'Patient',
                                                    'StudyDate': 'Date d\'étude',
                                                    'Modality': 'Modalité',
                                                    'InstitutionName': 'Institution',
                                                    'SeriesDescription': 'Description'
                                                }).map(([key, label]) => {
                                                    const value = metadata[key];
                                                    if (value) {
                                                        return (
                                                            <Box key={key} sx={{ mb: 1 }}>
                                                                <Typography variant="body2">
                                                                    <strong>{label}:</strong> {formatMetadataValue(key, value)}
                                                                </Typography>
                                                            </Box>
                                                        );
                                                    }
                                                    return null;
                                                })}
                                            </Box>
                                        </CardContent>
                                    </Card>
                                )}
                            </Box>
                        </Grid>
                    </Grid>
                )}
            </DialogContent>
            
            <DialogActions>
                <Button onClick={handleDownload} startIcon={<Download />}>
                    Télécharger
                </Button>
                <Button onClick={onClose}>Fermer</Button>
            </DialogActions>
        </Dialog>
    );
};

export default DicomViewer;

Maintenant, créons le service frontend pour la gestion des images DICOM :

// src/services/dicomService.js - Service pour la gestion des images DICOM

import api from './api';

/**
 * Récupère une image DICOM complète
 * @param {string} orthancId - L'identifiant de l'image sur Orthanc
 * @returns {Promise} - Promesse contenant les données de l'image
 */
export const getDicomImage = (orthancId) => {
    return api.get(`/dicom/${orthancId}`, {
        responseType: 'arraybuffer'
    });
};

/**
 * Récupère un aperçu PNG de l'image DICOM
 * @param {string} orthancId - L'identifiant de l'image sur Orthanc
 * @returns {Promise} - Promesse contenant l'aperçu de l'image
 */
export const getDicomPreview = (orthancId) => {
    return api.get(`/dicom/${orthancId}/preview`, {
        responseType: 'arraybuffer'
    });
};

/**
 * Récupère les métadonnées d'une image DICOM
 * @param {string} orthancId - L'identifiant de l'image sur Orthanc
 * @returns {Promise} - Promesse contenant les métadonnées
 */
export const getDicomMetadata = (orthancId) => {
    return api.get(`/dicom/${orthancId}/metadata`);
};

/**
 * Télécharge une image DICOM
 * @param {number} dossierId - L'ID du dossier médical
 * @param {FormData} formData - Les données du fichier à télécharger
 * @returns {Promise} - Promesse de téléchargement
 */
export const uploadDicomImage = (dossierId, formData) => {
    return api.post(`/dicom/upload/${dossierId}`, formData, {
        headers: {
            'Content-Type': 'multipart/form-data'
        },
        onUploadProgress: (progressEvent) => {
            // Cette fonction peut être utilisée pour suivre le progrès
            const percentCompleted = Math.round(
                (progressEvent.loaded * 100) / progressEvent.total
            );
            console.log(`Upload progress: ${percentCompleted}%`);
        }
    });
};

/**
 * Vérifie le statut du serveur Orthanc
 * @returns {Promise} - Promesse contenant le statut du serveur
 */
export const getOrthancStatus = () => {
    return api.get('/dicom/status');
};

Finalement, mettons à jour le service pour le médecin afin d'inclure les nouvelles fonctionnalités :

// src/services/medecinService.js - Service médecin complet

import api from './api';

// ===== RENDEZ-VOUS =====

// Obtenir les prochains rendez-vous du médecin
export const getProchainRendezVous = (medecinId) => {
    return api.get(`/medecin/${medecinId}/rendez-vous/prochains`);
};

// Obtenir les statistiques du médecin
export const getStatistiques = (medecinId) => {
    return api.get(`/medecin/${medecinId}/statistiques`);
};

// Obtenir tous les rendez-vous du médecin
export const getAllRendezVous = (medecinId) => {
    return api.get(`/medecin/${medecinId}/rendez-vous`);
};

// Valider un rendez-vous
export const validerRendezVous = (rendezVousId) => {
    return api.put(`/rendez-vous/${rendezVousId}/valider`);
};

// Rejeter un rendez-vous
export const rejeterRendezVous = (rendezVousId, rejetData = {}) => {
    return api.put(`/rendez-vous/${rendezVousId}/rejeter`, rejetData);
};

// ===== DOSSIERS MÉDICAUX =====

// Obtenir les dossiers médicaux des patients du médecin
export const getDossiersMedicaux = (medecinId) => {
    return api.get(`/dossiers/medecin/${medecinId}`);
};

// Obtenir un dossier médical spécifique
export const getDossierMedical =



